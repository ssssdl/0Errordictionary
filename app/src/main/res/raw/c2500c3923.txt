编译器错误 C2500 Compiler Error C2500 11
已直接基类类或结构的基类列表中多次出现。直接基是基础列表中所述。间接基类是基类的基础列表中的类之一。一个类不能多次指定为直接基类。类可以用作间接基类不止一次。下面的示例生成 C2500: The following sample generates C2500: // C2500.cpp  
// compile with: /c  
class A {};  
class B : public A, public A {};    // C2500  

// OK  
class C : public A {};  
class D : public A {};  
class E : public C, public D {};

编译器错误 C2502 Compiler Error C2502 11
：上的基类的访问修饰符太多基本类具有多个访问修饰符。只能有一个访问修饰符，，或允许。下面的示例生成 C2502: The following sample generates C2502: // C2502.cpp  
// compile with: /c  
class A { };  
class B { };  
class C : private public A { };   // C2502  

// OK  
class D : private A {};  
class E : public A, private B {};

编译器错误 C2503 Compiler Error C2503 11
：基类，这些类不能包含零大小的数组基类或结构包含零大小的数组。类中的数组必须具有至少一个元素。下面的示例生成 C2503: The
following sample generates C2503: // C2503.cpp
// compile with: /c  
class A {  
   public:  
   int array [];  
};  

class B : A {};    // C2503  

class C {  
public:  
   int array [10];  
};  

class D : C {};

编译器错误 C2504 Compiler Error C2504 11
：未定义的基类声明的基类，但是永远不会定义。可能的原因：缺少包含文件。使用不声明外部的基类。下面的示例生成 C2504: The following sample generates C2504: // C2504.cpp  
// compile with: /c  
class A;  
class B : public A {};   // C2504 还行 // OK class C{};  
class D : public C {};

编译器错误 C2505 Compiler Error C2505 11
只能应用于声明或定义的全局对象或静态数据成员函数中使用了设计为仅使用在全局范围内的修饰符。有关详细信息，请参见应用程序域和过程。下面的示例生成 C2505: The following sample generates C2505: // C2505.cpp  
// compile with: /clr  

// OK  
__declspec(process) int ii;  
__declspec(appdomain) int jj;  

int main() {  
   __declspec(process) int i;   // C2505  
   __declspec(appdomain) int j;   // C2505  
}

编译器错误 C2506 Compiler Error C2506 11
不能应用于此符号不能为托管类的静态成员声明每个进程或每个。有关更多信息，请参见。示例下面的示例生成 C2506。 The following sample generates C2506. // C2506.cpp  
// compile with: /clr /c  
ref struct R {  
   __declspec(process) static int n;   // C2506  
   int o;   // OK  
};

编译器错误 C2507 Compiler Error C2507 11
：基的类上的虚拟修饰符太多类或结构声明为不止一次。只有一个修饰符可以出现在列表中每个类的基类，这些类。下面的示例生成 C2507: The following sample generates C2507: // C2507.cpp  
// compile with: /c  
class A {};  
class B : virtual virtual public A {};   // C2507  
class C : virtual public A {};   // OK

编译器错误 C2509 Compiler Error C2509 11
：未在中声明的成员函数未在指定的类中声明函数。示例下面的示例生成 C2509。 The following sample generates C2509. // C2509.cpp  
// compile with: /c  
struct A {  
   virtual int vfunc() = 0;  
   virtual int vfunc2() = 0;  
};  

struct B : private A {  
   using A::vfunc;  
   virtual int vfunc2();  
};  

int B::vfunc() { return 1; }   // C2509  
int B::vfunc2() { return 1; }   // OK

编译器错误 C2510 Compiler Error C2510 11
“”：“”的左边必须是类结构联合类、结构或联合名称必须显式在范围解析运算符（）运算符的左侧。

编译器错误 C2511 Compiler Error C2511 11
：重载中找不到的成员函数使用指定的参数不声明的函数的任何版本。可能的原因：错误的参数传递给函数。在错误的顺序传递的参数。参数名称拼写不正确。下面的示例生成 C2511: The following sample generates C2511: // C2511.cpp  
// compile with: /c  
class C {  
   int c_2;  
   int Func(char *, char *);  
};  

int C::Func(char *, char *, int i) {   // C2511  
// try the following line instead  
// int C::Func(char *, char *) {  
   return 0;  
}

编译器错误 C2512 Compiler Error C2512 11
标识符：没有适当的默认构造函数可用默认构造函数，不需要任何参数的构造函数不可用于指定的类、结构或联合。仅当提供了没有用户定义的构造函数，编译器将提供默认构造函数。如果你提供具有非参数的构造函数，你想要允许你的类以创建不带任何参数（例如，作为数组的元素），你还必须提供一个默认构造函数。默认构造函数可以是一个所有参数都使用默认值的构造函数。示例错误的常见原因是当你定义的类或结构的构造函数采用自变量时，然后你尝试声明类或结构不带任何参数的实例。例如，下面声明的构造函数的需要自变量，而不是不带任何参数。在，声明的实例，但未提供参数。编译器生成，因为它找不到默认构造函数。你可以通过定义默认构造函数为结构或类，如修复此问题，或其中的所有自变量具有默认值，如构造函数。

编译器错误 C2513 Compiler Error C2513 11
之前的任何变量声明类型说明符出现在不带任何变量的标识符的声明。下面的示例生成 C2513: The following sample generates C2513: // C2513.cpp  
int main() {  
   int = 9;   // C2513  
   int i = 9;   // OK  
} 此错误还可能来自于为 Visual Studio.NET 2003年执行的编译器一致性工作： 不再允许的 typedef 的初始化。 This error can also be generated as a result of a compiler conformance work done for Visual Studio .NET 2003: initialization of a typedef no longer allowed. Typedef 的初始化不允许使用由标准，并且现在将生成编译器错误。 The initialization of a typedef is not allowed by the standard and now generates a compiler error. // C2513b.cpp  
// compile with: /c  
typedef struct S {  
   int m_i;  
} S = { 1 };   // C2513  
// try the following line instead  
// } S; 一种替代方法是删除 typedef 定义的变量聚合初始值设定项列表，但这不建议，因为它将创建具有相同名称作为类型的变量和隐藏的类型名称。 An alternative would be to delete typedef to define a variable with aggregate initializer list, but this is not recommended because it will create a variable with the same name as the type and hide the type name.

编译器错误 C2514 Compiler Error C2514 11
：类具有任何构造函数类、结构或联合具有使用参数列表相匹配所用其进行实例化参数没有构造函数。它可以实例化之前，必须完全声明一个类。下面的示例生成 C2514: The following sample generates C2514: // C2514.cpp  
// compile with: /c  
class f;  

class g {  
public:  
    g (int x);  
};  

class fmaker {  
   f *func1() {  
      return new f(2);   // C2514  
   }  

   g *func2() {  
      return new g(2);   // OK  
   }  
};

编译器错误 C2516 Compiler Error C2516 11
：不是合法的基本类类派生自定义的类型名称语句。下面的示例生成 C2516: The following sample generates C2516: // C2516.cpp  
typedef unsigned long ulong;  
class C : public ulong {}; // C2516

编译器错误 C2517 Compiler Error C2517 11
：右侧的未定义范围解析运算符右侧的标识符必须是定义的类、结构或在左侧的联合成员。如果名为任何类、结构或联合，则必须具有全局作用域声明在右侧的标识符。

编译器错误 C2518 Compiler Error C2518 11
关键字非法基类列表中忽略关键字和不应出现在基类列表。下面的示例生成 C2518: The following sample generates C2518: // C2518.cpp  
// compile with: /c  
class B {};  
class C : public class B {};   // C2518  
class D: public B {};   // OK

编译器错误 C2521 Compiler Error C2521 11
函数不采用任何参数你试图使用析构函数或终结器的参数。有关详细信息，请参阅析构函数和终结器。示例下面的示例生成 C2521。 The following sample generates C2521. // C2521.cpp  
// compile with: /clr  
ref class R {  
protected:  
   !R() {}  

public:  
   void CleanUp() {  
      this->!R(4);   // C2521  
      this->!R();   // OK  
   }  
};  

int main() {  
   R^ r = gcnew R();  
   r->CleanUp();  
}

编译器错误 C2523 Compiler Error C2523 11
类标识符：析构函数终结器标记不匹配析构函数的名称必须是类名前面是波形符。构造函数和析构函数是仅具有与类相同的名称的成员。下面的示例生成 C2523: The following sample generates C2523: // C2523.cpp  
// compile with: /c  
class A {  
   ~B();    // C2523  
   ~A();   // OK  
};

编译器错误 C2524 Compiler Error C2524 11
析构函数：析构函数终结器必须具有参数列表析构函数或终结器具有不是一个参数列表。不允许其他参数类型。示例下面的代码再现。示例下面的代码再现。

编译器错误 C2526 Compiler Error C2526 11
链接函数不能返回类定义带链接的函数无法返回的用户定义的类型。

编译器错误 C2528 Compiler Error C2528 11
：指针引用是非法的不能声明为引用的指针。在声明指向它的指针之前取消引用该变量。下面的示例生成 C2528: The following sample generates C2528: // C2528.cpp  
int i;  
int &ir = i;  
int & (*irptr) = ir;    // C2528

编译器错误 C2529 Compiler Error C2529 11
：引用的引用是非法的：使用指针的语法，并声明对指针的引用，则可能修复此错误。下面的示例生成 C2529: The following sample generates C2529: // C2529.cpp  
// compile with: /c  
int i;  
int &ri = i;  
int &(&rri) = ri;   // C2529

编译器错误 C2530 Compiler Error C2530 11
：必须初始化引用你必须初始化引用声明它时，除非它已被声明：使用关键字。作为类、结构或联合的成员（和构造函数中初始化）。作为函数声明或定义中的参数。作为函数的返回类型。下面的示例生成 C2530: The following sample generates C2530: // C2530.cpp  
int main() {  
   int i = 0;  
   int &j;   // C2530  
   int &k = i;   // OK  
}

编译器错误 C2531 Compiler Error C2531 11
：对有点字段非法引用不允许对位域的引用。下面的示例生成 C2531: The following sample generates C2531: // C2531.cpp  
// compile with: /c  
class P {  
   int &b1 : 10;   // C2531  
   int b2 : 10;   // OK  
};

编译器错误 C2532 Compiler Error C2532 11
：非法引用修饰符引用已被更改。无法修改引用以引用另一个对象。而是使用指针。

编译器错误 C2533 Compiler Error C2533 11
“”构造函数不能有返回类型构造函数不能具有返回类型（甚至不能是返回类型）。此错误的常见来源是类定义结尾与第一个构造函数实现之间缺少分号。编译器会将类视为构造函数返回类型的定义，会生成。下面的示例生成 C2533，并演示如何修复此错误： The following sample generates C2533, and shows how to fix it: // C2533.cpp  
// compile with: /c  
class X {  
public:  
   X();     
};  

int X::X() {}   // C2533 - constructor return type not allowed  
X::X() {}   // OK - fix by using no return type

编译器错误 C2534 Compiler Error C2534 11
：构造函数无法返回值构造函数不能返回值或具有返回类型甚至不返回类型。通过删除可能会修复此错误从构造函数定义的语句。下面的示例生成 C2534: The following sample generates C2534: // C2534.cpp  
class A {  
public:  
   int i;  
   A() { return i; }   // C2534  
};

编译器错误 C2535 Compiler Error C2535 11
：已定义或声明的成员函数无法通过使用多个定义或重载函数的声明中的同一形式参数列表导致此错误。如果您因为函数获得，请参阅析构函数和终结器有关详细信息。如果您正在编译的项目，请参阅知识库文章。下面的示例生成 C2535: The following sample generates C2535: // C2535.cpp  
// compile with: /c  
class C {  
public:  
   void func();   // forward declaration  
   void func() {}   // C2535  
};

编译器错误 C2537 Compiler Error C2537 11
：非法链接规范可能的原因：不支持链接说明符。支持的链接说明符。对于重载函数的一组中的多个函数指定了链接。这是不允许的。下面的示例生成 C2537: The following sample generates C2537: // C2537.cpp  
// compile with: /c  
extern "c" void func();   // C2537  
extern "C" void func2();   // OK

编译器错误 C2540 Compiler Error C2540 11
作为数组界限的非常量表达式数组必须具有常量绑定。下面的示例生成 C2540: The following sample generates C2540: // C2540.cpp  
void func(int n, int pC[]) {  
   int i = ((int [n])pC)[1];   // C2540  
}  

void func2(int n, int pC[]) {  
   int i = (pC)[1];   // OK  
}  

int main() {  
   int pC[100];  
   func(100, pC);  
   func2(100, pC);  
}

编译器错误 C2541 Compiler Error C2541 11
删除：无法删除不是指针的对象删除在不是指针的对象上使用运算符。下面的示例生成 C2541: The following sample generates C2541: // C2541.cpp  
int main() {  
   int i;  
   delete i;   // C2541 i not a pointer  

   // OK  
   int *ip = new int;  
   delete ip;  
}

编译器错误 C2542 Compiler Error C2542 11
：类对象具有初始化没有构造函数没有使用参数列表相匹配初始化的构造函数。在初始化参数不正确可以导致此错误。

编译器错误 C2543 Compiler Error C2543 11
预期运算符下标运算符缺少左的括号。宏扩展可以导致此错误。

编译器错误 C2544 Compiler Error C2544 11
预期运算符（）函数调用运算符缺少左的括号。宏扩展可以导致此错误。

编译器错误 C2545 Compiler Error C2545 11
：无法查找重载运算符运算符不能与提供的操作数中使用。必须提供所需的操作数重载的运算符。如果操作数具有不正确的类型，则可以导致此错误。如果你定义的转换运算符或构造函数采用单个参数，则可能会修复此错误。

编译器错误 C2548 Compiler Error C2548 11
：缺少参数参数的默认参数默认参数列表中缺少参数。如果你提供任何位置中的参数列表的默认参数，你必须定义所有后续的参数的默认参数。示例下面的示例生成 C2548: The following sample generates C2548: // C2548.cpp  
// compile with: /c  
void func( int = 1, int, int = 3);  // C2548  

// OK  
void func2( int, int, int = 3);  
void func3( int, int = 2, int = 3);

编译器错误 C2549 Compiler Error C2549 11
用户定义的转换不能指定返回类型下面的示例生成 C2549: The following sample generates C2549: // C2549.cpp  
// compile with: /c  
class X {  
public:  
   int operator int() { return value; }   // C2549  

   // try the following line instead  
   // operator int() { return value; }  
private:  
   int value;  
};

编译器错误 C2550 Compiler Error C2550 11
：构造函数定义上只允许构造函数初始值设定项列表不是一个构造函数的函数定义中使用基本类初始值设定项列表。下面的示例生成 C2550: The following sample generates C2550: // C2550.cpp  
// compile with: /c  
class C {  
public:  
   C();  
};  

class D : public C {  
public:  
   D();  
   void func();  
};  

void D::func() : C() {}  // C2550  
D::D() : C() {}   // OK

编译器错误 C2551 Compiler Error C2551 11
“”类型需要显式转换通过隐式转换将指针分配给了非指针。必须使用显式转换。

编译器错误 C2552 Compiler Error C2552 11
“标识符”：不能用初始值设定项列表初始化非聚合错误初始化了聚合标识符。聚合定义为：数组不具有以下项的类、结构和联合：构造函数私有成员或受保护成员基类虚函数此外，不允许在包含构造函数的聚合中使用数据类型。以下内容表示在尝试对类型进行聚合初始化时可能触发的原因：类型拥有一个或多个用户定义的构造函数。类型拥有一个或多个非静态的私有数据成员。类型拥有一个或多个虚函数。类型拥有一个基类。类型是类或接口。类型拥有一个其元素具有析构函数的不固定的维度数组（零数组）。以下示例生成：

编译器错误 C2553 Compiler Error C2553 11
：重写虚函数返回类型不同于派生类中的函数尝试重写基类中的虚函数，但派生的类函数不具有相同的返回类型作为基类函数。重写函数签名必须与被重写的函数的签名匹配。下面的示例生成 C2553: The following sample generates C2553: // C2553.cpp  
// compile with: /clr /c  
ref struct C {  
   virtual void f();  
};  

ref struct D : C {  
   virtual int f() override ;   // C2553   

   // try the following line instead  
   // virtual void f() override;  
};

编译器错误 C2555 Compiler Error C2555 11
：重写虚函数返回类型不同，且不从协变虚函数和派生的重写函数具有相同的参数列表，但返回类型不同。在派生类中的重写函数不能从中只是其返回类型的基类的虚函数。若要解决此错误，将返回的值转换后调用的虚拟函数。如果使用进行编译，也可能会看到此错误。例如，等效于下面的 yiw声明：的详细信息，请参阅知识库文章。下面的示例生成 C2555: The following sample generates C2555: // C2555.cpp  
// compile with: /c  
struct X {  
   virtual void func();  
};  
struct Y : X {  
   char func();  // C2555  
   void func2();   // OK  
};

编译器错误 C2556 Compiler Error C2556 11
：重载的函数的区别仅在于返回类型重载的函数具有不同的返回类型，但相同的参数列表。每个重载的函数必须具有不同的形式参数列表。下面的示例生成 C2556: The following sample generates C2556: // C2556.cpp  
// compile with: /c  
class C {  
   int func();  
   double func();   // C2556  
   int func(int i);   // ok parameter lists differ  
};

编译器错误 C2557 Compiler Error C2557 11
“”：没有构造函数则不能初始化私有成员和受保护成员只有成员和朋友可以给私有或受保护成员赋值。非公共成员应在类构造函数中初始化。

编译器错误 C2558 Compiler Error C2558 11
“”没有可用的复制构造函数或复制构造函数声明为“”复制构造函数从同一类型的另一个对象初始化某对象。（它生成源对象的副本。）如果没有定义任何构造函数，则编译器生成默认复制构造函数。修复此错误的方法在尝试复制其复制构造函数为的类时，可能出现该问题。在大多数情况下，不应复制具有复制构造函数的类。通用编程技术声明复制构造函数以防止直接使用类。该类本身可能无用，或需要另一个类才能正常工作。如果确定可安全地使用具有复制构造函数的类，请从该具有构造函数的类派生一个新类，并使或复制构造函数在该新类中可用。使用该派生类替代原始类。在尝试复制其复制构造函数为显式的类时，可能出现该问题。将复制构造函数声明为会阻止将类的对象传递到对象或从函数到类的对象。有关显式构造函数的详细信息，请参阅用户定义类型转换。当尝试复制使用不采用引用参数声明的类实例时，可能出现该问题。请使用类型引用而不是非常量类型引用声明复制构造函数。

编译器错误 C2561 Compiler Error C2561 11
：函数必须返回值该函数被声明为返回一个值，但函数定义不包含语句。此错误可能引起错误的函数原型：如果该函数不返回一个值，请声明该函数返回类型与。检查所有可能分支的函数返回在原型中声明的类型的值。函数，其中包含存储中的返回值的内联程序集例程注册可能需要的语句。中的值复制到临时变量并从函数返回该变量。下面的示例生成 C2561: The following sample generates C2561: // C2561.cpp  
int Test(int x) {  
   if (x) {  
      return;   // C2561  
      // try the following line instead  
      // return 1;  
   }  
   return 0;  
}  

int main() {  
   Test(1);  
}

编译器错误 C2562 Compiler Error C2562 11
函数返回值该函数声明为但返回一个值。不正确的函数原型可以导致此错误。如果函数声明中指定的返回类型，可能会修复此错误。下面的示例生成 C2562: The following sample generates C2562: // C2562.cpp  
// compile with: /c  
void testfunc() {  
   int i;  
   return i;   // C2562 delete the return to resolve  
}

编译器错误 C2563 Compiler Error C2563 11
形参表中的不匹配函数（或指向函数的指针）的正式参数列表不匹配的另一个函数（或指向成员函数）。因此，无法进行分配函数或指针。下面的示例生成 C2563: The following sample generates C2563: // C2563.cpp  
void func( int );  
void func( int, int );  
int main() {  
   void *fp();  
   fp = func;   // C2563  
}

编译器错误 C2566 Compiler Error C2566 11
条件表达式中的重载的函数无法评估条件表达式中的重载的函数。

编译器错误 C2567 Compiler Error C2567 11
无法打开中的元数据，文件可能已删除或移动在源中引用的元数据文件与未找到位于同一目录中由编译器后端进程按照原样编译器前端进程。请参阅指令有关详细信息。如果使用进行编译则可能导致在某个上计算机，然后尝试在其他计算机上的链接时代码生成。有关详细信息，请参阅（链接时间代码生成）。此外，它也可能表示你的计算机已没有更多内存。若要更正此错误，请确保元数据文件位于相同的目录位置为生成过程的所有阶段。

编译器错误 C2568 Compiler Error C2568 11
：无法解析函数重载编译器无法确定哪一个重载函数调用。传递给函数的实际参数必须强制转换，以匹配重载函数，之一的正式参数但没有一个匹配项是明确优于其他所有类型。

编译器错误 C2569 Compiler Error C2569 11
：枚举联合不能用作基类如果你必须派生自指定的联合或枚举类型，将更改该联合或枚举，为类或结构。下面的示例生成 C2569: The following sample generates C2569: // C2569.cpp  
// compile with: /c  
union ubase {};  
class cHasPubUBase : public ubase {};   // C2569  
// OK  
struct sbase {};  
class cHasPubUBase : public sbase {};

编译器错误 C2570 Compiler Error C2570 11
：联合不能具有基类联合派生自类、结构或联合。这是不允许的。而是将派生的类型声明为类或结构。下面的示例生成 C2570: The following sample generates C2570: // C2570.cpp  
// compile with: /c  
class base {};  
union hasPubBase : public base {};   // C2570  
union hasNoBase {};   // OK

编译器错误 C2571 Compiler Error C2571 11
：虚函数不能为联合联合中与虚函数声明的联合。您可以声明只能在类或结构中的虚拟函数。可能的解决方法：将联合更改为类或结构。使非虚拟函数。下面的示例生成 C2571: The following sample generates C2571: // C2571.cpp  
// compile with: /c  
union A {  
   virtual void func1();   // C2571  
   void func2();   // OK  
};

编译器错误 C2572 Compiler Error C2572 11
：重定义的默认参数：参数默认参数不能重新定义。如果你需要另一个参数的值，默认参数应保持为未定义状态。下面的示例生成 C2572: The following sample generates C2572: // C2572.cpp  
// compile with: /c  
void f(int i = 1);   // function declaration  

// function definition  
void f(int i = 1) {}   // C2572  

// try the following line instead  
// void f(int i) {}

编译器错误 C2573 Compiler Error C2573 11
“”：不能删除指向此类对象的指针；该类没有“”的非位置重载。该类缺少非位置运算符。

编译器错误 C2574 Compiler Error C2574 11
析构函数：不能声明为静态可以声明析构函数和构造函数都不。下面的示例生成 C2574: The following sample generates C2574: // C2574.cpp  
// compile with: /c  
class A {  
   virtual static ~A();   // C2574  
   //  try the following line instead  
   // virtual ~A();  
};

编译器错误 C2575 Compiler Error C2575 11
：只能成员函数和基虚拟全局函数或类声明为。这是不允许的。下面的示例生成 C2575: The following sample generates C2575: // C2575.cpp  
// compile with: /c  
virtual void func() {}   // C2575  

void func2() {}  
struct A {  
   virtual void func2(){}  
};

编译器错误 C2577 Compiler Error C2577 11
：析构函数终结器不能有返回类型析构函数或终结器不能返回值为或任何其他类型。删除从析构函数定义的语句。示例下面的示例生成 C2577。 The following sample generates C2577. // C2577.cpp  
// compile with: /c  
class A {  
public:  
   A() {}  
   ~A(){  
      return 0;   // C2577  
   }  
};

编译器错误 C2579 Compiler Error C2579 11
无法解析类型（偏移量）。应在文件中始终遵循。有关详细信息，请参阅编译器警告（等级）。

编译器错误 C2581 Compiler Error C2581 11
：静态运算符是非法的函数分配运算符未正确声明为。赋值运算符不能为。有关详细信息，请参阅用户定义的运算符。示例下面的示例生成 C2581。 The following sample generates C2581. // C2581.cpp  
// compile with: /clr /c  
ref struct Y {  
   static Y ^ operator = (Y^ me, int i);   // C2581  
   Y^ operator =(int i);   // OK  
};

编译器错误 C2582 Compiler Error C2582 11
函数是中不可用尝试将分配给没有赋值运算符的对象。下面的示例生成 C2582: The following sample generates C2582: // C2582.cpp  
// compile with: /clr  
using namespace System;  

struct N {};  
ref struct O {};  
ref struct R {  
   property O prop;   // C2582  
   property O ^ prop2;   // OK  
};  

int main() {  
   String ^ st1 = gcnew String("");  
   ^st1 = gcnew String("");   // C2582  
   st1 = "xxx";   // OK  
}

编译器错误 C2583 Compiler Error C2583 11
指针是非法的构造函数析构函数声明构造函数或析构函数或。这是不允许的。下面的示例生成 C2583: The following sample generates C2583: // C2583.cpp  
// compile with: /c  
class A {  
public:  
   int i;  
   A() const;   // C2583  

   // try the following line instead  
   // A();  
};

编译器错误 C2584 Compiler Error C2584 11
：直接基不可访问已一个基的已直接从派生。又派生自。不能从派生因为这可能意味着从（间接）继承同样，这是不合法因为已直接基类。示例下面的示例生成 C2584。 The following sample generates C2584. // C2584.cpp  
// compile with: /c  
struct A1 {  
   virtual int MyFunction();  
};  

struct A2 {  
    virtual int MyFunction();  
};  

struct B1: public virtual A1, virtual A2 {  
    virtual int MyFunction();  
};  

struct B2: public virtual A2, virtual A1 {  
    virtual int MyFunction();  
};  

struct C: virtual B1, B2 {  
    virtual int MyFunction();  
};  

struct Z : virtual B2, virtual C {   // C2584  
// try the following line insted  
// struct Z : virtual C {  
    virtual int MyFunction();  
};

编译器错误 C2585 Compiler Error C2585 11
显式转换为不明确类型转换可以生成多个结果。通过检查以下可能的原因进行修复从基于多个继承的类或结构类型转换。如果该类型多次继承相同的基类的转换函数或运算符必须使用范围解析指定哪些继承的类，在转换中使用。转换运算符和一个构造函数定义了进行相同的转换。

编译器错误 C2586 Compiler Error C2586 11
不正确的用户定义的转换语法：非法的间接寻址不允许的转换运算符的间接寻址。下面的示例生成 C2586: The following sample generates C2586: // c2586.cpp  
// compile with: /c  
struct C {  
   * operator int();   // C2586  
   operator char();   // OK  
};

编译器错误 C2587 Compiler Error C2587 11
：非法用作本地变量的默认参数本地变量不允许作为默认参数。下面的示例生成 C2587: The following sample generates C2587: // C2587.cpp  
// compile with: /c  
int i;  
void func() {  
   int j;  
   extern void func2( int k = j );  // C2587 -- local variable  
   extern void func3( int k = i );   // OK  
}

编译器错误 C2588 Compiler Error C2588 11
标识符：非法的全局析构函数类、结构或联合以外为内容定义了析构函数。这是不允许的。此错误可能引起缺少类、结构或联合名称在范围解析左侧运算符。下面的示例生成 C2588: The following sample generates C2588: // C2588.cpp  
~F();   // C2588

编译器错误 C2589 Compiler Error C2589 11
：非法的标记，在右侧如果类、结构或联合名称显示范围解析运算符（双冒号）的左侧，在右侧的令牌必须是类、结构或联合成员。否则，任何全局标识符可以出现在右侧。范围解析运算符无法进行重载。下面的示例生成 C2589: The following sample generates C2589: // C2589.cpp  
void Test(){}  
class A {};  
void operator :: ();   // C2589  

int main() {  
   ::Test();  
}

编译器错误 C2592 Compiler Error C2592 11
“”：“”继承自“”，无法重新指定你仅可指定不是继承自其他基类的基类。在此情况下，的规范中仅需要，因为已继承。

编译器错误 C2593 Compiler Error C2593 11
运算符不明确为重载运算符定义了多个可能的运算符。如果上一个或多个实际参数使用显式强制转换，则可能会修复此错误。下面的示例生成 C2593: The following sample generates C2593: // C2593.cpp  
struct A {};  
struct B : A {};  
struct X {};  
struct D : B, X {};  
void operator+( X, X );  
void operator+( A, B );  
D d;  

int main() {  
   d +  d;         // C2593, D has an A, B, and X   
   (X)d + (X)d;    // OK, uses operator+( X, X )  
} 此错误可能由序列化浮点变量 using CArchive 对象。 This error can be caused by serializing a floating-point variable using a CArchive object. 编译器标识 << 为不明确的运算符。 The compiler identifies the << operator as ambiguous. 仅基元 c + + 类型 CArchive 可以序列化是固定大小类型 BYTE ， WORD ， DWORD ，和 LONG 。 The only primitive C++ types that CArchive can serialize are the fixed-size types BYTE , WORD , DWORD , and LONG . 用于序列化，所有的整数类型必须转换为这些类型之一。 All integer types must be cast to one of these types for serialization. 必须使用存档浮点类型 CArchive::Write() 成员函数。 Floating-point types must be archived using the CArchive::Write() member function. 下面的示例演示如何存档浮点变量 ( f ) 到存档 ar : The following example shows how to archive a floating-point variable ( f ) to archive ar : ar.Write(&f, sizeof( float ));

编译器错误 C2594 Compiler Error C2594 11
：从到的不明确转换从任何转换到比任何其他更直接。我们建议从转换的两个可能的解决方案到。第一个选项是定义从直接转换到，和第二个选项是指定的转换从序列到。下面的示例生成 C2594。 The following sample generates C2594. 到错误的建议解决方法是一系列的转换： The suggested resolution to the error is a sequence of conversions: // C2594.cpp  
// compile with: /c  
struct A{};  
struct I1 : A {};  
struct I2 : A {};  
struct D : I1, I2 {};  

A *f (D *p) {  
   return (A*) (p);    // C2594  

// try the following line instead  
// return static_cast<A *>(static_cast<I1 *>(p));  
}

编译器错误 C2597 Compiler Error C2597 11
对非静态成员“”的非法引用可能的原因：在静态成员函数中指定了非静态成员。若要访问非静态成员，必须传入或创建类的本地实例并使用成员访问运算符（或）。指定标识符不是类、结构或联合的成员。检查标识符拼写。成员访问运算符引用非成员函数。下面的示例生成 C2597，并演示如何修复此错误： The following sample generates C2597 and shows how to fix it: // C2597.cpp  
// compile with: /c  
struct s1 {  
   static void func();  
   static void func2(s1&);  
   int i;  
};  

void s1::func() {  
   i = 1;    // C2597 - static function can't access non-static data member  
}  

// OK - fix by passing an instance of s1  
void s1::func2(s1& a) {  
   a.i = 1;  
}

编译器错误 C2598 Compiler Error C2598 11
链接规范必须在全局范围内在本地范围声明链接说明符。下面的示例生成 C2598: The following sample generates C2598: // C2598.cpp  
// compile with: /c  
void func() {  
   extern "C" int func2();   // C2598  
}  

extern "C" int func( int i );

编译器错误 C2599 Compiler Error C2599 11
不允许前向声明的枚举类型编译器不再支持托管枚举的前向的声明。前向声明的枚举类型，不允许在。下面的示例生成 C2599: The following sample generates C2599: // C2599.cpp  
// compile with: /clr /c  
enum class Status;   // C2599  

enum class Status2 { stop2, hold2, go2};   

ref struct MyStruct {  
   // Delete the following line to resolve.  
   Status m_status;  

   Status2 m_status2;   // OK  
};  

enum class Status { stop, hold, go };

编译器错误 C2600 Compiler Error C2600 11
：不能定义（必须在声明类第一次）的编译器生成的特殊成员函数在为类定义成员函数（如构造函数或析构函数）之前，必须在类中声明它们。如果没有在类中声明，则编译器会生成默认的构造函数和析构函数（称为特殊成员函数）。但是，如果在类中定义这些函数中没有匹配声明的函数，则编译器将检测到冲突。若要修复此错误，请在类声明中，声明你在类声明以外定义的每个成员函数。以下示例生成：

编译器错误 C2601 Compiler Error C2601 11
：局部函数定义是非法的代码尝试定义函数中的函数。或者，错误的位置之前在源代码中可能有一个额外的大括号。下面的示例生成 C2601: The following sample generates C2601: // C2601.cpp  
int main() {  
   int i = 0;  

   void funcname(int j) {   // C2601  
      j++;  
   }  
}

编译器错误 C2602 Compiler Error C2602 11
不是基类的的成员无法访问，因为它不是从任何基类继承的成员。下面的示例生成 C2602: The following sample generates C2602: // C2602.cpp  
// compile with: /c  
struct X {  
   int x;  
};  
struct A {  
   int a;  
};  
struct B : public A {  
   X::x;   // C2602 B is not derived from X  
   A::a;   // OK  
};

编译器错误 C2603 Compiler Error C2603 11
函数：太多块静态对象的范围与函数中的构造函数析构函数在之前的编译器的版本时，或者当指定编译器选项，没有为个你可以在外部可见的内联函数中的静态对象数限制若要解决此问题，我们建议你采用较新版本的编译器工具集，或如果可能，请删除编译器选项。如果这是不可能，请考虑将静态对象。如果同一类型的对象，请考虑使用该类型的单个静态数组，并且引用所需的各个成员。示例下面的代码生成，并演示修复此错误的一种方法：

编译器错误 C2605 Compiler Error C2605 11
“”此方法是托管或类中的保留方法某些名称由编译器保留用于内部函数。有关详细信息，请参阅析构函数和终结器。示例以下示例生成。

编译器错误 C2611 Compiler Error C2611 11
：非法的后缀（应为标识符）令牌不是标识符。下面的示例生成 C2611: The following sample generates C2611: // C2611.cpp  
// compile with: /c  
class C {  
   C::~operator int();   // C2611  
   ~C();   // OK  
};

编译器错误 C2612 Compiler Error C2612 11
尾随非法基成员初始值设定项列表中在最后一个基或初始值设定项列表中的成员后出现的字符。下面的示例生成 C2612: The following sample generates C2612: // C2612.cpp  
class A {  
public:  
   int i;  
   A( int ia ) : i( ia ) + {};   // C2612  
};

编译器错误 C2613 Compiler Error C2613 11
基类列表中的后缀“”非法在基类列表中的最后一个基后面出现一个逗号。

编译器错误 C2614 Compiler Error C2614 11
：非法的成员初始化不是基或成员只有成员或基类，这些类可以出现在类或结构的初始化列表中。示例下面的示例生成 C2614。 The following sample generates C2614. // C2614.cpp  
// compile with: /c  
struct A {  
   int i;  
   A( int ia ) : B( i ) {};   // C2614 B is not a member of A  
};  

struct A2 {  
   int B;  
   int i;  
   A2( int ia ) : B( i ) {};   // OK  
};

编译器错误 C2616 Compiler Error C2616 11
：无法将非左值到隐式转换，不是常量无法从非左值初始化引用。这是在兼容性错误和在扩展下的警告。

编译器错误 C2617 Compiler Error C2617 11
：不一致的语句指定的函数没有声明的返回类型，而且前一个返回语句不提供一个值。下面的示例生成 C2617: The following sample generates C2617: // C2617.cpp  
int i;  
func() {   // no return type prototype  
   if( i ) return;   // no return value  
   else return( 1 );   // C2617 detected on this line  
} 可能的解决方法： Possible resolution: // C2617b.cpp  
// compile with: /c  
int i;  
int MyF() {  
   if (i)  
      return 0;  
   else   
      return (1);  
}

编译器错误 C2619 Compiler Error C2619 11
“标识符”：匿名结构或联合中不允许使用静态数据成员匿名结构或联合的成员声明为。下面的示例生成 C2619，并演示如何通过删除 static 关键字修复此错误。 The following sample generates C2619, and demonstrates how to fix it by removing the static keyword. // C2619.cpp  
int main() {  
   union { static int j; };  // C2619  
   union { int j; };  // OK  
}

编译器错误 C2624 Compiler Error C2624 11
局部类不能用于声明变量的外部局部类或结构不能用于声明变量。下面的示例生成 C2624: The following sample generates C2624: // C2624.cpp  
int main() {  
   struct C {};  
   extern C ac;   // C2624  
}

编译器错误 C2626 Compiler Error C2626 11
“标识符”匿名结构或联合中不允许使用私有或受保护的数据成员匿名结构或联合的成员必须具有公共访问。以下示例生成：若要解决此问题，请移除任何私有或受保护的标记：

编译器错误 C2627 Compiler Error C2627 11
：不允许匿名联合中的成员函数匿名联合不能具有成员函数。下面的示例生成 C2627: The following sample generates C2627: // C2627.cpp  
int main() {  
   union { void f(){} };   // C2627  
   union X { void f(){} };  
}

编译器错误 C2628 Compiler Error C2628 11
跟是非法是否忘记了？分号可能会丢失。下面的示例生成 C2628: The following sample generates C2628: // C2628.cpp  
class CMyClass {}  
int main(){}   // C2628 error 可能的解决方法： Possible resolution: // C2628b.cpp  
class CMyClass {};  
int main(){}

编译器错误 C2630 Compiler Error C2630 11
在内容应为逗号分隔列表中找到符号出现在需要逗号的上下文中。下面的示例生成 C2630: The following sample generates C2630: // C2630.cpp  
// compile with: /c  
struct D {  
   D(int);  
};  

struct E {  
   E(int);  
};  

class C : public D, public E {  
   C();  
};  

C::C() : D(0) ; E(0) { }   // C2630  
C::C() : D(0), E(0) {}   // OK

编译器错误 C2632 Compiler Error C2632 11
跟是非法的如果缺少两个类型说明符之间的代码，则可以导致此错误。下面的示例生成 C2632: The following sample generates C2632: // C2632.cpp  
int float i;   // C2632 此错误还可能来自于为 Visual Studio.NET 2003年执行的编译器一致性工作。 This error can also be generated as a result of compiler conformance work that was done for Visual Studio .NET 2003. bool 现在是正确的类型。 bool is now a proper type. 在以前版本， bool 是的 typedef，并可以创建具有该名称的标识符。 In previous versions, bool was a typedef, and you could create identifiers with that name. 下面的示例生成 C2632: The following sample generates C2632: // C2632_2.cpp  
// compile with: /LD  
void f(int bool);   // C2632 若要解决此错误，以使代码在 Visual Studio.NET 2003年和 Visual Studio.NET 版本的 Visual c + + 中有效，重命名标识符。 To resolve this error so that the code is valid in both the Visual Studio .NET 2003 and Visual Studio .NET versions of Visual C++, rename the identifier.

编译器错误 C2633 Compiler Error C2633 11
内联是构造函数的唯一合法存储类构造函数声明为内联以外的存储类。下面的示例生成 C2633: The following sample generates C2633: // C2633.cpp  
// compile with: /c  
class C {  
   extern C();   // C2633, not inline  
   inline C();   // OK  
};

编译器错误 C2634 Compiler Error C2634 11
“”指向引用成员的指针是非法的声明指向引用成员的指针。下面的示例生成 C2634: The following sample generates C2634: // C2634.cpp  
int mem;  
struct S {  
   S() : rf(mem) { }  
   int &rf;  
};  
int (S::*pdm) = &S::rf;   // C2634

编译器错误 C2635 Compiler Error C2635 11
无法将转换为隐式转换从虚拟基类此转换所需从强制转换基类派生的类，这不允许。下面的示例生成 C2635: The following sample generates C2635: // C2635.cpp  
class B {};  
class D : virtual public B {};  
class E : public B {};  

int main() {  
   B b;  
   D d;  
   E e;  

   D * pD = &d;  
   E * pE = &e;  
   pD = (D*)&b;   // C2635  
   pE = (E*)&b;   // OK  
}

编译器错误 C2636 Compiler Error C2636 11
：指向引用成员的指针是非法的未声明指向引用成员的指针。下面的示例生成 C2636: The following sample generates C2636: // C2636.cpp  
struct S {};  
int main() {  
   int &S::*prs;   // C2636  
   int S::*prs1;   // OK  
   int *S::*prs2;   // OK  
}

编译器错误 C2637 Compiler Error C2637 11
：不能修改指向数据成员指向数据成员的指针不能具有调用约定。若要解决，请删除的调用约定，或声明指向成员函数的指针。下面的示例生成 C2637: The following sample generates C2637: // C2637.cpp  
// compile with: /c  
struct S {};  
int __stdcall S::*pms1;   // C2637  

// OK  
int S::*pms2;  
int (__stdcall S::*pms3)(...);

编译器错误 C2638 Compiler Error C2638 11
上指向成员的指针修饰符非法修饰符不能使用指向成员的指针。下面的示例生成 C2638: The following sample generates C2638: // C2638.cpp  
void *a;  

class C {  
public:  
   int i;  
   int j;  
   int func();  
};  
int __based (a) C::* cpi = &C::i;  // C2638  
int (__based (a) C::* cpf)() = &C::func; // c2638

编译器错误 C2640 Compiler Error C2640 11
修饰符非法引用指针仅可使用修饰符。下面的示例生成 C2640: The following sample generates C2640: // C2640.cpp  
void f(int i) {  
    void *vp;  
    int _based(vp) &vr = I;  // C2640  
}

编译器错误 C2645 Compiler Error C2645 11
指向成员的指针的限定的名找到指向成员的指针的声明未指定类。下面的示例生成 C2645: The following sample generates C2645: // C2645.cpp  
class A {};  
int main() {  
   int B::* bp;   // C2645 B not defined  
   int A::* ap;   // OK  
}

编译器错误 C2646 Compiler Error C2646 11
全局或命名空间范围的匿名结构或联合必须声明为静态匿名结构或联合具有全局或命名空间范围，但未被声明为。下面的示例生成 C2646，并演示如何修复此错误： The following sample generates C2646 and shows how to fix it: // C2646.cpp  
// compile with: /c  
union { int i; };   // C2646 not static  

// OK  
static union { int j; };  
union U { int i; };

编译器错误 C2647 Compiler Error C2647 11
：不能取消引用上一个指向成员的指针运算符的左的操作数或不能隐式转换为右运算符与相关的类型。下面的示例生成 C2647: The following sample generates C2647: // C2647.cpp  
class C {};  
class D {};  

int main() {  
   D d, *pd;  
   C c, *pc = 0;  
   int C::*pmc = 0;  
   pd->*pmc = 0;   // C2647  
   d.*pmc = 0;   // C2647  

   // OK  
   pc->*pmc = 0;  
   c.*pmc = 0;  
}

编译器错误 C2648 Compiler Error C2648 11
：使用的成员，因为默认参数需要静态成员作为默认参数使用了非静态成员。下面的示例生成 C2648: The following sample generates C2648: // C2648.cpp  
// compile with: /c  
class C {  
public:  
   int i;  
   static int j;  
   void func1( int i = i );  // C2648  i is not static  
   void func2( int i = j );  // OK  
};

编译器错误 C2649 Compiler Error C2649 11
“”不是类、结构或联合声明使用不正确的标记。

编译器错误 C2650 Compiler Error C2650 11
：不能为虚函数或运算符被声明为。这些运算符是成员函数，不能为。示例下面的示例生成 C2650: The following sample generates C2650: // C2650.cpp  
// compile with: /c  
class A {  
   virtual void* operator new( unsigned int );   // C2650  
   // try the following line instead  
   // void* operator new( unsigned int );  
};

编译器错误 C2651 Compiler Error C2651 11
数据类型：左侧的必须是类、结构或联合若要使用模板参数，就像它是一个类，专用化模板类而不是整数类型的类模板。

编译器错误 C2652 Compiler Error C2652 11
：非法的复制构造函数：第一个参数不能复制构造函数中的第一个参数具有与类、结构或联合为其定义相同的类型。第一个参数可以是对的类型，但不是类型本身的引用。下面的示例生成 C2651: The following sample generates C2651: // C2652.cpp  
// compile with: /c  
class A {  
   A( A );   // C2652 takes an A  
};  
class B {  
   B( B& );   // OK, reference to B  
};

编译器错误 C2653 Compiler Error C2653 11
标识符：不是类或命名空间名称类、结构、联合或此处命名空间名称，将需要的语言语法。当你使用尚未声明为类、结构、联合或范围运算符的前面的命名空间的名称时，可以出现此错误。若要解决此问题，将该名称声明，或包含的标头中声明的名称，然后使用它。也可能是如果你尝试定义复合命名空间，包含一个或多个作用域嵌套命名空间名称的命名空间。复合不允许定义在在之前的命名空间。支持从在开始，在你指定的复合的命名空间最新编译器选项。从版本开始，编译器支持复合命名空间定义时指定选项。示例此示例生成，因为作用域名称是使用但不是声明。编译器需要的类、结构、联合或之前的范围运算符（）的命名空间名称。在代码中未或更高版本的标准，嵌套的命名空间必须在每个嵌套级别使用显式命名空间声明：

编译器错误 C2654 Compiler Error C2654 11
：尝试在成员函数的外部访问成员在声明中访问的成员。可以仅在成员函数中访问成员数据。在尝试初始化声明中的变量时，可以导致此错误。为此目的使用构造函数。

编译器错误 C2655 Compiler Error C2655 11
：定义或在当前范围内的非法重新声明仅在全局范围内，可以重新声明标识符。下面的示例生成 C2655: The following sample generates C2655: // C2655.cpp  
class A {};  
class B {  
public:  
   static int i;  
};  

int B::i;  // OK  

int main() {  
   A B::i;  // C2655  
}

编译器错误 C2656 Compiler Error C2656 11
：不允许作为位域的函数函数声明为位域的成员。可以通过构造函数初始值设定项列表中的语法错误导致此错误。

编译器错误 C2657 Compiler Error C2657 11
类语句的起始处找到（是否忘记指定类型？）行开头的指针到成员标识符。到成员，指针的声明中缺少类型说明符可以导致此错误。下面的示例生成 C2657: The following sample generates C2657: // C2657.cpp  
class C {};  
int main() {  
   C::* pmc1;        // C2657  
   int C::* pmc2;   // OK  
}

编译器错误 C2658 Compiler Error C2658 11
：匿名结构联合中的重定义两个匿名结构或联合包含具有相同标识符但具有不同类型的成员声明。下 yiw，你还将发生此错误的成员具有相同的标识符和类型。下面的示例生成 C2658: The following sample generates C2658: // C2658.cpp  
// compile with: /c  
struct X {  
   union { // can be struct too  
      int i;  
   };  
   union {  
      int i;   // Under /Za, C2658  
      // int i not needed here because it is defined in the first union  
   };  
};  

struct Z {  
   union {  
      char *i;  
   };  

   union {  
      void *i;   // C2658 redefinition of 'i'  
      // try the following line instead  
      // void *ii;  
   };  
};

编译器错误 C2659 Compiler Error C2659 11
“”作为左操作数函数在指定运算符的左边。出现此错误的最常见原因是编译器已将运算符左侧的标识符分析为函数，但开发人员希望它是变量。有关详细信息，请参阅文章最棘手的分析。本示例显示了函数声明和容易混淆的变量定义：若要解决此问题，请更改标识符的声明，使它不会被分析为函数声明。当函数具有无法在指定的运算符左侧的表达式中使用的类型时，也可能发生错误。’本示例在代码将函数指针分配给函数时生成：

编译器错误 C2660 Compiler Error C2660 11
：函数不带编号的参数该函数已调用的参数数目不正确。如果你意外调用函数而不是具有相同名称的成员函数，则会发生。若要解决此问题：调整函数调用，以符合为成员函数调用的格式。使用范围解析运算符以告知编译器要查找全局命名空间中的函数名称。示例下面的示例生成 C2660。 The following sample generates C2660. // C2660.cpp  
void func( int, int ) {}  

int main() {  
   func( 1 );   // C2660 func( int ) not declared  
   func( 1, 0 );   // OK  
} 示例 Example 如果你尝试直接调用的托管类型的 Dispose 方法，也会发生 C2660。 C2660 can also occur if you attempt to directly call the Dispose method of a managed type. 有关详细信息，请参阅 析构函数和终结器 。 For more information, see Destructors and finalizers . 下面的示例生成 C2660。 The following sample generates C2660. // C2660_a.cpp  
// compile with: /clr  
using namespace System;  
using namespace System::Threading;  

void CheckStatus( Object^ stateInfo ) {}  

int main() {  
   ManualResetEvent^ event = gcnew ManualResetEvent( false );     
   TimerCallback^ timerDelegate = gcnew TimerCallback( &CheckStatus );  
   Timer^ stateTimer = gcnew Timer( timerDelegate, event, 1000, 250 );  

   stateTimer->Dispose();   // C2660  
   stateTimer->~Timer();   // OK  
} 示例 Example 如果派生的类隐藏了函数，将发生 C2660。 C2660 will occur if a derived class hides a function. // C2660b.cpp  
// C2660 expected  
#include <stdio.h>  

class f {  
public:  
   void bar() {  
      printf_s("in f::bar\n");  
    }  
};  

class f2 : public f {  
public:  
   void bar(int i){printf("in f2::bar\n");}  
   // Uncomment the following line to resolve.  
   // using f::bar;   // - using declaration added  
   // or  
   // void bar(){__super::bar();}  
};  

int main() {  
   f2 fObject;  
   fObject.bar();  
} 示例 Example 如果不正确地调用索引的属性，则会发生 C2660。 C2660 can occur if you invoke an indexed property incorrectly. // C2660c.cpp  
// compile with: /clr  
ref class X {  
   double d;  
public:  
   X() : d(1.9) {}  
   property double MyProp[] {  
      double get(int i) {  
         return d;  
      }  
   }   // end MyProp definition  
};  

int main() {  
   X ^ MyX = gcnew X();  
   System::Console::WriteLine(MyX->MyProp(1));   // C2660  
   System::Console::WriteLine(MyX->MyProp[1]);   // OK  
} 示例 Example 如果不正确地调用索引的属性，则会发生 C2660。 C2660 can occur if you invoke an indexed property incorrectly. // C2660d.cpp  
// compile with: /clr  
ref class A{  
public:  
   property int default[int,int] {  
      int get(int a, int b) {  
         return a + b;  
      }  
   }  
};  

int main() {  
   A^ a = gcnew A;  
   int x = a[3][5];   // C2660  
   int x2 = a[3,5];   // OK  
} 示例 Example 如果在一种模板类，定义新运算符，但其新运算符创建一个对象，其类型是不同于封闭类型，则会发生 C2660。 C2660 can occur if you define a new operator in a template class, but where the new operator creates an object whose type is other than the enclosing type. // C2660e.cpp  
// compile with: /c  
#include <malloc.h>  

template <class T> class CA {  
private:  
    static T** line;  
   void* operator new (size_t, int i) {   
      return 0;  
   }  
   void operator delete(void* pMem, int i) {  
      free(pMem);  
   }  

public:  
   CA () { new (1) T(); }   // C2660  
   // try the following line instead  
   // CA () { new (1) CA<int>(); }  
};  

typedef CA <int> int_CA;  

void AAA() {  
   int_CA  list;  
}

编译器错误 C2661 Compiler Error C2661 11
：没有重载的函数接受编号参数可能的原因：函数调用中的实际参数不正确。缺少函数声明。下面的示例生成 C2661: The following sample generates C2661: // C2661.cpp  
void func( int ){}  
void func( int, int ){}  
int main() {  
   func( );   // C2661 func( void ) was not declared  
   func( 1 );   // OK func( int ) was declared  
}

编译器错误 C2662 Compiler Error C2662 11
：无法将从到的指针转换编译器无法转换指针从到。可以通过调用非导致此错误成员函数上的对象。可能的解决方法：删除从对象声明。添加指向成员函数。下面的示例生成 C2662: The following sample generates C2662: // C2662.cpp  
class C {  
public:  
   void func1();  
   void func2() const{}  
} const c;  

int main() {  
   c.func1();   // C2662  
   c.func2();   // OK  
} 使用编译时 /clr ，不能调用一个函数 const 或 volatile 限定托管的类型。 When compiling with /clr , you cannot call a function on a const or volatile qualified managed type. 不能声明托管类的 const 成员函数，因此您无法 const 托管对象上调用方法。 You cannot declare a const member function of a managed class, so you cannot call methods on const managed objects. // C2662_b.cpp  
// compile with: /c /clr  
ref struct M {  
   property M^ Type {  
      M^ get() { return this; }  
   }  

   void operator=(const M %m) {  
      M ^ prop = m.Type;   // C2662  
   }  
};  

ref struct N {  
   property N^ Type {  
      N^ get() { return this; }  
   }  

   void operator=(N % n) {  
      N ^ prop = n.Type;   // OK  
   }  
}; 下面的示例生成 C2662: The following sample generates C2662: // C2662_c.cpp  
// compile with: /c  
// C2662 expected  
typedef int ISXVD;  
typedef unsigned char BYTE;  

class LXBASE {  
protected:  
    BYTE *m_rgb;  
};  

class LXISXVD:LXBASE {  
public:  
   // Delete the following line to resolve.  
   ISXVD *PMin() { return (ISXVD *)m_rgb; }  

   ISXVD *PMin2() const { return (ISXVD *)m_rgb; };   // OK  
};  

void F(const LXISXVD *plxisxvd, int iDim) {  
   ISXVD isxvd;  
   // Delete the following line to resolve.  
   isxvd = plxisxvd->PMin()[iDim];  

   isxvd = plxisxvd->PMin2()[iDim];    
}

编译器错误 C2663 Compiler Error C2663 11
：数字重载具有指针的任何合法转换编译器无法转换到任何成员函数的重载版本。可以通过调用非导致此错误成员函数上的对象。可能的解决方法：删除从对象声明。添加成员函数重载之一。下面的示例生成 C2663: The following sample generates C2663: // C2663.cpp  
struct C {  
   void f() volatile {}  
   void f() {}  
};  

struct D {  
   void f() volatile;  
   void f() const {}  
};  

const C *pcc;  
const D *pcd;  

int main() {  
   pcc->f();    // C2663  
   pcd->f();    // OK  
}

编译器错误 C2664 Compiler Error C2664 11
“函数”无法将自变量从“类型”转换为“类型”如果创建了某个类的实例，然后尝试了对用关键字标记的构造函数进行隐式转换，则可能会发生此参数转换问题。有关显式转换的详细信息，请参阅用户定义类型转换。如果将临时对象传递给采用指向对象的引用作为参数的函数，则该引用必须是引用。如果使用不是函数所预期的类型的参数传递该函数，则使用适当的构造函数可创建临时对象。然后将该临时对象传递给函数。在这种情况下，该临时对象用于初始化引用。在该语言的早期版本中，所有的引用都可以由临时对象进行初始化。若要修复，请执行以下操作再次检查给定函数的原型，并改正错误信息中指出的自变量。如果需要的话，提供显式转换。如果某个类在它的一个基类中隐藏了成员，也可能生成。有关详细信息，请参阅如何：转换到或。示例下面的示例生成 C2664，并演示如何修复此错误。 The following sample generates C2664 and shows how to fix it. // C2664.cpp  
// C2664   
struct A {  
   void f(int i) {};  
};  

struct B : public A {  
   // To fix, uncomment the following line.  
   // using A::f;  
   void f(A a) {};  
};  

int main() {  
   B b;  
   int i = 1;  
   b.f(i);   // B::F hides A::f Uncomment the using declaration in B.  
} 示例 Example 此示例也生成 C2664，并演示如何修复此错误。 This sample also generates C2664 and shows how to fix it. // C2664b.cpp  
// C2664 expected  
struct A {  
   // To fix, uncomment the following line.  
   // A(int i){}  
};  

void func( int, A ) {}  

int main() {  
   func( 1, 1 );   // No conversion from int to A.  
} 示例 Example 下一个示例通过使用字符串调用 Test 来演示 C2664，并演示如何修复此错误。 The next sample demonstrates C2664 by using a string literal to call Test , and shows how to fix it. 因为该参数是 szString 引用，所以必须使用适当的构造函数创建对象。 Because the parameter is an szString reference, an object must be created by the appropriate constructor. 结果是一个无法用于初始化该引用的临时对象。 The result is a temporary object that cannot be used to initialize the reference. // C2664c.cpp  
// compile with: /EHsc  
// C2664 expected  
#include <iostream>  
#include <string.h>  
using namespace std;  

class szString {  
   int slen;  
   char *str;  

public:  
   szString(const char *);  
   int len() const {   
      return slen;   
   }  
};  

// Simple reference cannot bind to temp var.  
void Test(szString &a) {}  

// To fix, uncomment the following line.  
// void Test(const szString &a) {}  

szString::szString(const char * newstr) : slen(0), str(NULL) {  
   slen=strlen(newstr);  
   str = new char[slen + 1];  
   if (str)  
      strcpy_s(str, (slen + 1), newstr);  
}  

int main() {  
   Test("hello");  
} 示例 Example 编译器强制实施应用 const 的 C++ 标准要求。 The compiler enforces the C++ standard requirements for applying const . 此示例生成 C2664： This sample generates C2664: // C2664d.cpp  
// C2664 expected  
#include <windows.h>  

void func1(LPCSTR &s)  
{  

}  

void func2(LPSTR &s)  
{  
   func1(s);  
}  

int main()  
{  
   return 0;  
} 示例 Example 下面是生成 C2664 的更复杂情况，包括有关如何修复此错误的说明： Here's a more complex situation where C2664 is generated, including directions on how to fix it: // C2664e.cpp  
// compile with: /EHsc  
// C2664 expected  
#define _INTL  
#include <locale>  
#include <iostream>  

using namespace std;  
#define LEN 90  

in...

编译器错误 C2665 Compiler Error C2665 11
：无重载可以从类型转换参数重载函数的参数无法转换为所需的类型。可能的解决方法：提供一个转换运算符。使用显式转换。示例下面的示例生成 C2665。 The following sample generates C2665. // C2665.cpp  
void func(short, char*){}  
void func(char*, char*){}  

int main() {  
   func(0, 1);   // C2665  
   func((short)0, (char*)1);   // OK  
}

编译器错误 C2666 Compiler Error C2666 11
：数字重载具有相似的转换重载的函数或运算符不明确。形参列表可能太相似，编译器无法解析多义性。若要解决此错误，显式转换一个或多个实际的参数。下面的示例生成 C2666: The following sample generates C2666: // C2666.cpp  
struct complex {  
   complex(double);  
};  

void h(int,complex);  
void h(double, double);  

int main() {  
   h(3,4);   // C2666  
} 此错误还可能来自于为 Visual Studio.NET 2003年执行的编译器一致性工作： This error can also be generated as a result of compiler conformance work that was done for Visual Studio .NET 2003: 二元运算符和用户定义的到指针类型转换 binary operators and user-defined conversions to pointer types 限定转换不标识转换相同 qualification conversion is not the same as identity conversion 对于二元运算符<，>， <=、 和 > =、 传递参数现在被隐式转换为操作数的类型如果参数的类型定义用户定义的转换运算符以将转换为操作数的类型。 For the binary operators <, >, <=, and >=, a passed parameter is now implicitly converted to the type of the operand if the parameter's type defines a user-defined conversion operator to convert to the type of the operand. 现在有了潜在不明确。 There is now potential for ambiguity. 对于 Visual Studio.NET 2003年和 Visual Studio.NET 版本的 Visual c + + 中有效的代码，调用使用函数语法显式类运算符。 For code that is valid in both the Visual Studio .NET 2003 and Visual Studio .NET versions of Visual C++, call the class operator explicitly using function syntax. 示例 Example // C2666b.cpp  
#include <string.h>  
#include <stdio.h>  

struct T   
{  
    T( const T& copy )   
    {  
        m_str = copy.m_str;  
    }  

    T( const char* str )   
    {  
        int iSize = (strlen( str )+ 1);  
        m_str = new char[ iSize ];  
        if (m_str)  
            strcpy_s( m_str, iSize, str );  
    }  

    bool operator<( const T& RHS )   
    {  
        return m_str < RHS.m_str;  
    }  

    operator char*() const   
    {  
        return m_str;  
    }  

    char* m_str;  
};  

int main()   
{  
    T str1( "ABCD" );  
    const char* str2 = "DEFG";  

    // Error - Ambiguous call to operator<()  
    // Trying to convert str1 to char* and then call   
    // operator<( const char*, const char* )?  
    //  OR  
    // trying to convert str2 to T and then call  
    // T::operator<( const T& )?  

    if( str1 < str2 )   // C2666  

    if ( str1.operator < ( str2 ) )   // Treat str2 as type T  
        printf_s("str1.operator < ( str2 )\n");  

    if ( str1.operator char*() < str2 )   // Treat str1 as type char*  
        printf_s("str1.operator char*() < str2\n");  
} 示例 Example 下面的示例生成 C2666 The following sample generates C2666 // C2666c.cpp  
// compile with: /c  

enum E   
{  
    E_A,   E_B  
};  

class A   
{  
    int h(const E e) const {return 0; }  
    int h(const int i) { return 1; }  
    // Uncomment the following line to resolve.  
    // int h(const E e) { return 0; }  

    void Test()   
    {  
        h(E_A);   // C2666  
        h((const int) E_A);  
        h((int) E_A);  
    }  
};

编译器错误 C2667 Compiler Error C2667 11
：没有任何数字重载具有最佳转换重载的函数调用不明确，无法解析。必须严格优于所需的所有其他重载函数的转换需要用来匹配对其中一个重载函数的函数调用中的实际参数转换。在函数模板的部分排序，请参阅知识库文章有关详细信息。

编译器错误 C2668 Compiler Error C2668 11
：对重载函数调用不明确无法解析指定的重载的函数调用。你可能想要将一个或多个实参显式转换。此外可以通过模板使用来获取此错误。如果在同一类中，你有正则成员函数和模板化的成员函数具有相同签名，必须出现在模板化的一个最前面。这是的当前实现的限制。在函数模板的部分排序，请参阅知识库文章有关详细信息。如果你要生成包含对象支持项目，请参阅知识库文章。示例下面的示例生成 C2668: The following sample generates C2668: // C2668.cpp  
struct A {};  
struct B : A {};  
struct X {};  
struct D : B, X {};  

void func( X, X ){}  
void func( A, B ){}  
D d;  
int main() {  
   func( d, d );   // C2668 D has an A, B, and X   
   func( (X)d, (X)d );   // OK, uses func( X, X )  
} 示例 Example 若要解决此错误的另一个方法是使用 using 声明 : Another way to resolve this error is with a using declaration : // C2668b.cpp  
// compile with: /EHsc /c  
// C2668 expected  
#include <iostream>  
class TypeA {  
public:  
   TypeA(int value) {}  
};  

class TypeB {  
   TypeB(int intValue);  
   TypeB(double dbValue);  
};  

class TestCase {  
public:  
   void AssertEqual(long expected, long actual, std::string  
                    conditionExpression = "");  
};  

class AppTestCase : public TestCase {  
public:  
   // Uncomment the following line to resolve.  
   // using TestCase::AssertEqual;  
   void AssertEqual(const TypeA expected, const TypeA actual,  
                    std::string conditionExpression = "");  
   void AssertEqual(const TypeB expected, const TypeB actual,  
                    std::string conditionExpression = "");  
};  

class MyTestCase : public AppTestCase {  
   void TestSomething() {  
      int actual = 0;  
      AssertEqual(0, actual, "Value");  
   }  
}; 示例 Example 此错误还可能来自于为 Visual Studio.NET 2003年执行的编译器一致性工作： 强制转换为常量 0 上的不明确转换。 This error can also be generated as a result of compiler conformance work that was done for Visual Studio .NET 2003: ambiguous conversion on cast of constant 0. 强制转换使用常量 0 上的转换是不明确，因为 int 需要这两个到转换和长到 void 。 Conversion on a cast using constant 0 is ambiguous since int requires a conversion both to long and to void. 若要解决此错误，强制转换为它正用于以便发生 （此代码将在 Visual c + + 的 Visual Studio.NET 2003年和 Visual Studio.NET 版本中有效） 所需的任何转换的函数参数的确切类型 0。 To resolve this error, cast 0 to the exact type of the function parameter it is being used for so that no conversions need to take place (this code will be valid in the Visual Studio .NET 2003 and Visual Studio .NET versions of Visual C++). // C2668c.cpp  
#include "stdio.h"  
void f(long) {  
   printf_s("in f(long)\n");  
}  
void f(void*) {  
   printf_s("in f(void*)\n");  
}  
int main() {  
   f((int)0);   // C2668  

   // OK  
   f((long)0);  
   f((void*)0);  
} 示例 Example 由于 CRT 现在具有 float 和 double 窗体的所有数学函数，则可能出现此错误。 This error can occur because the CRT now has float and double forms of all math functions. // C2668d.cpp  
#include <math.h>  
int main() {  
   int i = 0;  
   float f;  
   f = cos(i);   // C2668  
   f = cos((float)i);   // OK  
} 示例 Example 因为 pow （int，int） 已从 CRT 中的 math.h 中删除，则可能出现此错误。 This error can occur because the pow(int, int) was removed from math.h in the CRT. // C2668e.cpp  
#include <math.h>  
int main() {  
   pow(9,9);   // C2668  
   pow((double)9,9);   // OK  
} 示例 Example 此代码在 Visual Studio 2015 中成功，但失败 C2668 在 Visual Studio 2017 和更高版本。 This code succeeds in Visual Studio 2015 but fails in Visual Studio 2017 and later with C2668. 在 Visual Studio 2015 中，编译器以与常规复制初始化相同的方...

编译器错误 C2669 Compiler Error C2669 11
不允许匿名联合中的成员函数匿名联合不能具有成员函数。示例下面的示例生成 C2669: The following sample generates C2669: // C2669.cpp  
struct X {  
   union {  
      int i;  
      void f() {   // C2669, remove function  
         i = 0;   
      }  
   };  
};

编译器错误 C2670 Compiler Error C2670 11
：函数模板不能从类型转换参数号所需的类型，无法转换参数。如果创建显式转换，则可能会修复此错误。

编译器错误 C2671 Compiler Error C2671 11
：静态成员函数没有此指针成员函数尝试访问。下面的示例生成 C2671: The following sample generates C2671: // C2671.cpp  
struct S {  
   static S* const func() { return this; }  // C2671  
};

编译器错误 C2673 Compiler Error C2673 11
：全局函数没有此指针全局函数尝试访问。下面的示例生成 C2673: The following sample generates C2673: // C2673.cpp  
int main() {  
   this = 0;   // C2673  
}

编译器错误 C2674 Compiler Error C2674 11
此上下文中不允许泛型声明未正确声明泛型。有关详细信息，请参阅泛型。示例下面的示例生成 C2674。 The following sample generates C2674. // C2674.cpp  
// compile with: /clr /c  
void F(generic <class T> ref class R1);   // C2674  
generic <class T> ref class R2 {};   // OK

编译器错误 C2675 Compiler Error C2675 11
一元不定义此运算符或可接受的类型转换到预定义的运算符使用一元运算符，也会发生和类型未定义运算符或可接受的类型转换到预定义的运算符。要使用该运算符，必须针对指定类型将其重载，或者定义一个到某个类型（该运算符已针对此类型进行了定义）的转换。示例下面的示例生成 C2675。 The following sample generates C2675. // C2675.cpp  
struct C {   
   C(){}  
} c;  

struct D {   
   D(){}  
   void operator-(){}  
} d;  

int main() {  
   -c;   // C2675  
   -d;   // OK  
}

编译器错误 C2676 Compiler Error C2676 11
二进制不定义此运算符或可接受的类型转换到预定义的运算符要使用该运算符，必须针对指定类型将其重载，或者定义一个到某个类型（该运算符已针对此类型进行了定义）的转换。示例下面的示例生成 C2676。 The following sample generates C2676. // C2676.cpp  
// C2676 expected  
struct C {  
   C();  
} c;  

struct D {  
   D();  
   D operator >>( C& ){return * new D;}  
   D operator <<( C& ){return * new D;}  
} d;  

struct E {  
   // operator int();  
};  

int main() {  
   d >> c;  
   d << c;  
   E e1, e2;  
   e1 == e2;   // uncomment operator int in class E, then  
               // it is OK even though neither E::operator==(E) nor   
               // operator==(E, E) defined. Uses the conversion to int   
               // and then the builtin-operator==(int, int)  
} 示例 Example 如果你尝试执行指针算术操作上，也可能发生 C2676 this 引用类型的指针。 C2676 can also occur if you attempt to do pointer arithmetic on the this pointer of a reference type. this 指针为类型中引用类型的句柄。 The this pointer is of type handle in a reference type. 有关详细信息，请参阅 语义 this 指针 。 For more information, see Semantics of the this pointer . 下面的示例生成 C2676。 The following sample generates C2676. // C2676_a.cpp  
// compile with: /clr  
using namespace System;  

ref struct A {  
   property Double default[Double] {  
      Double get(Double data) {  
         return data*data;  
      }  
   }  

   A() {  
      Console::WriteLine("{0}", this + 3.3);   // C2676  
      Console::WriteLine("{0}", this[3.3]);   // OK  
   }  
};  

int main() {  
   A ^ mya = gcnew A();  
}

编译器错误 C2677 Compiler Error C2677 11
二进制：没有全局运算符找到接受类型（或没有可接受的转换）要使用该运算符，必须针对指定类型将其重载，或者定义一个到某个类型（该运算符已针对此类型进行了定义）的转换。下面的示例生成 C2677: The following sample generates C2677: // C2677.cpp  
class C {  
public:  
   C(){}  
} c;  

class D {  
public:  
   D(){}  
   operator int(){return 0;}  
} d;  

int main() {  
   int i = 1 >> c;   // C2677  
   int j = 1 >> d;   // OK operator int() defined  
}

编译器错误 C2678 Compiler Error C2678 11
二进制“”：未定义接受“”类型的左操作数的运算符（或者没有可接受的转换）要使用该运算符，必须针对指定类型将其重载，或者定义一个到某个类型（该运算符已针对此类型进行了定义）的转换。示例如果左操作数限定为常量，但运算符定义为采用非常量参数，则会发生。下面的示例生成 C2678，并演示如何修复此错误： The following sample generates C2678 and shows how to fix it: // C2678a.cpp  
// Compile by using: cl /EHsc /W4 C2678a.cpp  
struct Combo {  
   int number;  
   char letter;  
};  

inline Combo& operator+=(Combo& lhs, int rhs) {  
   lhs.number += rhs;  
   return lhs;  
}  

int main() {  
   Combo const combo1{ 42, 'X' };  
   Combo combo2{ 13, 'Z' };  

   combo1 += 6; // C2678  
   combo2 += 9; // OK - operator+= matches non-const Combo  
} 示例 Example 如果没有锁住本机成员就对其调用成员函数，也会发生 C2678。 C2678 can also occur if you do not pin a native member before calling a member function on it. 下面的示例生成 C2678，并演示如何修复此错误。 The following sample generates C2678 and shows how to fix it. // C2678.cpp  
// compile with: /clr /c  
struct S { int _a; };  

ref class C {  
public:  
   void M( S param ) {  
      test = param;   // C2678  

      // OK  
      pin_ptr<S> ptest = &test;  
      *ptest = param;  
   }  
   S test;  
};

编译器错误 C2679 Compiler Error C2679 11
二进制：未找到接受的右操作数的类型（或没有可接受的转换）要使用该运算符，必须针对指定类型将其重载，或者定义一个到某个类型（该运算符已针对此类型进行了定义）的转换。下面的示例生成 C2679: The following sample generates C2679: // C2679.cpp  
class C {  
public:  
   C();   // no constructor with an int argument  
} c;  

class D {  
public:  
   D(int) {}  
   D(){}  
} d;  

int main() {  
   c = 10;   // C2679  
   d = 10;   // OK  
}

编译器错误 C2680 Compiler Error C2680 11
：名称的目标类型无效试图将转换为不是指针或引用的类型强制转换运算符。运算符可仅为指针或引用。下面的示例生成 C2680: The following sample generates C2680: // C2680.cpp  
// compile with: /c  
class A { virtual void f(); };  
class B : public A {};  

void g(B b) {  
   A a;  
   a = dynamic_cast<A>(b);   // C2680  target not a reference type  
   a = dynamic_cast<A&>(b);   // OK  
} 未定义目标时，也可能发生 C2680: C2680 can also occur when the target is not defined: // C2680b.cpp  
// compile with: /clr /c  
// C2680 expected  
using namespace System::Collections;  

// Delete the following line to resolve.  
ref class A;   // not defined  

// Uncomment the following line to resolve.  
// ref class A{};  

public ref class B : ArrayList {  
   property A^ C[int] {  
      A^ get(int index) {  
         return dynamic_cast<A^>(this->default::get(index));  
      }  
      void set(int index, A^ value) {  
         this->default::set(index, value);   
      }  
   }  
};

编译器错误 C2681 Compiler Error C2681 11
：无效的表达式类型名称强制转换运算符尝试从无效的类型转换。例如，如果你使用运算符将表达式转换为指针类型，源表达式必须是指针。下面的示例生成 C2681: The following sample generates C2681: // C2681.cpp  
class A { virtual void f(); };  

void g(int i) {  
    A* pa;  
    pa = dynamic_cast<A*>(i);  // C2681  
}

编译器错误 C2682 Compiler Error C2682 11
不能使用将从转换为强制转换运算符已尝试使用不兼容的类型之间进行转换。例如，不能使用运算符将指针转换为引用。运算符不能用于转换掉限定符。所有的限定符类型必须匹配。你可以使用运算符来删除属性，如，，或。下面的示例生成 C2682: The following sample generates C2682: // C2682.cpp  
class A { virtual void f(); };  
class B: public A {};  

void g(A* pa) {  
    B& rb = dynamic_cast<B&>(pa); // C2682  
} 下面的示例生成 C2682: The following sample generates C2682: // C2682b.cpp  
// compile with: /clr  
ref struct R{};  
ref struct RR : public R{};  
ref struct H {  
   RR^ r ;  
   short s;  
   int i;  
};  

int main() {  
   H^ h = gcnew H();    
   interior_ptr<int>lr = &(h->i);  
   interior_ptr<short>ssr = safe_cast<interior_ptr<short> >(lr);   // C2682  
   interior_ptr<short>ssr = reinterpret_cast<interior_ptr<short> >(lr);   // OK  
}

编译器错误 C2683 Compiler Error C2683 11
不是多态类型不能使用将从非多态类（具有没有虚函数的类）转换。你可以使用来执行非多态类型的转换。但是，不执行运行时检查。下面的示例生成 C2683: The following sample generates C2683: // C2683.cpp  
// compile with: /c  
class B { };  
class D : public B { };  

void f(B* pb) {  
   D* pd1 = dynamic_cast<D*>(pb);  // C2683  
   D* pd1 = static_cast<D*>(pb);   // OK  
}

编译器错误 C2687 Compiler Error C2687 11
：异常声明不能为，也不能表示不完整类型、指针或对不完整类型引用对于要异常声明的一部分的类型，它必须是已定义且不是。下面的示例生成 C2687: The following sample generates C2687: // C2687.cpp  
class C;  

int main() {  
   try {}  
   catch (C) {}   // C2687 error  
} 可能的解决方法： Possible resolution: // C2687b.cpp  
// compile with: /EHsc  
class C {};  

int main() {  
   try {}  
   catch (C) {}  
}

编译器错误 C2688 Compiler Error C2688 11
：具有多个协变返回或函数不支持的虚拟继承当函数包含变量自变量在中不支持协变返回类型。若要解决此错误，请定义您的函数，因此它们不会使用变量自变量或使返回的值对所有虚函数相同。下面的示例生成 C2688: The following sample generates C2688: // C2688.cpp  
struct G1 {};  
struct G2 {};  
struct G3 : G1, G2 {};  
struct G4 {};  
struct G5 {};  
struct G6 : G4, G5 {};  
struct G7 : G3, G6 {};  

struct C1 {  
   virtual G4& fgrv(int,...);  
};  

struct C2 : C1 {  
   virtual G7& fgrv(int,...);   // C2688, does not return G4&  
};

编译器错误 C2689 Compiler Error C2689 11
：友元函数不能定义内的本地类你可以声明，但不是在本地类中定义友元函数。下面的示例生成 C2689: The following sample generates C2689: // C2689.cpp  
// compile with: /c  
void g() {  
   void f2();  
   class X {  
      friend void f2(){}   // C2689  
      friend void f2();   // OK  
   };  
}

编译器错误 C2690 Compiler Error C2690 11
“”：不能对托管或数组执行指针算术不允许对托管或数组执行指针算术。使用数组索引表示法来遍历该数组。

编译器错误 C2691 Compiler Error C2691 11
数据类型：托管或不能具有此元素类型托管数组元素或数组元素的类型可以是值类型或引用类型。以下示例生成：

编译器错误 C2692 Compiler Error C2692 11
编译器中所需的完全原型函数选项编译的托管代码时，编译器需要函数声明。此外，如果函数不采用任何参数，它必须显式声明作为参数类型。

编译器错误 C2693 Compiler Error C2693 11
“运算符”：比较托管数组或数组的引用是非法的你不能测试托管数组或数组的任何不相等情况。例如，你可以测试托管数组是否相等，但不能测试其中一个数组是大于还是小于另一个数组。

编译器错误 C2694 Compiler Error C2694 11
重写：重写虚函数具有限制性较弱的异常规范比基类虚拟成员函数虚函数已被重写，但在，则重写函数具有限制性较少异常规范。下面的示例生成 C2694: The following sample generates C2694: // C2694.cpp  
// compile with: /Za /c  
class MyBase {  
public:  
   virtual void f(void) throw(int) {  
   }  
};  

class Derived : public MyBase {  
public:  
   void f(void) throw(...) {}   // C2694  
   void f2(void) throw(int) {}   // OK  
};

编译器错误 C2695 Compiler Error C2695 11
：重写虚函数不同于只是在调用约定派生类中的函数的签名不能重写基类中的函数和更改的调用约定。下面的示例生成 C2695: The following sample generates C2695: // C2695.cpp  
class C {  
   virtual void __fastcall func();  
};  

class D : public C {  
   virtual void __clrcall func();   // C2695  
};

编译器错误 C2696 Compiler Error C2696 11
无法创建托管类型的临时对象引用非托管程序中会导致编译器调用的构造函数并在堆栈上创建临时对象。但是，永远不会可以在堆栈上创建的托管的类。才可访问使用过时的编译器选项。

编译器错误 C2698 Compiler Error C2698 11
声明为声明不能共存与现有声明为声明一旦声明任何使用的数据成员不允许使用相同的名称与同一范围中的声明，因为只有函数可以进行重载。下面的示例生成 C2698: The following sample generates C2698: // C2698.cpp  
struct A {  
   int x;  
};  

struct B {  
   int x;  
};  

struct C : A, B {  
   using A::x;  
   using B::x;   // C2698  
}

编译器错误 C2700 Compiler Error C2700 11
“”：无法引发（有关详细信息，请使用）无法引发该对象。使用编译以获得详细诊断信息。

编译器错误 C2701 Compiler Error C2701 11
：函数模板不能为本地类的友元局部类不能将作为友元函数模板函数。下面的示例生成 C2701: The following sample generates C2701: // C2701.cpp  
// compile with: /c  
template<typename T>   // OK  
void f1(const T &);  

void MyFunction() {  
   class MyClass {  
      template<typename T> friend void f2(const T &);   // C2701  
   };  
}

编译器错误 C2702 Compiler Error C2702 11
中不能出现终止块异常处理程序不能嵌套在块。下面的示例生成 C2702: The following sample generates C2702: // C2702.cpp  
// processor: x86 IPF  
int Counter;  
int main() {  
   __try {}  
   __finally {  
      __try {}   // C2702  
      __except( Counter ) {}   // C2702  
   }  
}

编译器错误 C2703 Compiler Error C2703 11
非法语句语句必须是内部块。下面的示例生成 C2703: The following sample generates C2703: // C2703.cpp  
int main() {  
   __leave;   // C2703  
   __try {  
      // try the following line instead  
      __leave;  
   }  
   __finally {}  
}

编译器错误 C2704 Compiler Error C2704 11
“”：内部函数只能在中内部函数用于具有固定数量的参数的函数声明中。

编译器错误 C2705 Compiler Error C2705 11
：非法跳转到异常处理程序块作用域执行跳转到标签内，，块。有关详细信息，请参阅异常处理。下面的示例生成 C2705: The following sample generates C2705: // C2705.cpp  
int main() {  
goto trouble;  
   __try {  
      trouble: ;   // C2705  
   }  
   __finally {}  

   // try the following line instead  
   // trouble: ;  
}

编译器错误 C2706 Compiler Error C2706 11
没有匹配非法缺少中块？编译器未找到的右大括号块。下面的示例生成 C2706: The following sample generates C2706: // C2706.cpp  
int main() {  
   __try {  
      void f();  
   // C2706  } missing here  
   __except(GetExceptionCode() == 0x0) {  
   }  
}

编译器错误 C2707 Compiler Error C2707 11
：内部函数的错误上下文结构化的异常处理内部函数是在某些上下文中无效：外部异常筛选器或块外部异常筛选器外部块若要解决此错误，请确保在合适的上下文中放置的异常处理内部函数。示例下面的示例生成 C2707。 The following sample generates C2707. // C2707.cpp  
#include <windows.h>  
#include <stdio.h>  

LONG MyFilter(LONG excode)   
{  
    return (excode == EXCEPTION_ACCESS_VIOLATION ?  
        EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH);   // OK  
}  

LONG func(void)   
{  
    int x, y;  
    return(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?  // C2707  
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH);  

    __try   
    {  
        y = 0;  
        x = 4 / y;  
        return 0;  
     }  

    __except(MyFilter(GetExceptionCode()))   
    {  
        return(GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? // ok  
               EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH);  
    }  
}  

int main()   
{  
    __try   
    {  
        func();  
    } __except(EXCEPTION_EXECUTE_HANDLER)  
    {  
        printf_s("Caught exception\n");  
    }  
}

编译器错误 C2708 Compiler Error C2708 11
：以字节为单位的实际参数长度不同于上一个调用或引用函数的前面必须是原型。否则为编译器会解释首次作为原型函数调用，并且当编译器遇到不匹配的调用时发生此错误。若要解决此错误，请添加一个函数原型。

编译器错误 C2709 Compiler Error C2709 11
“”形参的字节长度不同于以前的声明调用中对指定函数的签名不同于该原型。

编译器错误 C2710 Compiler Error C2710 11
可以仅应用于返回一个指向函数其返回值是一个指针的函数是到的唯一构造可以应用。下面的示例生成 C2710: The following sample generates C2710: // C2710.cpp  
__declspec(restrict) void f();   // C2710  
// try the following line instead  
__declspec(restrict) int * g();

编译器错误 C2711 Compiler Error C2711 11
：此函数不能编译为托管，请考虑使用非托管一些说明将阻止编译器生成的封闭函数的。下面的示例生成 C2711: The following sample generates C2711: // C2711.cpp  
// compile with: /clr  
// processor: x86  
using namespace System;  
value struct V {  
   static const t = 10;  
};  

void bar() {  
   V::t;  
   __asm int 3   // C2711 inline asm can't be compiled managed  
}

编译器错误 C2712 Compiler Error C2712 11
无法在要求对象展开的函数中使用如果你使用，则会发生错误，并且带有结构化的异常处理也的函数具有需要展开（析构）的对象。可能的解决方案：将要求的代码移动到另一个函数中重写使用的函数以避免使用具有析构函数的局部变量和参数。在构造函数或析构函数中不要使用不使用进行编译如果调用通过使用声明的方法，也可能发生错误关键字。因为事件可能在多线程环境中使用，编译器将生成阻止基础事件对象操作，然后将生成的代码封装到的代码语句。因此，如果调用事件方法并按值传递其类型具有析构函数的自变量，则将发生错误。这种情况的一种解决方法是将自变量作为常数引用进行传递。示例如果使用进行编译，也会发生和声明中的指针到函数的静态数组块。静态成员要求编译器下使用动态初始化，这意味着异常处理。但是，不允许在块中进行异常处理。和编译器选项在中已弃用。下面的示例生成 C2712，并演示如何修复此错误。 The following sample generates C2712 and shows how to fix it. // C2712.cpp  
// compile with: /clr:pure /c  
struct S1 {  
   static int smf();  
   void fnc();  
};  

void S1::fnc() {  
   __try {  
      static int (*array_1[])() = {smf,};   // C2712  

      // OK  
      static int (*array_2[2])();  
      array_2[0] = smf;  
    }  
    __except(0) {}  
}

编译器错误 C2713 Compiler Error C2713 11
只有一种形式的允许每个函数的异常处理不能使用结构化的异常处理和异常处理相同的函数中。

编译器错误 C2714 Compiler Error C2714 11
不允许对运算符传递了无效的值。请参阅运算符有关详细信息。示例下面的示例生成 C2714。 The following sample generates C2714. // C2714.cpp  
int main() {  
   return __alignof(void);   // C2714  
   return __alignof(char);   // OK  
}

编译器错误 C2715 Compiler Error C2715 11
：无法引发或捕捉此类型值类型不是有效的自变量中使用异常处理托管代码时请参阅异常处理有关详细信息。

编译器错误 C2718 Compiler Error C2718 11
：不对齐具有的实际参数对齐函数参数中不允许修饰符。下面的示例生成 C2718: The following sample generates C2718: // C2718.cpp  
typedef struct __declspec(align(32)) AlignedStruct  {   
   int i;   
} AlignedStruct;  

void f2(int i, ...);  

void f4() {  
   AlignedStruct as;  

   f2(0, as);   // C2718, actual parameter is aligned  
}

编译器错误 C2719 Compiler Error C2719 11
“”：不对齐具有的形参对齐函数参数中不允许修饰符。函数参数的对齐方式由所使用的调用约定控制。有关详细信息，请参阅调用约定。以下示例将生成，并演示如何修复此错误：

编译器错误 C2720 Compiler Error C2720 11
标识符说明符非法成员上的存储类说明符存储类无法用于声明外部的类成员。若要解决此错误，删除不需要存储类从类声明外部的成员定义的说明符。示例下例生成了，并介绍了如何修复此错误：

编译器错误 C2721 Compiler Error C2721 11
：非法运算符关键字和类型之间的存储类说明符用户定义的类型转换适用于所有存储类，所以不能在类型转换指定存储类。

编译器错误 C2722 Compiler Error C2722 11
运算符：非法以下操作员命令使用运算符语句重新定义或。和运算符是全局性的因此范围解析运算符是无意义。删除运算符。

编译器错误 C2723 Compiler Error C2723 11
“函数”：“”说明符在函数定义上非法说明符不能与类声明外部的函数定义同时出现。仅能对类声明内的成员函数声明指定说明符。下面的示例生成 C2723 并显示如何修复它： The following sample generates C2723 and shows how to fix it: // C2723.cpp  
struct X {  
   virtual void f();  
   virtual void g();  
};  

virtual void X::f() {}   // C2723  

// try the following line instead  
void X::g() {}

编译器错误 C2724 Compiler Error C2724 11
不应使用在文件范围内定义的成员函数应使用外部链接声明静态成员函数。下面的示例生成 C2724: The following sample generates C2724: // C2724.cpp  
class C {  
   static void func();  
};  

static void C::func(){};   // C2724  
// try the following line instead  
// void C::func(){};

编译器错误 C2725 Compiler Error C2725 11
“”：无法根据值或引用引发或捕获托管或对象托管或异常的类型不正确。示例下面的示例生成 C2725，并演示如何修复此错误。 The following sample generates C2725 and shows how to fix it. // C2725.cpp  
// compile with: /clr  
ref class R {  
public:  
   int i;  
};  

int main() {  
   R % r1 = *gcnew R;  
   throw r1;   // C2725  

   R ^ r2 = gcnew R;  
   throw r2;   // OK     
} 示例 Example 下面的示例生成 C2725，并演示如何修复此错误。 The following sample generates C2725 and shows how to fix it. // C2725b.cpp  
// compile with: /clr  
using namespace System;  
int main() {  
   try {}  
   catch( System::Exception%) {}   // C2725  
   // try the following line instead  
   // catch( System::Exception ^e) {}  
}

编译器错误 C2726 Compiler Error C2726 11
“”只能用于创建具有托管或类型的对象不能在垃圾回收堆上创建本机类型的实例。下面的示例生成 C2726，并演示如何修复此错误： The following sample generates C2726 and shows how to fix it: // C2726.cpp  
// compile with: /clr  
using namespace System;  
class U {};  
ref class V {};  
value class W {};  

int main() {  
   U* pU = gcnew U;    // C2726  
   U* pU2 = new U;   // OK  
   V^ p2 = gcnew V;   // OK  
   W p3;   // OK  

}

编译器错误 C2728 Compiler Error C2728 11
“”：本机数组不能包含此类型数组创建语法用于创建托管对象或对象的数组。不能使用本机数组语法创建托管对象或对象的数组。有关详细信息，请参阅数组。以下示例将生成，并演示如何修复此错误：

编译器错误 C2730 Compiler Error C2730 11
“”不能是自身的基类递归的基类无效。请将另一个类指定为基类。

编译器错误 C2731 Compiler Error C2731 11
：无法重载函数函数，，，和无法进行重载。下面的示例生成 C2731: The following sample generates C2731: // C2731.cpp  
extern "C" void WinMain(int, char *, char *);  
void WinMain(int, short, char *, char*);   // C2731

编译器错误 C2732 Compiler Error C2732 11
链接规范与“”的早期规范冲突该函数已经使用其他链接说明符声明。具有不同链接说明符的包含文件可能会导致此错误。要修复此错误，请更改语句，以便这些链接一致。特别是，不要对块中的指令换行。示例下面的示例生成 C2732： The following sample generates C2732: // C2732.cpp  
extern void func( void );   // implicit C++ linkage  
extern "C" void func( void );   // C2732

编译器错误 C2733 Compiler Error C2733 11
第二个链接的重载函数不允许使用链接声明多个重载的函数。使用链接时，只有一种形式的指定可以是函数的外部的。重载的函数具有相同的未修饰的名称，因为它们不能用于程序。下面的示例生成 C2733: The following sample generates C2733: // C2733.cpp  
extern "C" {  
   void F1(int);  
}  

extern "C" {  
   void F1();   // C2733  
   // try the following line instead  
   // void F2();  
}

编译器错误 C2734 Compiler Error C2734 11
：必须初始化对象，如果不是外部声明该标识符但未初始化或。下面的示例生成 C2734: The following sample generates C2734: // C2734.cpp  
const int j;   // C2734  
extern const int i;   // OK, declared as extern

编译器错误 C2735 Compiler Error C2735 11
形参类型说明符中不允许使用关键字关键字在此上下文中无效。下面的示例生成 C2735: The following sample generates C2735: // C2735.cpp  
void f(inline int){}   // C2735

编译器错误 C2736 Compiler Error C2736 11
强制转换中不允许使用关键字关键字中强制转换无效。下面的示例生成 C2736: The following sample generates C2736: // C2736.cpp  
int main() {  
   return (virtual) 0;   // C2736  
   // try the following line instead  
   // return 0;  
}

编译器错误 C2738 Compiler Error C2738 11
：不明确或不是的成员未正确声明函数。下面的示例生成 C2738: The following sample generates C2738: // C2738.cpp  
struct A {  
   template <class T> operator T*();  
   // template <class T> operator T();  
};  

template <>  
A::operator int() {   // C2738  

// try the following line instead  
// A::operator int*() {  

// or use the commented member declaration  

   return 0;  
}

编译器错误 C2739 Compiler Error C2739 11
“”显式托管或数组维度必须介于和之间数组维度不在和之间。下面的示例生成 C2739，并演示如何修复此错误： The following sample generates C2739 and shows how to fix it: // C2739.cpp  
// compile with: /clr  
int main() {  
   array<int, -1>^a;   // C2739  
   // try the following line instead  
   // array<int, 2>^a;  
}

编译器错误 C2743 Compiler Error C2743 11
：无法捕获具有析构函数或复制构造函数的本机类型使用编译的模块尝试捕获异常的本机类型和其中的类型的析构函数或复制构造函数使用调用约定。如果使用编译的，异常处理预计要的本机类型的成员函数和。与成员函数使用的本机类型调用约定不能使用编译的模块中捕获。有关详细信息，请参阅（公共语言运行时编译）。示例下面的示例生成 C2743。 The following sample generates C2743. // C2743.cpp  
// compile with: /clr  
public struct S {  
   __clrcall ~S() {}  
};  

public struct T {  
   ~T() {}  
};  

int main() {  
   try {}  
   catch(S) {}   // C2743  
   // try the following line instead  
   // catch(T) {}  

   try {}  
   catch(S*) {}   // OK  
}

编译器错误 C2745 Compiler Error C2745 11
：此令牌不能转换为标识符标识符必须包含合法字符。下面的示例生成 C2745: The following sample generates C2745: // C2745.cpp  
// compile with: /clr  
int main() {  
   int __identifier([));   // C2745  
}

编译器错误 C2748 Compiler Error C2748 11
创建托管数组或数组时必须提供数组大小或数组初始值设定项托管数组或数组的格式不正确。有关详细信息，请参阅数组。下面的示例生成 C2748，并演示如何修复此错误： The following sample generates C2748 and shows how to fix it: // C2748.cpp  
// compile with: /clr  
int main() {  
   array<int> ^p1 = new array<int>();   // C2748  
   // try the following line instead  
   array<int> ^p2 = new array<int>(2);  
}

编译器错误 C2749 Compiler Error C2749 11
：只能引发或捕获的托管类使用句柄使用时，你只能引发或捕获引用类型。有关详细信息，请参阅（公共语言运行时编译）。示例下面的示例生成 C2749: The following sample generates C2749: // C2749.cpp  
// compile with: /clr:safe  
ref struct MyStruct {  
public:  
   int i;  
};  

int main() {  
   MyStruct ^x = gcnew MyStruct;  

   // Delete the following 4 lines to resolve.  
   try {   
      throw (1);   // C2749  
   }  
   catch(int){}  

   // OK  
   try {  
      throw (x);  
   }  
   catch(MyStruct ^){}   
}

编译器错误 C2750 Compiler Error C2750 11
：不能使用引用类型上的请改用若要创建的是类型，它将导致要放置在垃圾回收堆上的实例，实例必须使用。下面的示例生成 C2750: The following sample generates C2750: // C2750.cpp  
// compile with: /clr  
ref struct Y1 {};  

int main() {  
   Y1 ^ x = new Y1;   // C2750  

   // try the following line instead  
   Y1 ^ x2 = gcnew Y1;  
}

编译器错误 C2751 Compiler Error C2751 11
：函数参数的名称不能限定限定的名称不能用作函数参数。下面的示例生成 C2751: The following sample generates C2751: // C2751.cpp  
namespace std {  
   template<typename T>  
   class list {};  
}  

#define list std::list  
void f(int &list){}   // C2751

编译器错误 C2752 Compiler Error C2752 11
多个部分专用化匹配模板自变量列表实例化是不明确。下面的示例生成 C2752: The following sample generates C2752: // C2752.cpp  
template<class T, class U>   
struct A {};  

template<class T, class U>   
struct A<T*, U> {};  

template<class T, class U>   
struct A<T,U*> {};  

// try the following line instead  
// template<class T, class U> struct A<T*,U*> {};  

int main() {  
   A<char*,int*> a;   // C2752 an instantiation  

   // OK  
   A<char*,int> a1;  
   A<char,int*> a2;  
   A<char,int> a3;  
}

编译器错误 C2753 Compiler Error C2753 11
模板：部分专用化不能与匹配主模板参数列表如果模板自变量列表与匹配参数列表，则编译器会将其视为相同的模板。不允许两次定义相同的模板。示例下面的示例生成 C2753，并演示了如何修复此错误： The following sample generates C2753 and shows a way to fix it: // C2753.cpp  
// compile with: cl /c C2753.cpp
template<class T>  
struct A {};  

template<class T>  
struct A<T> {};   // C2753  
// try the following line instead  
// struct A<int> {};  

template<class T, class U, class V, class W, class X>  
struct B {};

编译器错误 C2754 Compiler Error C2754 11
：部分专用化不能有依赖的非类型模板参数尝试部分专用化具有依赖的非类型模板参数的模板类。这是不允许的。下面的示例生成 C2754: The following sample generates C2754: // C2754.cpp  
// compile with: /c  

template<class T, T t>  
struct A {};  

template<class T, int N>  
struct B {};  

template<class T> struct A<T,5> {};   // C2754  
template<> struct A<int,5> {};   // OK  
template<class T> struct B<T,5> {};   // OK

编译器错误 C2755 Compiler Error C2755 11
：部分专用化的非类型参数必须是简单标识符非类型参数必须是一个简单的标识符，编译器可以解析为一个单一的标识符或常量值的编译时的内容。下面的示例生成 C2755: The following sample generates C2755: // C2755.cpp  
template<int I, int J>  
struct A {};  

template<int I>   
struct A<I,I*5> {};   // C2755  
// try the following line instead  
// struct A<I,5> {};

编译器错误 C2756 Compiler Error C2756 11
“模板类型”部分专用化中不允许有默认模板自变量部分专用化的模板不能包含默认自变量。下面的示例生成 C2756，并演示如何修复此错误： The following sample generates C2756 and shows how to fix it: // C2756.cpp  
template <class T>  
struct S {};  

template <class T=int>  
// try the following line instead  
// template <class T>  
struct S<T*> {};   // C2756

编译器错误 C2757 Compiler Error C2757 11
：已存在具有此名称的符号，因此此名称不能用作命名空间名称中引用的程序集中已使用的命名空间标识符作为当前的编译中使用的符号。下面的示例生成 C2757: The following sample generates C2757: // C2757a.cpp  
// compile with: /clr /LD  
public ref class Nes {}; 然后， And then, // C2757b.cpp  
// compile with: /clr /c  
#using <C2757a.dll>  

namespace Nes {    // C2757  
// try the following line instead  
// namespace Nes2 {  
   public ref class X {};  
}

编译器错误 C2758 Compiler Error C2758 11
“”：必须初始化引用类型的成员如果构造函数未初始化初始值设定项列表中引用类型的成员，则会导致编译器错误。编译器将该成员保留为未定义状态。如果已在构造函数的初始化列表中声明引用成员变量或为其赋值，则必须对其进行初始化。下面的示例生成 C2758： The following sample generates C2758: // C2758.cpp  
// Compile by using: cl /W3 /c C2758.cpp  
struct A {  
   const int i;  

   A(int n) { };   // C2758  
   // try the following line instead  
   // A(int n) : i{n} {};  
};

编译器错误 C2760 Compiler Error C2760 11
语法错误：预期不强制转换运算符用于无效的运算符。下面的示例生成 C2760: The following sample generates C2760: // C2760.cpp  
class B {};  
class D : public B {};  

void f(B* pb) {  
    D* pd1 = static_cast<D*>(pb);  
    D* pd2 = static_cast<D*>=(pb);  // C2760  
    D* pd3 = static_cast<D*=(pb);   // C2760  
}

编译器错误 C2761 Compiler Error C2761 11
：不允许的成员函数重新声明不能重新声明成员函数。您可以定义它，但不是能重新声明。示例下面的示例生成 C2761。 The following sample generates C2761. // C2761.cpp  
class a {  
   int t;  
   void test();  
};  

void a::a;     // C2761  
void a::test;  // C2761 示例 Example 不能定义类或结构的非静态成员。 Nonstatic members of a class or structure cannot be defined. 下面的示例生成 C2761。 The following sample generates C2761. // C2761_b.cpp  
// compile with: /c  
struct C {  
   int s;  
   static int t;  
};  

int C::s;   // C2761  
int C::t;   // OK

编译器错误 C2762 Compiler Error C2762 11
：作为自变量的模板参数的表达式无效使用时，编译器不会将整数转换为指针。下面的示例生成 C2762: The following sample generates C2762: // C2762.cpp  
// compile with: /Za  
template<typename T, T *pT>  
class X2 {};  

void f2() {  
   X2<int, 0> x21;   // C2762  
   // try the following line instead  
   // X2<int, static_cast<int *>(0)> x22;  
}

编译器错误 C2764 Compiler Error C2764 11
：未使用或部分专用化中不能推导出的模板参数部分专用化中未使用的模板参数。这使得部分专用化不可用，因为无法推导模板参数。示例下面的示例生成 C2764: The following sample generates C2764: // C2764.cpp  
#include <stdio.h>  
template <class T1, class T2>  
struct S  {  
   int m_i;  
};  

template <class T1, class T2>  
struct S<int, T2*> {   // C2764  
// try the following line instead  
// struct S<T1(*)(T2), T2*> {  
   char m_c;  
};  

int main() {  
   S<int, char> s1;  
   S<void (*)(short), short *> s2;  
   s2.m_c = 10;  
   s1.m_i = s2.m_c;  
   printf_s("%d\n", s1.m_i);  
}

编译器错误 C2765 Compiler Error C2765 11
：函数模板的显式专用化不能有任何默认自变量函数模板的显式专用化上不允许使用默认参数。有关详细信息，请参阅函数模板的显式专用化。下面的示例生成 C2765: The following sample generates C2765: // C2765.cpp  
template<class T> void f(T t) {};  

template<> void f<char>(char c = 'a') {}   // C2765  
// try the following line instead  
// template<> void f<char>(char c) {}

编译器错误 C2766 Compiler Error C2766 11
显式专用化已定义不允许重复的显式专用化。有关详细信息，请参阅函数模板的显式专用化。下面的示例生成 C2766: The following sample generates C2766: // C2766.cpp  
// compile with: /c  
template<class T>   
struct A {};  

template<>   
struct A<int> {};  

template<>   
struct A<int> {};   // C2766  
// try the following line instead  
// struct A<char> {};

编译器错误 C2767 Compiler Error C2767 11
管理或维度不匹配：应有个自变量提供了托管数组或数组的声明的格式不正确。有关详细信息，请参阅数组。下面的示例生成 C2767，并演示如何修复此错误： The following sample generates C2767 and shows how to fix it: // C2767.cpp  
// compile with: /clr  
int main() {  
   array<int> ^p1 = new array<int>(2,3); // C2767  
   array<int> ^p2 = new array<int>(2);   // OK  
}

编译器错误 C2768 Compiler Error C2768 11
：非法使用显式模板自变量编译器无法确定是否应该函数定义的显式专用化函数模板，或者函数定义应该用于新函数。此错误的引入了在中，编译器一致性增强功能的一部分。下面的示例生成 C2768: The following sample generates C2768: // C2768.cpp  
template<typename T>  
void f(T) {}  

void f<int>(int) {}   // C2768  

// an explicit specialization  
template<>  
void f<int>(int) {}   

// global nontemplate function overload  
void f(int) {}

编译器错误 C2770 Compiler Error C2770 11
的无效显式参数使用显式模板或泛型自变量的函数模板候选项时不允许的函数类型。下面的示例生成 C2770: The following sample generates C2770: // C2770.cpp  
#include <stdio.h>  
template <class T>  
int f(typename T::B*);   // expects type with member B  

struct Err {};  

int main() {  
   f<int>(0);   // C2770 int has no B  
   // try the following line instead  
   f<OK>(0);  
}

编译器错误 C2771 Compiler Error C2771 11
导入只能在全局或命名空间范围例如，在函数或结构中不允许使用指令。

编译器错误 C2773 Compiler Error C2773 11
导入和仅在编译器中可用编译器不能识别预处理器指令。编译为源文件。使用如有必要。

编译器错误 C2774 Compiler Error C2774 11
：任何方法，此属性与相关联数据成员声明与属性未包含任何函数，但表达式尝试将其值设置。下面的示例生成 C2774: The following sample generates C2774: // C2774.cpp  
struct A {  
   __declspec(property(get=GetProp)) int prop;  
   int GetProp(void);  

   __declspec(property(get=GetProp2, put=PutProp2)) int prop2;  
   int GetProp2(void);  
   void PutProp2(int);  
};  

int main() {  
   A* pa = new A;  
   int val = 0;  
   pa->prop = val;   // C2774  
   pa->prop++;   // C2774  
}

编译器错误 C2775 Compiler Error C2775 11
：任何方法，此属性与相关联数据成员声明与属性扩展的特性没有函数指定，但表达式尝试检索其值。下面的示例生成 C2775: The following sample generates C2775: // C2775.cpp  
struct A {  
   __declspec(property(put=PutProp2, get=GetProp2)) int prop2;  
   int GetProp2(){return 0;}  
   void PutProp2(int){}  

   __declspec(property(put=PutProp)) int prop;  
   int PutProp(void){}  

};  

int main() {  
   A* pa = new A;  
   int x;  
   x = pa->prop;   // C2775  
   x = pa->prop2;  
}

编译器错误 C2776 Compiler Error C2776 11
可以每个属性指定只有一个方法你只能指定一个函数中属性扩展的特性。发生此错误时多个来指定函数。下面的示例生成 C2776: The following sample generates C2776: // C2776.cpp  
struct A {  
   __declspec(property(get=GetProp,get=GetPropToo))  
   // try the following line instead  
   // __declspec(property(get=GetProp))  
      int prop;   // C2776  
   int GetProp(void);  
   int GetPropToo(void);  
};

编译器错误 C2777 Compiler Error C2777 11
可以每个属性指定只有一个方法属性修饰符有多个属性。下面的示例生成 C2777: The following sample generates C2777: // C2777.cpp  
struct A {  
   __declspec(property(put=PutProp,put=PutPropToo))   // C2777  
   // try the following line instead  
   // __declspec(property(put=PutProp))  
      int prop;  
   int PutProp(void);  
   int PutPropToo(void);  
};

编译器错误 C2778 Compiler Error C2778 11
中格式不正确的不正确的提供给扩展的特性。必须是具有以下格式的十六进制数字的字符串：扩展的特性接受字符串识别、使用或不大括号分隔符。下面的示例生成 C2778: The following sample generates C2778: // C2778b.cpp  
struct __declspec(uuid(" 00000000-0000-0000-0000-000000000000 ")) C { };   // C2778  
struct __declspec(uuid("00000000000000000000000000000000")) D { };   // C2778

编译器错误 C2779 Compiler Error C2779 11
：只能与非静态数据成员相关联的属性方法扩展的属性不正确地应用于静态数据成员。下面的示例生成 C2779: The following sample generates C2779: // C2779.cpp  
struct A {  
   static __declspec(property(put=PutProp))  
   // try the following line instead  
   __declspec(property(put=PutProp))  
      int prop;   // C2779  
   int PutProp(void);  
};

编译器错误 C2780 Compiler Error C2780 11
“声明”应输入个自变量，却提供了个函数模板的自变量太少或太多。下面的示例生成 C2780，并演示如何修复此错误： The following sample generates C2780 and shows how to fix it: // C2780.cpp  
template<typename T>  
void f(T, T){}  

int main() {  
   f(1);  // C2780  
   // try the following line instead  
   // f(1,2);  
}

编译器错误 C2781 Compiler Error C2781 11
：需要至少参数提供具有变量参数列表的函数模板具有参数太少。下面的示例生成 C2781: The following sample generates C2781: // C2781.cpp  
template<typename T>  
void f(T, T, ...){}  

int main() {  
   f(1);   // C2781  

   // try the following line instead  
   f(1,1);  
}

编译器错误 C2782 Compiler Error C2782 11
：模板参数不明确确定模板自变量的类型。下面的示例生成 C2782: The following sample generates C2782: // C2782.cpp  
template<typename T>  
void f(T, T) {}  

int main() {  
   f(1, 'c');   // C2782  
   // try the following line instead  
   // f<int>(1, 'c');  
} 使用泛型时也可能发生 C2782: C2782 can also occur when using generics: // C2782b.cpp  
// compile with: /clr  
generic<typename T> void gf(T, T) { }  

int main() {  
   gf(1, 'c'); // C2782  
   // try the following line instead  
   // gf<int>(1, 'c');  
}

编译器错误 C2783 Compiler Error C2783 11
：无法推导其模板参数确定模板自变量。默认自变量不能用于推导其模板参数。下面的示例生成 C2783: The following sample generates C2783: // C2783.cpp  
template<typename T1, typename T2>  
T1 f(T2) {  
   return 248;  
}  

int main() {  
   f(1);   // C2783  
   // try the following line instead  
   int i = f<int>(1);  
} 使用泛型时，也可能发生 C2783: C2783 can also occur when using generics: // C2783b.cpp  
// compile with: /clr  
using namespace System;  
generic<typename T1, typename T2>   
T1 gf(T2) {  
   T1 t1 = safe_cast<T1>( Activator::CreateInstance(T1::typeid));  
   return t1;  
}  

ref class MyClass{};  

int main() {  
   int i;  
   i = gf(9);   // C2783  

   // OK  
   i = gf<int>(9);  
}

编译器错误 C2784 Compiler Error C2784 11
“”对于“”，无法从“”推导其模板自变量从提供的函数自变量确定模板自变量。下面的示例生成 C2784，并演示如何修复此错误： The following sample generates C2784 and shows how to fix it: // C2784.cpp  
template<class T> class X {};  
template<class T> void f(X<T>) {}  

int main() {  
   X<int> x;  
   f(1);   // C2784  

   // To fix it, try the following line instead  
   f(x);  
}

编译器错误 C2785 Compiler Error C2785 11
和具有不同的返回类型函数模板专用化的返回类型不同于主函数模板的返回类型。更正此错误检查一致性的函数模板的所有专用化。示例下面的示例生成 C2785: The following sample generates C2785: // C2785.cpp  
// compile with: /c  
template<class T> void f(T);  

template<> int f(int); // C2785  
template<> void f(int); // OK

编译器错误 C2786 Compiler Error C2786 11
：对于无效的操作数运算符采用与附加的或用户定义类型的对象的用户定义的类型。可能的原因：参数不是用户定义的类型。无法提取自变量中的。下面的示例生成 C2786: The following sample generates C2786: // C2786.cpp  
struct __declspec(uuid("00000000-0000-0000-0000-000000000000")) A {};  

int main() {  
   __uuidof(int);   // C2786  
   __uuidof(int *);   // C2786  
   __uuidof(A **);   // C2786  

   // no error  
   __uuidof(A);  
   __uuidof(A *);  
   __uuidof(A &);  
   __uuidof(A[]);  

   int i;  
   int *pi;  
   A **ppa;  

   __uuidof(i);      // C2786  
   __uuidof(pi);     // C2786  
   __uuidof(ppa);    // C2786  
}

编译器错误 C2787 Compiler Error C2787 11
：未已与此对象关联运算符采用与附加的或用户定义类型的对象的用户定义的类型。如果参数为不具有的用户定义的类型，则会发生此错误。下面的示例生成 C2787: The following sample generates C2787: // C2787.cpp  
#include <windows.h>  
struct F {};  

struct __declspec(uuid("00000000-0000-0000-c000-000000000046")) F2;  

int main() {  
   __uuidof(F);   // C2787  
   __uuidof(F2);   // OK  
}

编译器错误 C2788 Compiler Error C2788 11
：与此对象关联的多个运算符采用与附加的或用户定义类型的对象的用户定义的类型。如果参数为具有多个的对象，则会发生此错误。下面的示例生成 C2788: The following sample generates C2788: // C2788.cpp  
#include <windows.h>  
struct __declspec(uuid("00000001-0000-0000-0000-000000000000")) A {};  
struct __declspec(uuid("{00000002-0000-0000-0000-000000000000}")) B {};  
template <class T, class U> class MyClass {};  

typedef MyClass<A,B> MyBadClass;  
typedef MyClass<A,A> MyGoodClass;  

int main() {  
   __uuidof(MyBadClass);    // C2788  
   // try the following line instead  
   __uuidof(MyGoodClass);  
}

编译器错误 C2790 Compiler Error C2790 11
：仅在类成员函数的主体内使用此关键字如果用户曾经尝试使用关键字，则出现此错误消息成员函数的上下文之外。下面的示例生成 C2790: The following sample generates C2790: // C2790.cpp  
void f() {  
   __super::g();   // C2790  
}

编译器错误 C2791 Compiler Error C2791 11
非法使用超级没有任何基类，这些类关键字没有任何基类的类的成员函数的上下文中使用。下面的示例生成 C2791: The following sample generates C2791: // C2791.cpp  
struct D {  
   void mf() {  
      __super::mf();   // C2791  
   }  
};

编译器错误 C2792 Compiler Error C2792 11
：此关键字的后面必须跟可以按照关键字的唯一令牌是。下面的示例生成 C2792: The following sample generates C2792: // C2792.cpp  
struct B {  
   void mf();  
};  

struct D : B {  
   void mf() {  
      __super.();   // C2792  

      // try the following line instead  
      // __super::mf();  
   }  
};

编译器错误 C2793 Compiler Error C2793 11
：意外的令牌以下:yiw，标识符或关键字预期可以遵循的标记仅是标识符或关键字。下面的示例生成 C2793 The following sample generates C2793 // C2793.cpp  
struct B {  
   void mf();  
};  

struct D : B {  
   void mf() {  
      __super::(); // C2793  
   }  
};

编译器错误 C2794 Compiler Error C2794 11
：不是的任何直接或间接基类的成员尝试使用调用不存在的成员函数。下面的示例生成 C2794 The following sample generates C2794 // C2794.cpp  
struct B {  
   void mf();  
};  

struct D : B {  
   void mf() {  
      __super::f();  // C2794  
   }  
};

编译器错误 C2795 Compiler Error C2795 11
不是成员函数每当您尝试使用时，会出现此错误消息访问成员函数之外的成员。

编译器错误 C2797 Compiler Error C2797 11
（已过时）未实现成员初始值设定项列表或非静态数据成员初始值设定项内部的列表初始化。此警告是中已过时。在和早期版本中，编译器未实现成员初始值设定项列表或非静态数据成员初始值设定项内部的列表初始化。在之前，这已在无提示的情况下转换为函数调用，从而将导致代码生成错误。将其报告为错误。此示例生成：此示例也生成：若要解决此问题，你可以使用内部列表的显式构造。例如：如果无需初始化列表：（中的之前隐式执行它。）

编译器错误 C2798 Compiler Error C2798 11
不明确多个继承的结构包含与引用的成员。无法通过以下任一方法来修复该错误：的继承列表中移除或更改或中的数据成员的名称。下面的示例生成 C2798: The following sample generates C2798: // C2798.cpp  
struct B1 {  
   int i;  
};  

struct B2 {  
   int i;  
};  

struct D : B1, B2 {  
   void g() {  
      __super::i = 4; // C2798  
   }  
};

编译器错误 C2800 Compiler Error C2800 11
无法进行重载以下运算符无法进行重载：类成员访问，指向成员的指针，范围解析，条件表达式，和。下面的示例生成 C2800: The following sample generates C2800: // C2800.cpp  
// compile with: /c  
class C {  
   operator:: ();   // C2800  
};

编译器错误 C2801 Compiler Error C2801 11
必须为非静态成员以下运算符可以进行重载仅作为非静态成员：分配类成员访问下标函数调用的可能原因：重载的运算符不是类、结构或联合成员。重载的运算符被声明。下面的示例生成 C2801: The following sample generates C2801: // C2801.cpp  
// compile with: /c  
operator[]();   // C2801 not a member  
class A {  
   static operator->();   // C2801 static  
   operator()();   // OK  
};

编译器错误 C2802 Compiler Error C2802 11
静态成员不具有任何形式的参数声明的运算符成员函数必须具有至少一个参数。下面的示例生成 C2802: The following sample generates C2802: // C2802.cpp  
// compile with: /clr /c  
ref class A {  
   static operator+ ();   // C2802  
   static operator+ (A^, A^);   // OK  
};

编译器错误 C2803 Compiler Error C2803 11
必须具有至少一个类类型的正式参数重载的运算符缺少类类型的参数。您需要通过引用（不是使用指针，而是使用引用）或值至少传递一个参数，才能够编写“”（和均为类类型）。如果这两个参数都是指针，它将是指针地址的纯比较，并且将不使用用户定义的转换。下面的示例生成 C2803: The following sample generates C2803: // C2803.cpp  
// compile with: /c  
class A{};  
bool operator< (const A *left, const A *right);   // C2803  
// try the following line instead  
// bool operator< (const A& left, const A& right);

编译器错误 C2804 Compiler Error C2804 11
二进制“”的参数太多重载的二进制运算符成员函数被声明为带有多个参数。暗含了二元运算符成员函数的第一个操作数参数，其类型为该运算符的封闭类型。示例下面的示例生成 C2804，并演示如何修复此错误。 The following sample generates C2804 and shows how to fix it. // C2804.cpp  
// compile by using: cl /c /W4 C2804.cpp  
class X {  
public:  
   X& operator+= (const X &left, const X &right);   // C2804  
   X& operator+= (const X &right);   // OK - left operand implicitly *this  
};  

int main() {  
   X x, y;  
   x += y;   // equivalent to x.operator+=(y)  
} 示例 Example 下面的示例生成 C2804，并演示如何修复此错误。 The following sample generates C2804 and shows how to fix it. // C2804_2.cpp  
// compile with: /clr /c  
ref struct Y {  
   Y^ operator +(Y^ hY, int i);   // C2804  
   static Y^ operator +(Y^ hY, int i);   // OK  
   Y^ operator +(int i);   // OK  
};

编译器错误 C2805 Compiler Error C2805 11
二进制具有参数太少二元运算符没有任何参数。下面的示例生成 C2805: The following sample generates C2805: // C2805.cpp  
// compile with: /c  
class X {  
public:  
   X operator< ( void );   // C2805 must take one parameter  
   X operator< ( X );   // OK  
};

编译器错误 C2806 Compiler Error C2806 11
具有过多的正式参数重载的运算符的参数太多。下面的示例生成 C2806: The following sample generates C2806: // C2806.cpp  
// compile with: /c  
class X {  
public:  
   X operator++ ( int, int );   // C2806 more than 1 parameter  
   X operator++ ( int );   // OK  
} ;

编译器错误 C2807 Compiler Error C2807 11
第二个形参以后缀运算符必须是后缀运算符的第二个参数具有错误的类型。下面的示例生成 C2807: The following sample generates C2807: // C2807.cpp  
// compile with: /c  
class X {  
public:  
   X operator++ ( X );   // C2807 nonvoid parameter  
   X operator++ ( int );   // OK, int parameter  
};

编译器错误 C2808 Compiler Error C2808 11
一元运算符具有过多的正式参数一元运算符有非参数列表。下面的示例生成 C2808: The following sample generates C2808: // C2808.cpp  
// compile with: /c  
class X {  
public:  
   X operator! ( X );   // C2808 nonvoid parameter list  
   X operator! ( void );   // OK  
};

编译器错误 C2809 Compiler Error C2809 11
不具有任何形式的参数运算符缺少必需的参数。下面的示例生成 C2809: The following sample generates C2809: // C2809.cpp  
// compile with: /c  
class A{};  
int operator+ ();   // C2809  
int operator+ (A);   // OK

编译器错误 C2810 Compiler Error C2810 11
：接口只能从另一个接口继承接口可能只能继承自另一个接口和可能不是继承自的类或结构。下面的示例生成 C2810: The following sample generates C2810: // C2810.cpp  
#include <unknwn.h>  
class CBase1 {  
public:  
  HRESULT mf1();  
  int  m_i;  
};  

[object, uuid="40719E20-EF37-11D1-978D-0000F805D73B"]  
__interface IDerived : public CBase1 {  // C2810  
// try the following line instead  
// __interface IDerived {  
   HRESULT mf2(void *a);  
};  

struct CBase2 {  
   HRESULT mf1(int a, char *b);  
   HRESULT mf2();  
};

编译器错误 C2811 Compiler Error C2811 11
：不能继承自，类只能继承自类或接口类你尝试使用非托管的类用作基类的托管类。下面的示例生成 C2811: The following sample generates C2811: // C2811.cpp  
// compile with: /clr /c  
struct S{};  
ref struct T {};  
ref class C : public S {};   // C2811  
ref class D : public T {};   // OK

编译器错误 C2812 Compiler Error C2812 11
导入不支持使用和和编译器选项在中已弃用。指令不支持和因为需要本机编译器支持库的使用。示例下面的示例生成 C2812。 The following sample generates C2812. // C2812.cpp  
// compile with: /clr:pure /c  
#import "importlib.tlb"   // C2812

编译器错误 C2813 Compiler Error C2813 11
导入不支持如果在编译器命令中指定编译器选项以及两个或更多文件进行编译，并且其中一个或多个文件包含预处理器指令，则会发出。指令从指定类型库中的类型生成类，然后将这些类写入两个头文件。不支持指令，因为如果多个编译单元导入相同类型库，则这些单元在同时尝试写入相同头文件时会产生冲突。此编译器错误和编译器选项是中新增功能。示例下面的示例生成 C2813。 The following sample generates C2813. “compile with:”注释中的命令行向编译器指示使用 /MP 和 /c 编译器选项编译多个文件。 The command line in the "compile with:" comment indicates to the compiler to use the /MP and /c compiler options to compile several files. 其中至少有一个文件包含 #import 指令。 At least one of the files contains the #import directive. 为了测试此示例，我们对相同文件使用了两次。 We use the same file twice for the sake of testing this example. // C2813.cpp  
// compile with: /MP /c C2813.cpp C2813.cpp  
#import "C:\windows\system32\stdole2.tlb"   // C2813  
int main()   
{  
}

编译器错误 C2814 Compiler Error C2814 11
“”：本机类型不能嵌套在托管类型或类型“”内示例本机类型不能嵌套在或类型中。下面的示例生成 C2814，并演示如何修复此错误。 The following sample generates C2814 and shows how to fix it. // C2814.cpp  
// compile with: /clr /c  
ref class A {  
   class B {};   // C2814  
   ref class C {};   // OK  
};

编译器错误 C2815 Compiler Error C2815 11
：第一个形参必须是，但却使用任何用户定义运算符函数必须采用类型的第一个形参。下面的示例生成 C2815: The following sample generates C2815: // C2815.cpp  
// compile with: /c  
class CMyClass {  
public:  
   void mf1(int *a);  
   void operator delete(CMyClass *);   // C2815  
   void operator delete(void *);   
};

编译器错误 C2817 Compiler Error C2817 11
的返回类型必须为一个已重载运算符函数无法返回值。

编译器错误 C2818 Compiler Error C2818 11
重载“”的应用程序通过类型“”进行递归类成员访问运算符重新定义包含递归语句。若要重新定义运算符具有递归，你必须将移动到单独的函数调用从运算符的递归例程重写函数。

编译器错误 C2819 Compiler Error C2819 11
“”类型没有重载成员“”你需要定义若要使用此指针操作。下面的示例生成 C2819: The following sample generates C2819: // C2819.cpp  
// compile with: /c  
class A {  
   public:  
      int i;  
};  

class B {};  

void C(B j) {  
   j->i;   // C2819  
}  

class D {  
   A* pA;  

   public:  
      A* operator->() {  
         return pA;  
      }  
};  

void F(D j) {  
   j->i;  
} 使用时也可能发生 C2819 对于引用类型的 c + + 堆栈语义 。 C2819 can also occur when using C++ Stack Semantics for Reference Types . 下面的示例生成 C2819: The following sample generates C2819: // C2819_b.cpp  
// compile with: /clr  
ref struct R {  
   void Test() {}  
};  

int main() {  
   R r;  
   r->Test();   // C2819  
   r.Test();   // OK  
}

编译器错误 C2821 Compiler Error C2821 11
的第一个正式参数必须是的第一个形参运算符必须是无符号。示例下面的示例生成 C2821: The following sample generates C2821: // C2821.cpp  
// compile with: /c  
void * operator new( /* unsigned int,*/ void * );   // C2821  
void * operator new( unsigned int, void * );

编译器错误 C2823 Compiler Error C2823 11
模板是非法的模板中不允许定义。示例下面的示例生成 C2823，并演示修复此错误的一种方法： The following sample generates C2823, and shows one way to fix it: // C2823.cpp  
template<class T>  
typedef struct x {  
   T i;   // C2823 can't use T, specify data type and delete template  
   int i;   // OK  
} x1;

编译器错误 C2824 Compiler Error C2824 11
必须是返回类型使用非基于指针重载的运算符必须返回。下面的示例生成 C2824: The following sample generates C2824: // C2824.cpp  
// compile with: /c  
class   A {  
   A* operator new(size_t i, char *m);   // C2824  
   // try the following line instead  
   // void* operator new(size_t i, char *m);  
};

编译器错误 C2825 Compiler Error C2825 11
：必须是类或命名空间在后面带有不成功的尝试已进行形成限定的名。例如，请确保你的代码不包含函数声明的函数名称的开头。示例下面的示例生成 C2825: The following sample generates C2825: // C2825.cpp  
typedef int i;  
int main() {  
   int* p = new int;  
   p->i::i();   // C2825  
   // try the following line instead  
   // p->i::~i();  
}

编译器错误 C2827 Compiler Error C2827 11
不能全局重写以与一元窗体运算符不能具有一元窗体外部对象。使用以下可能的解决方案进行修复对象的本地做重载的运算符。选择要重载的适当的一元运算符。

编译器错误 C2828 Compiler Error C2828 11
不能全局重写以与二进制格式运算符不能有外部对象的二进制格式。使用以下可能的解决方案进行修复对象的本地做重载的运算符。选择要重载的适当的一元运算符。

编译器错误 C2829 Compiler Error C2829 11
不能具有变量参数列表只有两个运算符只能带变量参数列表：函数调用

编译器错误 C2830 Compiler Error C2830 11
仅放置到的参数可以具有默认值标准形参运算符不能有默认值。仅用户定义的位置参数可以指定默认值。

编译器错误 C2831 Compiler Error C2831 11
不能具有默认参数只有三个运算符可以具有默认参数：分配左的括号下面的示例生成 C2831: The following sample generates C2831: // C2831.cpp  
// compile with: /c  
#define BINOP <=  
class A {  
public:  
   int i;  
   int operator BINOP(int x = 1) {   // C2831  
   // try the following line instead  
   // int operator BINOP(int x) {  
      return i+x;  
   }  
};

编译器错误 C2833 Compiler Error C2833 11
不是可识别的运算符或类型必须跟你想要重写的运算符或你想要转换的类型。你可以在托管类型中定义的运算符的列表，请参阅用户定义的运算符。下面的示例生成 C2833: The following sample generates C2833: // C2833.cpp  
// compile with: /c  
class A {};  

void operator ::* ();   // C2833  
void operator :: ();   // OK

编译器错误 C2834 Compiler Error C2834 11
必须是全局限定和运算符被绑定到类驻留的位置。范围解析不能用于选择的版本或从另一个类。若要实现的多个窗体或运算符，带有额外形参创建运算符的版本。

编译器错误 C2835 Compiler Error C2835 11
用户定义的转换不采用任何形式的参数用户定义类型转换不能采用形参。下面的示例生成 C2835: The following sample generates C2835: // C2835.cpp  
class A {  
public:  
   char v_char;  

   A() {   
      v_char = 'A';   
   };  
   operator char(char a) {   // C2835  
   // try the following line instead  
   // operator char() {     
      return v_char + 1;   
   };  
};  

int main() {  
   A a;  
}

编译器错误 C2838 Compiler Error C2838 11
：非法的限定的名称，在成员声明类、结构或联合使用完全限定的名称重新声明另一个类、结构或联合的成员。下面的示例生成 C2838: The following sample generates C2838: // C2838.cpp  
// compile with: /c  
class Bellini {  
public:  
    void Norma();  
};  

class Bottesini {  
   Bellini::Norma();  // C2838  
};

编译器错误 C2839 Compiler Error C2839 11
重载的“”的无效返回类型“”运算符必须返回一个类、结构或联合或引用某一。

编译器错误 C2842 Compiler Error C2842 11
“类”：托管或类型不能定义自己的“”或“”你可以定义自己运算符或运算符来管理本机堆上的内存分配。但是，引用类不能定义这些运算符，因为它们仅分配在托管堆上。有关详细信息，请参阅用户定义的运算符。示例以下示例生成。

编译器错误 C2843 Compiler Error C2843 11
“”：不能获取托管或类型的非静态数据成员或方法的地址需要实例才能获取托管或类或接口的非静态数据成员的地址。下面的示例生成 C2843，并介绍了如何修复此错误： The following sample generates C2843 and shows how to fix it: // C2843_2.cpp  
// compile with: /clr  
public ref class C {  
public:  
   int m_i;  
};  

ref struct MyStruct {  
   static void sf() {}  
   void f() {}  
};  

int main() {  
   MyStruct ^ps = gcnew MyStruct;  
   void (__clrcall MyStruct::*F1)() = & MyStruct::f;   // C2843  
   void (__clrcall MyStruct::*F2)() = & ps->f;   // C2843  
   void (__clrcall MyStruct::*F3)();   // C2843  

   void (__clrcall *F5)() = MyStruct::sf;   // OK  
   void (__clrcall *F6)() = & ps->sf;   // OK  

   interior_ptr<int> i = &C::m_i; // C2843  
   C ^x = gcnew C();  
   interior_ptr<int> ii = &x->m_i;  
}

编译器错误 C2844 Compiler Error C2844 11
：不能为接口的成员接口类不能包含的数据成员，除非它也是一个属性。在接口中不允许一个属性或成员函数之外的任何内容。此外，不允许构造函数、析构函数和运算符。下面的示例生成 C2844: The following sample generates C2844: // C2844a.cpp  
// compile with: /clr /c  
public interface class IFace {  
   int i;   // C2844  
   // try the following line instead  
   // property int Size;  
};

编译器错误 C2845 Compiler Error C2845 11
：不允许对此类型的指针算术无法递增指向托管类的指针。

编译器错误 C2846 Compiler Error C2846 11
：接口不能有一个构造函数接口不能有一个构造函数。下面的示例生成 C2846: The following sample generates C2846: // C2846.cpp  
// compile with: /c  
__interface C {  
   C();   // C2846 constructor not allowed in an interface  
};

编译器错误 C2847 Compiler Error C2847 11
无法将应用到托管或类型“类”运算符可在编译时获取对象的值。由于托管或类的大小、接口或值类型是动态的，因此在编译时无法得知。例如，以下示例生成：

编译器错误 C2849 Compiler Error C2849 11
析构函数：接口不能具有析构函数接口不能具有析构函数。下面的示例生成 C2849: The following sample generates C2849: // C2849.cpp  
// compile with: /c  
__interface C {  
   ~C();   // C2849 destructor not allowed in an interface  
};

编译器错误 C2850 Compiler Error C2850 11
：仅允许在文件范围内可能不在的嵌套构造构造，如某些杂注，只能出现在全局范围内。下面的示例生成 C2850: The following sample generates C2850: // C2850.cpp  
// compile with: /c /Yc  
// try the following line instead  
// #pragma hdrstop  
namespace X {  
   #pragma hdrstop   // C2850  
};

编译器错误 C2854 Compiler Error C2854 11
中存在语法错误提供无效的文件名。杂注后面可以跟一个可选文件名中括号和引号引起来：下面的示例生成 C2854: The following sample generates C2854: // C2854.cpp  
// compile with: /c  
#pragma hdrstop( "\\source\\pchfiles\\myheader.pch" ]   // C2854  
// try the following line instead  
// #pragma hdrstop( "\\source\\pchfiles\\myheader.pch" )

编译器错误 C2855 Compiler Error C2855 11
命令行选项不一致，出现预编译标头给定的命令行选项不同于用于创建预编译标头的选项。重新生成包含给定的命令行选项的预编译标头。

编译器错误 C2856 Compiler Error C2856 11
杂注块内不能为杂注不能放在条件编译块的主体。移动语句未包含在一个区域块。

编译器错误 C2857 Compiler Error C2857 11
源文件中找不到与命令行选项指定的语句选项指定不包括正在编译的源文件中的包含文件的名称。此错误可能由未编译的条件编译块中的语句。

编译器错误 C2858 Compiler Error C2858 11
命令行选项不一致，出现预编译标头，使用使用预编译标头指定的程序数据库选项不是指定的上一个创建预编译头选项。

编译器错误 C2859 Compiler Error C2859 11
文件名不是创建此预编译标头时已使用的类型文件，请重新创建预编译标头。项目数据库和预编译标头文件必须创建在一起以确保一致的信息。重新生成项目，以进行重新创建预编译标头。有关预编译标头的信息，请参阅（预编译标头）。

编译器错误 C2860 Compiler Error C2860 11
不能是自变量类型，除外类型不能用作参数类型与其他参数。下面的示例生成 C2860: The following sample generates C2860: // C2860.cpp  
// compile with: /c  
void profunc1(void, int i);   // C2860  
void func10(void);   // OK

编译器错误 C2861 Compiler Error C2861 11
函数：接口成员函数不能定义编译器遇到了接口关键字或推导结构是接口，但随后发现成员函数定义。接口不能包含成员函数的定义。示例下面的示例生成 C2861: The following sample generates C2861: // C2861.cpp  
// compile with: /c  
#include <objbase.h>   // required for IUnknown definition  
[ object, uuid("00000000-0000-0000-0000-000000000001") ]  
__interface IMyInterface : IUnknown {  
   HRESULT mf(int a);  
};  

HRESULT IMyInterface::mf(int a) {}   // C2861

编译器错误 C2862 Compiler Error C2862 11
：接口仅可具有公共成员受保护，并且可能仅从其他成员函数访问私有成员。此类成员是在接口中的没有使用，因为它可能没有提供任何其成员的实现。下面的示例生成 C2862: The following sample will generate C2862: // C2862.cpp  
// compile with: /c  
#include <unknwn.h>  

[object, uuid="60719E20-EF37-11D1-978D-0000F805D73B"]  
__interface IMyInterface {  
   HRESULT mf1(void);   // OK  
protected:  
   HRESULT mf2(int *b);   // C2862  
private:  
   HRESULT mf3(int *c);   // C2862  
};

编译器错误 C2863 Compiler Error C2863 11
：接口不能具有友元不允许声明在接口上的友元。下面的示例生成 C2863: The following sample generates C2863: // C2863.cpp  
// compile with: /c  
#include <unknwn.h>  

class CMyClass {  
   void *f();  
};   

__interface IMyInterface {  
   void g();  

   friend int h();   // 2863  
   friend interface IMyInterface1;  // C2863  
   friend void *CMyClass::f();  // C2863  
};

编译器错误 C2864 Compiler Error C2864 11
“”：具有类中初始值设定项的静态数据成员必须具有非易失性常量整型若要初始化定义为、非或非整型的数据成员，请使用成员定义语句。无法在声明中初始化它们。此示例生成此示例演示如何修复：

编译器错误 C2865 Compiler Error C2865 11
：非法比较你可以比较对引用类和结构或托管仅对是否相等的引用类型以查看它们是否引用同一对象（）或不同的对象！。无法比较它们的排序，因为运行时可能会将托管的对象移动任何时候，从而更改测试的结果。

编译器错误 C2867 Compiler Error C2867 11
：不是命名空间指令应用于命名空间之外的内容。下面的示例生成 C2867: The following sample generates C2867: // C2867.cpp  
// compile with: /c  
namespace N {  
   class X {};  
}  
using namespace N::X;   // C2867

编译器错误 C2868 Compiler Error C2868 11
标识符：非法使用声明语法预期的限定名称声明需要限定的名称，范围运算符分隔的命名空间、类或枚举的名称标识符名称结尾的序列。单个作用域解析运算符可能用于与全局命名空间中引入一个名称。示例下面的示例生成 C2868，并还显示正确用法： The following sample generates C2868 and also shows correct usage: // C2868.cpp  
class X {  
public:  
   int i;  
};  

class Y : X {  
public:  
   using X::i;   // OK  
};  

int main() {  
   using X;   // C2868  
}

编译器错误 C2869 Compiler Error C2869 11
：已定义为命名空间你无法重用已使用与命名空间的名称。下面的示例生成 C2869: The following sample generates C2869: // C2869.cpp  
// compile with: /c  
namespace A { int i; };  

class A {};   // C2869, A is already used

编译器错误 C2870 Compiler Error C2870 11
：命名空间定义必须出现在文件范围内或在另一个命名空间定义立即定义命名空间不正确。必须在文件范围内（之外所有块和类）定义命名空间或立即在另一个命名空间中。下面的示例生成 C2870: The following sample generates C2870: // C2870.cpp  
// compile with: /c  
int main() {  
   namespace A { int i; };   // C2870  
}

编译器错误 C2871 Compiler Error C2871 11
：具有此名称的命名空间不存在不到是命名空间标识符传递时，将出现此错误使用指令。示例下面的示例生成 C2871: The following sample generates C2871: // C2871.cpp  
// compile with: /c
namespace a {
   int fn(int i) { return i; }
} 
namespace b { 
   using namespace d;   // C2871 because d is not a namespace  
   using namespace a;   // OK
}

编译器错误 C2872 Compiler Error C2872 11
符号：不明确的符号编译器无法确定所引用的符号。具有指定名称的多个符号处于范围。编译器找到不明确的符号，请参阅以下错误消息中的文件位置和声明说明。若要解决此问题，你可以完全限定的不明确的符号通过使用其命名空间，例如，或。你还可以使用命名空间别名，以为提供一个包含命名空间使用的方便短名称消除歧义在源代码中的符号。如果标头文件包含，则会发生指令，并包含了一个后续标头文件，其中包含在指定的命名空间中也是一种指令。指定指令仅在所有标头文件指定与后。有关的详细信息，请参阅知识库文章：编译器错误时你用于中的和错误平台：不明确的符号使用时的错误消息在的命名空间。示例下面的示例生成 C2872，因为不明确的引用名为的变量，所以 i ; 两个具有相同名称的变量都位于作用域： The following sample generates C2872, because an ambiguous reference is made to a variable named i ; two variables with the same name are in scope: // C2872.cpp  
// compile with: cl /EHsc C2872.cpp  
namespace A {  
   int i;  
}  

using namespace A;  
int i;  
int main() {  
   ::i++;   // ok, uses i from global namespace  
   A::i++;   // ok, uses i from namespace A  
   i++;   // C2872 ambiguous: ::i or A::i? 
   // To fix this issue, use the fully qualified name
   // for the intended variable. 
}

编译器错误 C2873 Compiler Error C2873 11
：符号不能在声明指令是缺少命名空间关键字。这将导致编译器错误地解释为代码声明而不是指令。

编译器错误 C2874 Compiler Error C2874 11
使用声明将导致的多个声明声明将导致定义两次对同一个项。下面的示例生成 C2874: The following sample generates C2874: // C2874.cpp  
namespace Z {  
   int i;  
}  

int main() {  
   int i;  
   using Z::i;   // C2874, i already declared  
}

编译器错误 C2875 Compiler Error C2875 11
使用声明将导致的多个声明声明将导致定义两次对同一个项。下面的示例生成 C2875: The following sample generates C2875: // C2875.cpp  
struct A {  
   void f(int*);  
};  

struct B {  
   void f(double*);  
};  

struct AB : A, B {  
   using A::f;  
   using A::f;   // C2875  
   using B::f;  
};

编译器错误 C2876 Compiler Error C2876 11
：并非所有重载都都可访问所有重载的形式的基的类中的函数必须可供派生的类访问。下面的示例生成 C2876: The following sample generates C2876: // C2876.cpp  
// compile with: /c  
class A {  
public:     
   double a(double);  
private:  
   int a(int);  
};  

class B : public A {  
   using A::a;   // C2876 one overload is private in base class  
};

编译器错误 C2877 Compiler Error C2877 11
不能从访问派生自的基类的所有成员都必须在派生类中可访问。下面的示例生成 C2877: The following sample generates C2877: // C2877.cpp  
// compile with: /c  
class A {  
private:  
   int a;  
};  

class B : public A {  
   using A::a;   // C2877  
};

编译器错误 C2878 Compiler Error C2878 11
：命名空间或类的此名称不存在你所做的命名空间或未定义的类的引用。下面的示例生成 C2878: The following sample generates C2878: // C2878.cpp  
// compile with: /c  
namespace A {}  
namespace B = C;   // C2878 namespace C doesn't exist  
namespace B = A;

编译器错误 C2879 Compiler Error C2879 11
：只有现有命名空间可以由命名空间别名定义提供备用名称无法创建命名空间别名以外的命名空间的其他符号。下面的示例生成 C2879: The following sample generates C2879: // C2879.cpp  
int main() {  
   int i;  
   namespace A = i;   // C2879 i is not a namespace  
}

编译器错误 C2881 Compiler Error C2881 11
已用作别名无法在两个命名空间的别名为使用相同的名称。下面的示例生成 C2881: The following sample generates C2881: // C2881.cpp  
// compile with: /c  
namespace A {  
   int k;  
}  

namespace B {  
   int i;  
}  

namespace C = A;  
namespace C = B;   // C2881 C is already an alias for A

编译器错误 C2882 Compiler Error C2882 11
：非法使用表达式中的命名空间标识符你尝试在表达式中使用命名空间的名称。下面的示例生成 C2882: The following sample generates C2882: // C2882.cpp  
// compile with: /c  
namespace A {  
   int k;  
}  

int i = A;   // C2882, can't assign A to i

编译器错误 C2883 Compiler Error C2883 11
：函数声明与由使用声明引入的冲突你尝试以不止一次定义的函数。与一个命名空间中进行的第一个定义声明。第二种是本地的定义。下面的示例生成 C2883: The following sample generates C2883: // C2883.cpp  
namespace A {  
   void z(int);  
}  

int main() {  
   using A::z;  
   void z(int);   // C2883  z is already defined  
}

编译器错误 C2884 Compiler Error C2884 11
：引起与局部函数使用声明冲突你尝试以不止一次定义的函数。第一个定义是本地的定义。第二个是与一个命名空间中声明。下面的示例生成 C2884: The following sample generates C2884: // C2884.cpp  
namespace A {  
   void z(int);  
}  

void f() {  
   void z(int);  
   using A::z;   // C2884 z is already defined  
}

编译器错误 C2885 Compiler Error C2885 11
：不使用的声明无效非类范围内你使用使用声明不正确。示例此错误可能来自于为年执行的编译器一致性工作：不再有效能够声明嵌套的类型，则必须显式限定对嵌套类型，将类型放在名称中所做的每个引用空间，或创建一个。下面的示例生成 C2885。 The following sample generates C2885. // C2885.cpp  
namespace MyNamespace {  
   class X1 {};  
}  

struct MyStruct {  
   struct X1 {  
      int i;  
   };  
};  

int main () {  
   using MyStruct::X1;   // C2885  

   // OK  
   using MyNamespace::X1;  
   X1 myX1;  

   MyStruct::X1 X12;  

   typedef MyStruct::X1 abc;  
   abc X13;  
   X13.i = 9;  
} 示例 Example 如果你使用 using 关键字后的跟类成员，c + + 需要定义该成员在其他类 （派生类）。 If you use the using keyword with a class member, C++ requires you to define that member inside another class (a derived class). 下面的示例生成 C2885。 The following sample generates C2885. // C2885_b.cpp  
// compile with: /c  
class A {  
public:  
   int i;  
};  

void z() {  
   using A::i;   // C2885 not in a class  
}  

class B : public A {  
public:  
   using A::i;  
};

编译器错误 C2886 Compiler Error C2886 11
：符号不能在成员声明声明将使用一个符号，如命名空间名称。声明是用于声明基类成员。下面的示例生成 C2886: The following sample generates C2886: // C2886.cpp  
// compile with: /c  
namespace Z {  
    int i;  
}  

class B {  
protected:  
    int i;  
};  

class D : public B {  
    // Error: Z is a namespace  
    using Z::i;   // C2886  

    // OK: B is a base class  
    using B::i;  
};

编译器错误 C2888 Compiler Error C2888 11
：无法在命名空间中定义符号必须包含的命名空间中定义属于命名空间符号下面的示例生成 C2888: The following sample generates C2888: // C2888.cpp  
// compile with: /c  
namespace M {  
   namespace N {  
      void f1();  
      void f2();  
   }  

   void N::f1() {}   // OK: namspace M encloses N  
}  

namespace O {  
   void M::N::f2() {}   // C2888 namespace O does not enclose M  
}

编译器错误 C2890 Compiler Error C2890 11
类只能有一个非接口基类引用类只能有一个基类。下面的示例生成 C2890: The following sample generates C2890: // C2890.cpp  
// compile with: /clr /c  
ref class A {};  
ref class B {};  
ref class C : public A, public B {};   // C2890  
ref class D : public A {};   // OK

编译器错误 C2891 Compiler Error C2891 11
：不能采用一个模板参数的地址不能采用一个模板参数的地址，除非它是左值。类型参数不是左值，因为它们没有任何地址。非类型值都不是左值的模板参数列表中还没有一个地址。这是代码的导致编译器错误示例，因为作为模板参数传递的值是代码的编译器生成的复制的模板自变量。都是左值，如引用类型的模板参数可以具有其采用地址。若要更正此错误，不会模板参数的地址除非它是左值。

编译器错误 C2892 Compiler Error C2892 11
局部类不应具有成员模板模板化成员函数不是有效的类中定义的函数中的。下面的示例生成 C2892: The following sample generates C2892: // C2892.cpp  
int main() {  
   struct local {  
      template<class T>   // C2892  
      void f() {}  
   };  
}

编译器错误 C2893 Compiler Error C2893 11
未能特殊化函数模板的模板名称编译器未能特殊化函数模板。可以有多种原因会导致此错误。通常情况下，解决错误的方法是先查看函数的签名并确保可以实例化每个类型。示例的发生是因为的模板参数推导为，但不具备成员不使用实例化。。下面的示例生成 C2893。 The following sample generates C2893. // C2893.cpp  
// compile with: /c /EHsc  
#include<map>  
using namespace std;  
class MyClass {};  

template<class T>   
inline typename T::data_type  
// try the following line instead  
// inline typename  T::mapped_type  
f(T const& p1, MyClass const& p2);  

template<class T>  
void bar(T const& p1) {  
    MyClass r;  
    f(p1,r);   // C2893  
}  

int main() {  
   map<int,int> m;  
   bar(m);  
}

编译器错误 C2894 Compiler Error C2894 11
模板不能声明为具有链接此错误可能由内部定义的模板块。下面的示例生成 C2894: The following sample generates C2894: // C2894.cpp  
extern "C" {  
   template<class T> class stack {};   // C2894 fail  

   template<class T> void f(const T &aT) {}   // C2894  
} 下面的示例生成 C2894: The following sample generates C2894: // C2894b.cpp  
// compile with: /c  
extern "C" template<class T> void f(const T &aT) {}   // C2894  

template<class T> void f2(const T &aT) {}   // OK

编译器错误 C2896 Compiler Error C2896 11
：不能用作参数的函数模板函数模板不能为另一个函数模板的自变量。下面的示例生成 C2896: The following sample generates C2896: // C2896.cpp  
template<class T1, class T2> void f1(void(*)(T1, T2));  
template<class T1, class T2> void f2(T1, T2);  

int main() {  
   f1(f2);   // C2896  
} 使用泛型时，也可能发生 C2896: C2896 can also occur when you use generics: // C2896b.cpp  
// compile with: /clr  
generic<class T1> void gf1(T1){}  
generic<class T1> void gf2(T1){}  

int main() {  
   gf1(gf2);   // C2896  
   gf1(1);   // OK  
}

编译器错误 C2897 Compiler Error C2897 11
析构函数终结器不能为函数模板析构函数或终结器无法进行重载，因此不允许声明析构函数作为模板（这将定义一组析构函数）。下面的示例生成 C2897: The following sample generates C2897: 示例 Example 下面的示例生成 C2897。 The following sample generates C2897. // C2897.cpp  
// compile with: /c  
class X {  
public:  
   template<typename T> ~X() {}   // C2897  
}; 示例 Example 下面的示例生成 C2897。 The following sample generates C2897. // C2897_b.cpp  
// compile with: /c /clr  
ref struct R2 {  
protected:  
   template<typename T> !R2(){}   // C2897 error  
};

编译器错误 C2898 Compiler Error C2898 11
：不能是虚拟成员函数模板下面的示例生成 C2898: The following sample generates C2898: // C2898.cpp  
// compile with: /c  
class X {  
public:  
   template<typename T> virtual void f(T t) {}   // C2898  
};

编译器错误 C3001 Compiler Error C3001 11
“”应为指令名称杂注后面必须跟有指令。下面的示例生成 C3001： The following sample generates C3001: // C3001.c  
// compile with: /openmp  
int main()  
{  
   #pragma omp   // C3001 missing token  
}

编译器错误 C3002 Compiler Error C3002 11
“”：多个指令名称不允许使用多个指令名称。下面的示例生成 C3002： The following sample generates C3002: // C3002.c  
// compile with: /openmp  
int main()  
{  
   #pragma omp parallel single   // C3002  
}

编译器错误 C3003 Compiler Error C3003 11
“”：在指令子句之后不允许使用指令名称指令名称不能位于指令子句之后。下面的示例生成 C3003： The following sample generates C3003: // C3003.c  
// compile with: /openmp  
int main()  
{  
   int x, y, z;  
   #pragma omp parallel shared(x, y, z) for   // C3003  
}

编译器错误 C3004 Compiler Error C3004 11
“”：“”指令上的子句无效在指令上使用了不支持的子句。下面的示例生成 C3004： The following sample generates C3004: // C3004.c  
// compile with: /openmp  
int main()  
{  
   int x, y, z;  

   // Shared clause not allowed for 'single' directive.  
   #pragma omp single shared(x, y)   // C3004  

   x = y;  
}

编译器错误 C3005 Compiler Error C3005 11
“”：“”指令上出现意外的标记指令格式不正确。下面的示例生成 C3005： The following sample generates C3005: // C3005.c  
// compile with: /openmp  
int main()  
{  
   #pragma omp parallel + for   // C3005  
} 如果将左大括号放置在杂注所在的行，也会发生 C3005。 C3005 can also occur if you put an open brace on the same line as the pragma. // C3005b.c  
// compile with: /openmp  
int main() {  
   #pragma omp parallel {   // C3005 put open brace on next line  
   lbl2:;  
   }  
   goto lbl2;  
}

编译器错误 C3006 Compiler Error C3006 11
“”：“”指令上的子句缺少应有的参数指令没有应有的参数。下面的示例生成 C3006： The following sample generates C3006: // C3006.c  
// compile with: /openmp  
int main()  
{  
   #pragma omp parallel shared   // C3006  
   // Try the following line instead:  
   // #pragma omp parallel shared(x) {}  

}

编译器错误 C3007 Compiler Error C3007 11
“”“”指令上的子句没有采用参数指令具有一个参数，但没有采用参数。以下示例生成：

编译器错误 C3008 Compiler Error C3008 11
“”“”指令上的参数缺少右括号“”获取参数的指令缺少右括号。以下示例生成

编译器错误 C3009 Compiler Error C3009 11
“”不允许跳转到结构化块中代码不能跳转到或跳出块。以下示例生成：

编译器错误 C3010 Compiler Error C3010 11
“”：不允许跳出结构化块代码不能跳转到或跳出块。以下示例生成：

编译器错误 C3011 Compiler Error C3011 11
并行区域内不允许直接使用内联程序集并行区域不能包含内联程序集指令。下面的示例生成 C3011： The following sample generates C3011: // C3011.cpp  
// compile with: /openmp  
// processor: /x86  
int main() {  
   int   n = 0;  

   #pragma omp parallel  
   {  
      _asm mov eax, n   // Delete this line to resolve this error.  
   }   // C3011  
}

编译器错误 C3012 Compiler Error C3012 11
内部：不允许直接并行区域内的内部函数编译器内部函数中不允许函数区域。若要解决此问题，移出该区域的内部函数，或将其替换为非内部等效项。示例下面的示例生成 C3012，并演示修复此错误的一种方法： The following sample generates C3012, and shows one way to fix it: // C3012.cpp  
// compile with: /openmp  
#ifdef __cplusplus  
extern "C" {  
#endif  
void* _ReturnAddress();  
#ifdef __cplusplus  
}  
#endif  

int main()  
{  
   #pragma omp parallel  
   {  
      _ReturnAddress();   // C3012  
   }  
   _ReturnAddress();      // OK  
}

编译器错误 C3013 Compiler Error C3013 11
“”：子句在“”指令上只能出现一次子句在同一指令上出现了两次。删除子句的一次出现。以下示例生成：

编译器错误 C3014 Compiler Error C3014 11
“”指令应后接循环除前面紧接指令的循环外，其他任何形式均为错。下面的示例生成 C3014： The following sample generates C3014: // C3014.cpp  
// compile with: /openmp  
int main()  
{  
   int i = 0;  

   #pragma omp parallel  
   {  
      #pragma omp for  
      for (i = 0; i < 10; ++i)   // OK  
      {  
      }  
   }  

   #pragma omp parallel for  
   for (i = 0; i < 10; ++i)   // OK  
   {  
   }  

   #pragma omp parallel  
   {  
      #pragma omp for  
      {   // C3014  
         for (i = 0; i < 10; ++i)  
         {  
         }  
      }  
   }  

   #pragma omp parallel for  
   {   // C3014  
      for (i = 0; i < 10; ++i)  
      {  
      }  
   }  

   #pragma omp parallel  
   {  
      #pragma omp for  
      i *= 2;   // C3014  
      for (i = 0; i < 10; ++i)  
      {  
      }  
   }  

   #pragma omp parallel for  
   i *= 2;   // C3014  
   for (i = 0; i < 10; ++i)  
   {  
   }  
}

编译器错误 C3015 Compiler Error C3015 11
“”语句中的初始化格式不正确必须完全或显式指定语句中的循环。以下示例生成：

编译器错误 C3016 Compiler Error C3016 11
“”语句中的索引变量必须是有符号的整型语句中的索引变量必须是有符号的整型。下面的示例生成 C3016： The following sample generates C3016: // C3016.cpp  
// compile with: /openmp  
int main()  
{  
   #pragma omp parallel  
   {  
      unsigned int i = 0;  
      // Try the following line instead:  
      // int i = 0;  

      #pragma omp for  
      for (i = 0; i <= 10; ++i)   // C3016  
      {  
      }  
   }  
}

编译器错误 C3017 Compiler Error C3017 11
“”语句中的终止测试格式不正确必须完全或显式指定语句中的循环。下面的示例生成 C3017： The following sample generates C3017: // C3017.cpp  
// compile with: /openmp  
int main()  
{  
   int i = 0, j = 10;  

   #pragma omp parallel  
   {  
      #pragma omp for  
      for (i = 0; i; ++i)   // C3017  
      // Try the following line instead:  
      // for (i = 0; i < 10; ++i)  
         ;  
   }  
}

编译器错误 C3018 Compiler Error C3018 11
“”“”测试或递增必须使用索引变量“”语句中的循环必须为测试和递增使用与其索引相同的变量。下面的示例生成 C3018: The following sample generates C3018: // C3018.cpp  
// compile with: /openmp  
int main()  
{  
   int i = 0, j = 5;  

   #pragma omp parallel  
   {  
      #pragma omp for  
      for (i = 0; j < 10; ++i)   // C3018  
      // try the the following line instead  
      // for (i = 0; i < 10; ++i)  
         j *= 2;  

      #pragma omp for  
      for (i = 0; i < 10; j = j + i)   // C3018  
      // try the the following line instead  
      // for (i = 0; i < 10; i = j + i)  
         j *= 2;  
   }  
}

编译器错误 C3019 Compiler Error C3019 11
在语句的增量具有格式不正确递增属于循环必须使用索引变量同时在左侧和右侧的运算符。下面的示例生成 C3019: The following sample generates C3019: // C3019.cpp  
// compile with: /openmp  
int main()  
{  
   int i = 0, j = 1, n = 3;  

   #pragma omp parallel  
   {  
      #pragma omp for  
      for (i = 0; i < 10; i = j + n)   // C3019  
      // Try the following line instead:  
      // for (i = 0; i < 10; i++)  
         j *= 2;  
   }  
}

编译器错误 C3020 Compiler Error C3020 11
：不能在循环体中修改索引变量的循环循环不能修改的正文中的索引（循环计数器）循环。下面的示例生成 C3020: The following sample generates C3020: // C3020.cpp  
// compile with: /openmp  
int main() {  
   int i = 0, n = 3;  

   #pragma omp parallel  
   {  
      #pragma omp for  
      for (i = 0; i < 10; i += n)  
         i *= 2;   // C3020  
         // try the following line instead  
         // n++;  
   }  
} 与声明的变量 lastprivate 不能用作并行化循环内的索引。 A variable declared with lastprivate cannot be used as the index inside a parallelized loop. 下面的示例将为第二个 lastprivate 产生 C3020，因为该 lastprivate 将触发写入中最外面的 idx_a for 循环。 The following sample will give C3020 for the second lastprivate because that lastprivate will trigger a write to idx_a within the outermost for loop. 第一个 lastprivate 不产生错误，因为该 lastprivate 触发写入外部最外面的 idx_a for 循环 （从技术上讲，在最后一次迭代的结尾）。 The first lastprivate doesn't give an error because that lastprivate triggers a write to idx_a outside the outermost for loop (technically, at the very end of the last iteration). 下面的示例生成 C3020。 The following sample generates C3020. // C3020b.cpp  
// compile with: /openmp /c  
float a[100][100];  
int idx_a, idx_b;  
void test(int first, int last)  
{  
   #pragma omp parallel for lastprivate(idx_a)  
   for (idx_a = first; idx_a <= last; ++idx_a) {  
      #pragma omp parallel for lastprivate(idx_a)   // C3020  
      for (idx_b = first; idx_b <= last; ++idx_b) {  
         a[idx_a][idx_b] += 1.0f;  
      }  
   }  
} 以下示例演示了可能的解决方法： The following sample demonstrates a possible resolution: // C3020c.cpp  
// compile with: /openmp /c  
float a[100][100];  
int idx_a, idx_b;  
void test(int first, int last)  
{  
   #pragma omp parallel for lastprivate(idx_a)  
   for (idx_a = first; idx_a <= last; ++idx_a) {  
      #pragma omp parallel for lastprivate(idx_b)  
      for (idx_b = first; idx_b <= last; ++idx_b) {  
         a[idx_a][idx_b] += 1.0f;  
      }  
   }  
}

编译器错误 C3021 Compiler Error C3021 11
“”“”指令上的参数为空指令需要参数。示例下面的示例生成 C3021： The following sample generates C3021: // C3021.cpp  
// compile with: /openmp  
#include <stdio.h>  
#include "omp.h"  

int g = 0;  

int main()  
{  
    int x, y, i;  

    #pragma omp parallel for schedule(static,)   // C3021  
    for (i = 0; i < 10; ++i) ;  

    #pragma omp parallel for schedule()   // C3021  
    for (i = 0; i < 10; ++i)  
        printf_s("Hello world, thread %d, iteration %d\n",  
                 omp_get_thread_num(), i);  

    #pragma omp parallel reduction()   // C3021  
      ;  

    #pragma omp parallel reduction(+ :)   // C3021  
      ;  

    //   
    // The following shows correct syntax examples.  
    //  
    #pragma omp parallel reduction(+ : x, y)  
      ;  

    #pragma omp parallel reduction(* : x, y)  
      ;  

    #pragma omp parallel reduction(- : x, y)  
      ;  

    #pragma omp parallel reduction(& : x, y)  
      ;  

    #pragma omp parallel reduction(^ : x, y)  
      ;  

    #pragma omp parallel reduction(| : x, y)  
      ;  

    #pragma omp parallel reduction(&& : x, y)  
      ;  

    #pragma omp parallel reduction(|| : x, y)  
      ;  
}

编译器错误 C3022 Compiler Error C3022 11
“”：在“”指令上的“”的计划类型无效一个不支持的值传递到子句。以下示例生成：

编译器错误 C3023 Compiler Error C3023 11
“”：在“”子句的参数中遇到意外的标记传递给子句的值无效。以下示例生成：

编译器错误 C3024 Compiler Error C3024 11
“”不允许使用表达式不能将值传递给子句的运行时参数。下面的示例生成 C3024： The following sample generates C3024: // C3024.cpp  
// compile with: /openmp /link vcomps.lib  
#include <stdio.h>  
#include "omp.h"  

int main() {  
   int i;  

   #pragma omp parallel for schedule(runtime, 10)   // C3024  
   for (i = 0; i < 10; ++i) ;  

   #pragma omp parallel for schedule(runtime)   // OK  
   for (i = 0; i < 10; ++i) ;  
}

编译器错误 C3025 Compiler Error C3025 11
“”：应为整型表达式子句需要整型表达式，但提供了非整型表达式。示例下面的示例生成 C3025。 The following sample generates C3025. // C3025.cpp  
// compile with: /openmp /link vcomps.lib  
#include <stdio.h>  
#include "omp.h"  

float f = 2.0F;  

int main()   
{  
    int i = 0;  

    // OK  
    puts("Test with int");  
    #pragma omp parallel for num_threads(i)  
    for (i = 1; i <= 2; ++i)  
        printf_s("Hello World - thread %d - iteration %d\n",  
                 omp_get_thread_num(), i);  

    puts("Test with float");  
    #pragma omp parallel for num_threads(f)   // C3025  
    for (i = 1; i <= 2; ++i)  
        printf_s("Hello World - thread %d - iteration %d\n",  
                 omp_get_thread_num(), i);  
}

编译器错误 C3026 Compiler Error C3026 11
“”常量表达式必须为正向子句传递了一个整数值，但此值不是正数。此值必须是正数。示例下面的示例生成 C3026： The following sample generates C3026: // C3026.cpp  
// compile with: /openmp /link vcomps.lib  
#include <stdio.h>  
#include "omp.h"  

int main()  
{  
    int i;  
    const int i1 = 0;  

    #pragma omp parallel for num_threads(i1)   // C3026  
    for (i = 1; i <= 2; ++i)  
        printf_s("Hello World - thread %d - iteration %d\n",  
                 omp_get_thread_num(), i);  

    #pragma omp parallel for num_threads(i1 + 1)   // OK  
    for (i = 1; i <= 2; ++i)  
        printf_s("Hello World - thread %d - iteration %d\n",  
                 omp_get_thread_num(), i);  
}

编译器错误 C3027 Compiler Error C3027 11
“”需要算术表达式或指针表达式需要算术表达式或指针表达式的子句传递了另一种表达式。示例下面的示例生成 C3027： The following sample generates C3027: // C3027.cpp  
// compile with: /openmp /link vcomps.lib  
#include <stdio.h>  
#include "omp.h"  

struct MyStruct   
{  
    int x;  
} m_MyStruct;  

int main()   
{  
    int i;  

    puts("Test with class MyStruct:\n");  
    #pragma omp parallel for if(m_MyStruct)   // C3027  
    for (i = 1; i <= 2; ++i)  
        printf_s("Hello World - thread %d - iteration %d\n",  
                 omp_get_thread_num(), i);  

    puts("Test with int:\n");  
    #pragma omp parallel for if(9)   // OK  
    for (i = 1; i <= 2; ++i)  
        printf_s("Hello World - thread %d - iteration %d\n",  
                 omp_get_thread_num(), i);  
}

编译器错误 C3028 Compiler Error C3028 11
：只有变量或静态数据成员可以使用的子句中向子句传递的变量或静态数据成员以外的符号。下面的示例生成 C3028: The following sample generates C3028: // C3028.cpp  
// compile with: /openmp /link vcomps.lib  
int g_i;  

class MyClass {  
public:  
   MyClass();  
   MyClass(int x);  
   static int x_public;  
   int mbr;  
private:  
   static int x_private;  
};  

int MyClass::x_public;  
int MyClass::x_private;  

namespace XyzNS {  
   struct xyz { int x; };  
   xyz xyz;  
}  

namespace NS {  
   int a1;  
   struct Bar {  
      static MyClass MyClass;  
   };  
   struct Baz : public Bar {  
      using NS::Bar::MyClass;  
   };  
}  

MyClass NS::Bar::MyClass;  

typedef int MyInt;  

template <class T, size_t n> class CTempl {  
public:  
   static T public_array[n];  
private:  
   static T private_array[n];  
};  

template<class T,size_t n> T CTempl<T,n>::public_array[n];  
template<class T,size_t n> T CTempl<T,n>::private_array[n];  

CTempl<int,5> tx;  

struct Incomplete;  
extern Incomplete inc;  

MyClass::MyClass(int x) {  

   #pragma omp parallel reduction(+: x, g_i, x_public, x_private)     
   // OK  
      ;  

   #pragma omp parallel reduction(+: x, g_i, MyClass::x_public,   
   MyClass::x_private)     
   // OK  
      ;  

   #pragma omp parallel reduction(+: mbr)     
   // C3028, member of a class.  
      ;  
}  

int main() {  

   #pragma omp parallel reduction(+:main)     
   // C3028, main is a function.  
      ;  

   #pragma omp parallel reduction(+: XyzNS)     
   // C3028, XyzNS is a namespace.  
      ;  
}

编译器错误 C3029 Compiler Error C3029 11
“”只能在指令中的子句中出现一次指令中一个或多个子句中多次使用符号。符号只能在指令中使用一次。以下示例生成：

编译器错误 C3030 Compiler Error C3030 11
“”：“”子句指令中的变量不能是引用类型只能将值参数传递到某些子句，如子句。下面的示例生成 C3030： The following sample generates C3030: // C3030.cpp  
// compile with: /openmp /link vcomps.lib  
#include "omp.h"  

void test(int &r) {  
   #pragma omp parallel reduction(+ : r)   // C3030  
      ;  
}  

void test2(int r) {  
   #pragma omp parallel reduction(+ : r)   // OK  
      ;  
}  

int main(int argc, char** argv) {  
   int& r = *((int*)argv);  
   int s = *((int*)argv);  

   #pragma omp parallel reduction(+ : r)   // C3030  
      ;  

   #pragma omp parallel reduction(+ : s)   // OK  
      ;  
}

编译器错误 C3031 Compiler Error C3031 11
“”：“”子句中的变量必须是标量算术类型向子句传递了错误类型的变量。下面的示例生成 C3031： The following sample generates C3031: // C3031.cpp  
// compile with: /openmp /link vcomps.lib  
#include <stdio.h>  
#include "omp.h"  

typedef struct {  
   int n;  
} Incomplete;  

extern Incomplete inc;  
int i = 9;  

int main() {  
   #pragma omp parallel reduction(+: inc)   // C3031   
      ;  

   #pragma omp parallel reduction(+: i)     // OK  
      ;  
}

编译器错误 C3032 Compiler Error C3032 11
“”“”子句中的变量不能是不完整的“类型”类型传递给某些子句的类型必须对编译器完全可见。下面的示例生成 C3032: The following sample generates C3032: // C3032.cpp  
// compile with: /openmp /link vcomps.lib  
#include "omp.h"  

struct Incomplete;  
extern struct Incomplete inc;  

int main() {  
   int i = 9;  
   #pragma omp parallel private(inc)   // C3032  
      ;  

   #pragma omp parallel private(i)     // OK  
      ;  

}

编译器错误 C3033 Compiler Error C3033 11
“”“”子句中的变量不能是常量限定类型传递给某些子句的值不能为变量。下面的示例生成 C3033： The following sample generates C3033: // C3033.cpp  
// compile with: /openmp /link vcomps.lib  
int main() {  
   const int val = 1;  
   int val2 = 1;  

   #pragma omp parallel reduction(+ : val)   // C3033  
   ;  

   #pragma omp parallel reduction(+ : val2)   // OK  
   ;  
}

编译器错误 C3034 Compiler Error C3034 11
“”指令不能直接嵌套在“”指令中一些指令不能嵌套。若要修复此错误，你可以将这两个指令语句合并到一个指令的块中或可以构造连续指令。以下示例生成：

编译器错误 C3035 Compiler Error C3035 11
“”指令必须使用“”子句直接绑定到“”或“”指令子句的格式不正确。下面的示例生成 C3035： The following sample generates C3035: // C3035.cpp  
// compile with: /openmp /link vcomps.lib  
int main() {  
   int n = 0, x, i;  

   #pragma omp parallel private(n)  
   {  
      #pragma omp ordered   // C3035  
      // Try the following line instead:  
      // #pragma omp for ordered  
       for (i = 0 ; i < 10 ; ++i)  
         ;  
   }  
}

编译器错误 C3036 Compiler Error C3036 11
“”：“”子句中的运算符标记无效未正确指定子句。下面的示例生成 C3036： The following sample generates C3036: // C3036.cpp  
// compile with: /openmp  
static float a[1000], b[1000], c[1000];  
void test1(int first, int last) {  
   static float dp = 0.0f;  
   #pragma omp for nowait reduction(.:dp)   // C3036  
   // try the following line instead  
   // #pragma omp for nowait reduction(+: dp)  
   for (int i = first ; i <= last ; ++i)  
      dp += a[i] * b[i];  
}

编译器错误 C3037 Compiler Error C3037 11
“”“”子句中的变量必须在封闭上下文中共享子句中指定的变量可能不是上下文中每个线程私有的。下面的示例生成 C3037： The following sample generates C3037: // C3037.cpp  
// compile with: /openmp /c  
int g_i;  

int main() {  
   int i;  

   #pragma omp parallel private(g_i)  
   // try the following line instead  
   // #pragma omp parallel   
   {  
      #pragma omp for reduction(+:g_i)   // C3037  
      for (i = 0 ; i < 10 ; ++i) {  
         g_i += i;  
      }  
   }  
}

编译器错误 C3038 Compiler Error C3038 11
“”：“”子句中的变量不能是封闭上下文中的变量并行指令的子句中出现的变量不能在子句中指定，后者位于绑定到并行构造的工作共享指令上。下面的示例生成 C3038： The following sample generates C3038: // C3038.cpp  
// compile with: /openmp /c  
int g_i, g_i2;  

int main() {  
   int i;  

   #pragma omp parallel reduction(+: g_i)  
   {  
      #pragma omp for private(g_i)   // C3038  
      // try the following line instead  
      // #pragma omp for private(g_i2)  
      for (i = 0; i < 10; ++i)  
         g_i += i;  
   }  
}

编译器错误 C3039 Compiler Error C3039 11
“”“”语句中索引变量不能是变量索引变量是隐式私有变量，因此该变量不能用于一组指令中的子句。示例以下示例生成

编译器错误 C3040 Compiler Error C3040 11
“”：“”子句中的变量类型与运算符“”不兼容子句中的变量不能与运算符一起使用。下面的示例生成 C3040： The following sample generates C3040: // C3040.cpp  
// compile with: /openmp /c  
#include "omp.h"  
double d;  

int main() {  
   #pragma omp parallel reduction(&:d)   // C3040  
      ;  

   #pragma omp parallel reduction(-:d)  // OK  
      ;  
}

编译器错误 C3041 Compiler Error C3041 11
“”：””子句中的变量在封闭上下文中必须是私有的传递给的变量不能在封闭上下文中共享。以下示例生成：

编译器错误 C3042 Compiler Error C3042 11
“”和“”子句不能同时出现在“”指令中和子句在指定的指令上彼此排斥。若要修复此错误，请删除或子句之一或两者一起删除。以下示例生成：

编译器错误 C3043 Compiler Error C3043 11
“”指令不能嵌套在同名的“”指令中指令不能嵌套在具有相同名称的指令中。下面的示例生成 C3043： The following sample generates C3043: // C3043.cpp  
// compile with: /openmp /c  
#include "omp.h"  

int main() {  
   int n1 = 1, n2 = 2, n3 = 3;  

   #pragma omp parallel  
   {  
      ++n2;  

      #pragma omp critical(MyTest)  
      {  
         ++n2;  

         #pragma omp critical(MyTest)   // C3043  
         // try the following line instead  
         // #pragma omp critical(MyTest2)  
         {  
            ++n3;  
         }  
      }  
   }  
}

编译器错误 C3044 Compiler Error C3044 11
“”只允许直接嵌套在“”指令中编译器发现指令未正确使用。有关详细信息，请参见部分。以下示例生成：

编译器错误 C3045 Compiler Error C3045 11
“”指令后应为一个复合语句。缺少“”用大括号分隔的代码块必须跟在指令之后。下面的示例生成 C3045： The following sample generates C3045: // C3045.cpp  
// compile with: /openmp /c  
#include "omp.h"  

int main() {  
   int n2 = 2, n3 = 3;  

   #pragma omp parallel  
   {  
      ++n2;  

      #pragma omp sections  
         ++n2;   // C3045  

      #pragma omp sections   // OK  
      {  
         ++n3;  
      }  
   }  
}

编译器错误 C3046 Compiler Error C3046 11
“”区域中缺少结构化块指令具有一个空代码块。下面的示例生成 C3046： The following sample generates C3046: // C3046.cpp  
// compile with: /openmp /c  
#include "omp.h"  

int main() {  
   int n2 = 2, n3 = 3;  

   #pragma omp parallel  
   {  
      ++n2;  

      #pragma omp sections  
      {  
/*  
         ++n2;  

         #pragma omp section  
         {  
            ++n3;  
         }  
*/  
       }   // C3046 uncomment code to resolve this C3046  
   }  
}

编译器错误 C3047 Compiler Error C3047 11
“”区域中的结构化块的前面必须是“”指令所引入代码块中的任何代码必须位于指令引入的代码块中。下面的示例生成 C3047： The following sample generates C3047: // C3047.cpp  
// compile with: /openmp /c  
#include "omp.h"  

int main() {  
   int n2 = 2, n3 = 3;  

   #pragma omp parallel  
   {  
      ++n2;  

      #pragma omp sections  
      {  

         #pragma omp section  
         {  
            ++n3;  
         }  

         ++n2;   // C3047 not enclosed in #pragma omp section  
      }  
   }  
}

编译器错误 C3048 Compiler Error C3048 11
“”后面的表达式格式不正确未正确指定了原子指令。下面的示例生成 C3048： The following sample generates C3048: // C3048.cpp  
// compile with: /openmp vcomps.lib  
#include "omp.h"  
#include <stdio.h>  

int main() {  
   int a[10];  
   omp_set_num_threads(4);  
   #pragma omp parallel  
   {  
      #pragma omp atomic  
      a[0] = 1;   // C3048  
      // try the following line instead  
      // a[0] += 1;  
   }  
}

编译器错误 C3049 Compiler Error C3049 11
“”“”子句中的参数无效向子句传递的值不正确。下面的示例生成 C3049： The following sample generates C3049: // C3049.cpp  
// compile with: /openmp /c  
int main() {  
   int n1 = 1;  

   #pragma omp parallel default(private)   // C3049   
   // try the following line instead  
   // #pragma omp parallel default(shared)  
   {  
      ++n1;  
   }  
}

编译器错误 C3050 Compiler Error C3050 11
“”：类不能从“”继承不能作为引用类型的基类。以下示例生成：

编译器错误 C3052 Compiler Error C3052 11
“”子句下的子句中未出现变量若使用，则结构化块中使用的任何变量均必须显式指定为或。下面的示例生成 C3052： The following sample generates C3052: // C3052.cpp  
// compile with: /openmp /c  
int main() {  
   int n1 = 1;  

   #pragma omp parallel default(none) // shared(n1) private(n1)  
   {  
      n1 = 0;   // C3052 use either a shared or private clause  
   }  
}

编译器错误 C3053 Compiler Error C3053 11
“”“”只对全局或静态数据项有效传递给的符号必须是全局或静态的。以下示例生成：可能的解决方法：

编译器错误 C3054 Compiler Error C3054 11
当前在泛型类或函数中不支持“”有关详细信息，请参阅泛型和。示例下面的示例生成 C3054。 The following sample generates C3054. // C3054.cpp  
// compile with: /openmp /clr /c  
#include <omp.h>  

ref struct MyBaseClass {  
   // Delete the following 7 lines to resolve.  
   generic <class ItemType>  
   void Test(ItemType i) {   // C3054  
      #pragma omp parallel num_threads(4)  
      {  
         int i = omp_get_thread_num();  
      }  
   }  

   // OK  
   void Test2() {  
      #pragma omp parallel num_threads(4)  
      {  
         int i = omp_get_thread_num();  
      }  
   }  
};

编译器错误 C3055 Compiler Error C3055 11
“”：符号在用于“”指令之前无法引用引用了一个符号，然后在子句中使用，这是不允许的。下面的示例生成 C3055： The following sample generates C3055: // C3055.cpp  
// compile with: /openmp  
int x, y;  
int z = x;  
#pragma omp threadprivate(x, y)   // C3055  

void test() {  
   #pragma omp parallel copyin(x, y)  
   {  
      x = y;  
   }  
} 可能的解决方法： Possible resolution: // C3055b.cpp  
// compile with: /openmp /LD  
int x, y, z;  
#pragma omp threadprivate(x, y)  

void test() {  
   #pragma omp parallel copyin(x, y)  
   {  
      x = y;  
   }  
}

编译器错误 C3056 Compiler Error C3056 11
“”符号所在范围与“”指令所在范围不同在子句中使用的符号必须位于与子句相同的范围中。下面的示例生成 C3056： The following sample generates C3056: // C3056.cpp  
// compile with: /openmp  
int x, y;  
void test() {  
   #pragma omp threadprivate(x, y)   // C3056  
   #pragma omp parallel copyin(x, y)  
   {  
      x = y;  
   }  
} 可能的解决方法： Possible resolution: // C3056b.cpp  
// compile with: /openmp /LD  
int x, y;  
#pragma omp threadprivate(x, y)  
void test() {  
   #pragma omp parallel copyin(x, y)  
   {  
      x = y;  
   }  
}

编译器错误 C3057 Compiler Error C3057 11
“”：当前不支持“”符号的动态初始化子句中所用符号的初始化值在编译时必须已知。以下示例生成：以下示例生成：

编译器错误 C3058 Compiler Error C3058 11
“符号”：符号在用于“”子句之前，不能声明为“”符号在用于子句之前，不能声明为。下面的示例生成 C3058: The following sample generates C3058: // C3058.cpp  
// compile with: /openmp  
int x, y, z;  
#pragma omp threadprivate(x, z)  

void test() {  
   #pragma omp parallel copyin(x, y)   // C3058  
   {  
   }  
} 可能的解决方法： Possible resolution: // C3058b.cpp  
// compile with: /openmp /LD  
int x, y, z;  
#pragma omp threadprivate(x, y)  

void test() {  
   #pragma omp parallel copyin(x, y)  
   {  
   }  
}

编译器错误 C3059 Compiler Error C3059 11
“”：“”符号不能用于“”子句中子句中使用符号。下面的示例生成 C3059： The following sample generates C3059: // C3059.cpp  
// compile with: /openmp  
#include "omp.h"  
int x, y;  
#pragma omp threadprivate(x, y)  

int main() {  
   #pragma omp parallel private(x, y)   // C3059  
   {  
      x = y;  
   }  
} 可能的解决方法： Possible resolution: // C3059b.cpp  
// compile with: /openmp  
#include "omp.h"  
int x = 0, y = 0;  

int main() {  
   #pragma omp parallel firstprivate(y) private(x)  
   {  
      x = y;  
   }  
}

编译器错误 C3060 Compiler Error C3060 11
“”：友元函数可能没有使用限定名在类内定义（可能只声明了它）使用限定名称定义了友元函数，不允许这样做。下面的示例生成 C3060： The following sample generates C3060: // C3060.cpp  
class A {  
public:  
   void func();  
};  

class C {  
public:  
   friend void A::func() { }   // C3060  
   // Try the following line and the out of class definition:  
   // friend void A::func();  
};  

// void A::func(){}

编译器错误 C3062 Compiler Error C3062 11
枚举器需要值，由于基础类型为你可以指定枚举的基础类型。但是，某些类型需要你将值分配到每个枚举器。枚举的详细信息，请参阅枚举类。下面的示例生成 C3062: The following sample generates C3062: // C3062.cpp  
// compile with: /clr  

enum class MyEnum : bool { a };   // C3062  
enum class MyEnum2 : bool { a = true};   // OK

编译器错误 C3063 Compiler Error C3063 11
运算符：所有操作数必须都具有相同的枚举类型当在枚举器上使用运算符，两个操作数必须是枚举类型。有关详细信息，请参阅如何：定义和使用枚举在。示例下面的示例生成 C3063，并演示如何修复此错误： The following sample generates C3063 and shows how to fix it: // C3063.cpp  
// compile with: /clr  
enum class E { a, b } e, mask;  
int main() {  
   if ( ( e & mask ) != 0 ) ;   // C3063 no operator!= (E, int)  

   if ( ( e & mask ) != E() )   // OK  
      ;  
}

编译器错误 C3065 Compiler Error C3065 11
不允许在非类范围上声明属性在类的外部使用了修饰符。只能在类内部声明属性。以下示例生成：

编译器错误 C3066 Compiler Error C3066 03
有多种方法可以调用此类型的对象使用这些自变量编译器检测到涉及代理项的不明确的函数调用。下面的示例生成 C3066: The following sample generates C3066: // C3066.cpp  
template <class T, class U> void func(T*, U*){}  

typedef void (*PF)(const int*, const char*);  
typedef void (*PF1)(const int*, volatile char*);  

struct A {  
   operator PF() const {  
      return func;  
   }  

   operator PF1() {  
      return func;  
   }  

   operator PF1() const  {  
      return func;  
   }  

};  

int main() {  
   A a;  
   int i;  
   char c;  

   a(&i, &c);   // C3066  
   a(&i, (const char *) &c);   // OK  
} 复制列表初始化 Copy-list-initialization 在 Visual Studio 2015 中，编译器以与常规复制初始化相同的方式错误地处理复制列表初始化；它只考虑将转换构造函数用于重载决策。 In Visual Studio 2015, the compiler erroneously treated copy-list-initialization in the same way as regular copy-initialization; it considered only converting constructors for overload resolution. 在以下示例中，Visual Studio 2015 选择 MyInt(23)，但 Visual Studio 2017 正确引发错误。 In the following example, Visual Studio 2015 chooses MyInt(23) but Visual Studio 2017 correctly raises the error. // From http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1228
struct MyList {
       explicit MyStore(int initialCapacity);
};

struct MyInt {
       MyInt(int i);
};

struct Printer {
       void operator()(MyStore const& s);
       void operator()(MyInt const& i);
};

void f() {
       Printer p;
       p({ 23 }); // C3066: there are multiple ways that an object of this type can be called with these arguments
}

编译器错误 C3068 Compiler Error C3068 11
函数不能包含需要展开如果发生了异常的对象编译器无法执行堆栈展开上裸函数引发了异常，因为临时对象的创建中的函数和异常处理指定。若要解决此错误，请执行至少一个以下操作：使用不编译。不要标记的功能与。函数中创建临时对象。如果函数在堆栈中，创建临时对象，如果该函数将引发异常，并且启用异常处理，编译器将清理堆栈如果引发异常。当引发异常，编译器生成的代码，调用和和其中不存在的裸函数中时，将执行的函数。示例下面的示例生成 C3068: The following sample generates C3068: // C3068.cpp  
// compile with: /EHsc  
// processor: x86  
class A {  
public:  
   A(){}  
   ~A(){}  
};  

void b(A){}  

__declspec(naked) void c() {  
   b(A());   // C3068   
};

编译器错误 C3069 Compiler Error C3069 11
“”不允许用于枚举类型枚举不支持运算符。有关详细信息，请参阅如何：定义和使用枚举在。示例下面的示例生成 C3069： The following sample generates C3069: // C3069.cpp  
// compile with: /clr  
enum struct E { e1 };  
enum F { f1 };  

int main() {  
   E e = E::e1;  
   bool tf;  
   tf = !e;   // C3069  

   // supported for native enums  
   F f = f1;  
   tf = !f;  
}

编译器错误 C3070 Compiler Error C3070 11
“”属性没有“”方法未定义属性的访问器方法。有关详细信息，请参阅。以下示例生成：

编译器错误 C3071 Compiler Error C3071 11
运算符“”只能应用于类或值类型实例中不能在本机类型上使用运算符。可以在类或结构（值类型）上使用运算符，但不可在本机类型（如）或本机类型的别名（如）上使用。这些类型不能从代码中以引用本机变量的方式进行装箱，因此无法使用此运算符。有关详细信息，请参阅跟踪引用运算符。示例以下示例生成。

编译器错误 C3072 Compiler Error C3072 11
运算符无法应用于类的实例使用一元运算符将类的实例转换为句柄类型类型需要运算符，不能使用本机（或标准）运算符。有关详细信息，请参阅跟踪引用运算符。示例下面的示例生成 C3072。 The following sample generates C3072. // C3072.cpp  
// compile with: /clr  
ref class R {};  

int main() {  
   R r1;  
   R^ r2 = &r1;   // C3072  
   R^ r3 = %r1;   // OK  
}

编译器错误 C3073 Compiler Error C3073 11
类没有用户定义的复制构造函数在（公共语言运行时编译）编译，编译器不会生成引用类型的复制构造函数。在任何编译，你必须定义你自己对于引用类型的复制构造函数如果你预计要复制的类型的实例。有关详细信息，请参阅对于引用类型的堆栈语义。示例下面的示例生成 C3073。 The following sample generates C3073. // C3073.cpp  
// compile with: /clr  
ref class R {  
public:  
   R(int) {}  
};  

ref class S {  
public:  
   S(int) {}  
   S(const S %rhs) {}   // copy constructor  
};  

void f(R) {}  
void f2(S) {}  
void f3(R%){}  

int main() {  
   R r(1);  
   f(r);   // C3073  
   f3(r);   // OK  

   S s(1);  
   f2(s);   // OK  
}

编译器错误 C3075 Compiler Error C3075 11
“”：无法将引用类型“”的实例嵌入到值类型中值类型不能包含引用类型的实例。有关详细信息，请参阅对于引用类型的堆栈语义。示例以下示例生成。

编译器错误 C3076 Compiler Error C3076 11
：不能在本机类型中嵌入一个引用类型，的实例本机类型不能包含类型的实例。有关详细信息，请参阅对于引用类型的堆栈语义。示例下面的示例生成 C3076。 The following sample generates C3076. // C3076.cpp  
// compile with: /clr /c  
ref struct U {};  

struct V {  
   U y;   // C3076  
};  

ref struct W {  
   U y;   // OK  
};

编译器错误 C3077 Compiler Error C3077 11
“”：终结器只能是引用类型的成员不能在本机类型或值类型中声明终结器。有关详细信息，请参阅析构函数和终结器中如何：定义和使用类和结构。示例下面的示例生成 C3077。 The following sample generates C3077. // C3077.cpp  
// compile with: /clr /c  
value struct vs {  
   !vs(){}   // C3077  
};  

ref struct rs {  
protected:  
   !rs(){}   // OK  
};

编译器错误 C3080 Compiler Error C3080 11
“”：终结器不能具有存储类说明符有关详细信息，请参阅析构函数和终结器中如何：定义和使用类和结构。示例下面的示例生成 C3080。 The following sample generates C3080. // C3080.cpp  
// compile with: /clr /c  
ref struct rs {  
protected:  
   static !rs(){}   // C3080  
   !rs(){}   // OK  
};

编译器错误 C3083 Compiler Error C3083 11
：左侧的符号必须是类型不正确地调用的函数。示例下面的示例生成 C3083。 The following sample generates C3083. // C3083.cpp  
// compile with: /c  
struct N {  
   ~N();  
};  

struct N1 {  
   ~N1();  
};  

N::N::~N() {}   // C3083  
N1::~N1() {}   // OK

编译器错误 C3084 Compiler Error C3084 11
“函数”终结器析构函数不能是“关键字”未正确声明终结器或析构函数。例如，析构函数不应标记为密封。派生类型无法访问析构函数。有关详细信息，请参阅显式重写和析构函数和终结器中如何：定义和使用类和结构。示例以下示例生成。

编译器错误 C3085 Compiler Error C3085 11
“”：构造函数不能是“”未正确声明构造函数。有关更多信息，请参见。示例以下示例生成。

编译器错误 C3087 Compiler Error C3087 11
“”：对“”的调用已将此成员初始化在同一值的未命名参数所在的特性快中指定了已命名参数。仅指定一个已命名或未命名参数。示例下面的示例生成 C3087。 The following sample generates C3087. // C3087.cpp  
// compile with: /c  
[idl_quote("quote1", text="quote2")];   // C3087  
[idl_quote(text="quote3")];   // OK  
[idl_quote("quote4")];   // OK

编译器错误 C3094 Compiler Error C3094 11
“”：不允许匿名使用未正确确定特性的范围。有关详细信息，请参阅。示例下面的示例生成 C3094。 The following sample generates C3094. // C3094.cpp  
// compile with: /clr /c  
using namespace System;  
[AttributeUsage(AttributeTargets::Class)]  
public ref class AAttribute : Attribute {};  

[A];   // C3094  

// OK  
[A]  
ref class x{};

编译器错误 C3095 Compiler Error C3095 11
“”特性不能重复已声明某些特性，因此不能将特性的多个匹配项应用于一个目标。有关详细信息，请参阅。示例下面的示例生成 C3095。 The following sample generates C3095. // C3095.cpp  
// compile with: /clr /c  
using namespace System;  

[AttributeUsage(AttributeTargets::All, AllowMultiple=false)]  
public ref class Attr : public Attribute {  
public:  
   Attr(int t) : m_t(t) {}  
   const int m_t;  
};  

[AttributeUsage(AttributeTargets::All, AllowMultiple=true)]  
public ref class Attr2 : public Attribute {  
public:  
   Attr2(int t) : m_t(t) {}  
   const int m_t;  
};  

[Attr(10)]   // C3095  
[Attr(11)]  
ref class A {};  

[Attr2(10)]   // OK  
[Attr2(11)]  
ref class B {};

编译器错误 C3096 Compiler Error C3096 11
“”：特性只能用于特性类的数据成员未正确应用特性。有关详细信息，请参阅。

编译器错误 C3097 Compiler Error C3097 11
“”特性必须使用“”或“”确定范围未正确使用全局特性。有关详细信息，请参阅。示例以下示例生成。

编译器错误 C3099 Compiler Error C3099 11
“关键字”：将用于托管特性；将用于特性使用声明属性。使用声明运行时特性。有关特性的详细信息，请参阅用户定义的特性。有关受支持运行时中的属性，请参阅命名空间示例下面的示例生成 C3099，并演示如何修复此错误。 The following sample generates C3099 and shows how to fix it. // C3099.cpp  
// compile with: /clr /c  
using namespace System;  
[usage(10)]   // C3099  
// try the following line instead  
// [AttributeUsageAttribute(AttributeTargets::All)]  
ref class A : Attribute {};

编译器错误 C3100 Compiler Error C3100 11
未知的属性限定符指定了无效的属性目标。有关详细信息，请参阅。示例下面的示例生成 C3100。 The following sample generates C3100. // C3100.cpp  
// compile with: /clr /c  
using namespace System;  
[AttributeUsage(AttributeTargets::All)]  
public ref class Attr : public Attribute {  
public:  
   Attr(int t) : m_t(t) {}  
   int m_t;  
};  

[invalid_target:Attr(10)];   // C3100  
[assembly:Attr(10)];   // OK

编译器错误 C3101 Compiler Error C3101 11
非法表达式已命名的特性自变量当初始化命名的特性自变量，值必须是编译时常量。属性的详细信息，请参阅用户定义的特性。示例下面的示例生成 C3101。 The following sample generates C3101. // C3101.cpp  
// compile with: /clr /c  
ref class AAttribute : System::Attribute {  
public:  
   int Field;  
};  

extern int i;  

[assembly:A(Field = i)];   // C3101  
[assembly:A(Field = 0)];   // OK

编译器错误 C3103 Compiler Error C3103 11
自变量：重复的命名的参数属性不能重复命名自变量。有关详细信息，请参阅。示例下面的示例生成 C3103。 The following sample generates C3103. // C3103.cpp  
// compile with: /clr /c  
using namespace System;  

[AttributeUsage(AttributeTargets::All)]  
public ref class Attr : public Attribute {  
public:  
   int m_t;  
};  

[Attr(m_t = 10, m_t = 1)]   // C3103  
// try the following line instead  
// [Attr(m_t = 10)]  
ref class A {};

编译器错误 C3104 Compiler Error C3104 11
非法特性自变量指定属性的无效自变量。请参阅特性参数类型有关详细信息。此错误可能来自于为年执行的编译器一致性工作：不再将从聚合初始化列表推导时将托管的数组传递给自定义特性，数组的类型。编译器现在需要你指定的数组初始值设定项列表的类型。示例下面的示例生成 C3104。 The following sample generates C3104. // C3104a.cpp  
// compile with: /clr /c  
using namespace System;  

[AttributeUsage(AttributeTargets::Class)]  
public ref struct ABC : public Attribute {  
   ABC(array<int>^){}  
   array<double> ^ param;  
};  

[ABC( {1,2,3}, param = {2.71, 3.14})]   // C3104  
// try the following line instead  
// [ABC( gcnew array<int> {1,2,3}, param = gcnew array<double>{2.71, 3.14})]   
ref struct AStruct{}; 示例 Example 下面的示例生成 C3104。 The following sample generates C3104. // C3104b.cpp  
// compile with: /clr /c  
// C3104 expected  
using namespace System;  

int func() {  
   return 0;   
}  

[attribute(All)]  
ref class A {  
public:   
   A(int) {}  
};  

// Delete the following 2 lines to resolve.  
[A(func())]  
ref class B {};  

// OK  
[A(0)]  
ref class B {};

编译器错误 C3106 Compiler Error C3106 11
：未命名自变量必须位于命名的参数之前未命名自变量必须传递给之前命名自变量的属性。有关详细信息，请参阅。示例下面的示例生成 C3106。 The following sample generates C3106. // C3106.cpp  
// compile with: /c  
[module(name="MyLib", dll)];   // C3106  
[module(dll, name="MyLib")];   // OK

编译器错误 C3110 Compiler Error C3110 11
：不能重载接口方法一个由接口属性，如前面的接口：自定义对象不能重载。例如

编译器错误 C3113 Compiler Error C3113 11
结构不能为模板泛型你尝试生成类模板或类泛型接口或枚举外。下面的示例生成 C3113: The following sample generates C3113: // C3113.cpp  
// compile with: /c  
template <class T>   
enum E {};   // C3113  
// try the following line instead  
// class MyClass{};

编译器错误 C3114 Compiler Error C3114 11
自变量：不是有效的命名特性自变量为了使属性类数据成员都是有效的命名自变量，它不能标记，，或。如果某个属性，该属性不能并且必须具有和访问器。有关详细信息，请参阅属性和用户定义的特性。示例下面的示例生成 C3114。 The following sample generates C3114. // C3114.cpp  
// compile with: /clr /c  
public ref class A : System::Attribute {  
public:  
   static property int StaticProp {  
      int get();  
   }  

   property int Prop2 {  
      int get();  
      void set(int i);  
   }  
};  

[A(StaticProp=123)]   // C3114  
public ref class R {};  

[A(Prop2=123)]   // OK  
public ref class S {};

编译器错误 C3115 Compiler Error C3115 11
构造上不允许此属性属性被应用到了意外的构造。请参阅按用法分的特性有关详细信息。示例下面的示例生成 C3115。 The following sample generates C3115. // C3115.cpp  
// compile with: /c  
#include <unknwn.h>  
[module(name="xx")];  

[object, helpstringdll(xx.dll), uuid("00000000-0000-0000-0000-000000000001")]   // C3115  
// try the following line instead  
// [object, uuid("00000000-0000-0000-0000-000000000001")]  
__interface IMyI {  
   HRESULT xx();  
};

编译器错误 C3116 Compiler Error C3116 11
存储：接口方法的无效的存储类你使用，，或为接口方法的存储类。在接口成员上不允许这些存储类。下面的示例生成 C3116: The following sample generates C3116: // C3116.cpp  
__interface ImyInterface  
{  
   static void myFunc();   // C3116  
};

编译器错误 C3117 Compiler Error C3117 11
：接口可只具有一个基类声明从多个基类继承的接口。下面的示例生成 C3117: The following sample generates C3117: // C3117.cpp  
#include <windows.h>  

[ object, uuid("00000000-0000-0000-0000-000000000001") ]  
__interface I1  
{  
};  

[ object, uuid("00000000-0000-0000-0000-000000000002") ]  
__interface I2  
{  
};  

[ object, uuid("00000000-0000-0000-0000-000000000003") ]  
__interface I3 : I1, I2  
{   // C3117  
};

编译器错误 C3118 Compiler Error C3118 11
：接口不支持虚拟继承你尝试以虚拟方式从接口继承。例如，应用于对象的生成此错误。

编译器错误 C3120 Compiler Error C3120 11
：接口方法不能接受变量自变量列表接口方法不能采用变量自变量列表。例如，下面的接口定义生成

编译器错误 C3121 Compiler Error C3121 11
无法更改的类的试图更改的类与。例如，下面的代码生成

编译器错误 C3126 Compiler Error C3126 11
不能定义联合内托管类型的联合不能在托管类型内定义联合。下面的示例生成 C3126: The following sample generates C3126: // C3126_2.cpp  
// compile with: /clr /c  
ref class Test  
{  
   union x  
   {   // C3126  
      int a;  
      int b;  
   };  
};

编译器错误 C3130 Compiler Error C3130 11
内部编译器错误：无法写入插入的代码块如果编译器无法插入的代码块写入文件，则会发生此错误。失败的最常见原因是缺乏磁盘空间。

编译器错误 C3131 Compiler Error C3131 11
项目必须具有属性模块属性模块属性必须具有名称参数。下面的示例生成 C3131: The following sample generates C3131: // C3131.cpp  
[emitidl];  
[module];   // C3131  
// try the following line instead  
// [module (name="MyLib")];  

[public]  
typedef long int LongInt;

编译器错误 C3132 Compiler Error C3132 11
函数参数：参数数组可以仅应用到类型一维托管数组的形参属性被应用到不是一个一维数组的参数。下面的示例生成 C3132: The following sample generates C3132: // C3132.cpp  
// compile with: /clr /c  
using namespace System;  
void f( [ParamArray] Int32[,] );   // C3132  
void g( [ParamArray] Int32[] );   // C3132  

void h( [ParamArray] array<Char ^> ^ MyArray );   // OK

编译器错误 C3133 Compiler Error C3133 11
无法将属性应用到未正确应用特性。属性不能应用于表示变量自变量的省略号。有关详细信息，请参阅。示例下面的示例生成 C3133。 The following sample generates C3133. // C3133.cpp  
// compile with: /clr /c  
ref struct MyAttr: System::Attribute {};   
void Func([MyAttr]...);   // C3133  
void Func2([MyAttr] int i);   // OK

编译器错误 C3134 Compiler Error C3134 11
：特性自变量属性不具有有效的类型的值当一个值分配到属性时检测到语法错误。请参阅按用法分的特性

编译器错误 C3135 Compiler Error C3135 11
属性不能具有或易失性键入和易失性属性上不允许关键字。

编译器错误 C3136 Compiler Error C3136 11
：只能从另一个接口继承的接口，接口不是一个接口应用到接口接口属性继承自不是一个接口的接口。接口最终继承自。前面的接口属性是任何接口是一个接口。下面的示例生成 C3136: The following example generates C3136: // C3136.cpp  
#include "unknwn.h"  

__interface A   // C3136  
// try the following line instead  
// _interface A : IUnknown  
{  
   int a();  
};  

[object]  
__interface B : A  
{  
   int aa();  
};

编译器错误 C3137 Compiler Error C3137 11
：无法初始化属性无法初始化某个属性，例如，在构造函数的初始化列表中。下面的示例生成 C3137: The following example generates C3137: // C3137.cpp  
// compile with: /clr /c  
ref class CMyClass {  
public:  
   property int Size {  
      int get() {  
         return 0;  
      }  
      void set( int i ) {}  
   }  

   CMyClass() : Size( 1 ) {   // C3137  
      // to resolve this C3137, remove the initializer from the  
      // ctor declaration and perform the assignment as follows  
      // Size = 1;  
   }  
};

编译器错误 C3138 Compiler Error C3138 11
接口必须继承从，或从继承的接口与接口双重或调度接口属性不具有为直接或间接基接口。下面的示例生成 C3138: The following example generates C3138: // C3138.cpp  
#include <unknwn.h>  

[ object, uuid("77ac9240-6e9a-11d2-97de-0000f805d73b") ]  
__interface IMyCustomInterface  
{  
   HRESULT mf1(void);  
};  

[ dispinterface, uuid("3536f8a0-6e9a-11d2-97de-0000f805d73b") ]  
__interface IMyDispInterface : IUnknown  
{  
   [id(1)] HRESULT mf2(void);  
};  

[ object, dual, uuid("34e90a10-6e9a-11d2-97de-0000f805d73b") ]  
__interface IMyDualInterface : IMyCustomInterface  // C3138 expected  
{  
   HRESULT mf3(void);  
};

编译器错误 C3139 Compiler Error C3139 11
：无法导出无成员尝试应用导出属性为空的（用户定义类型）。例如

编译器错误 C3140 Compiler Error C3140 11
不能在同一编译单元中有多个模块属性模块属性只能定义一次每个项目。下面的示例生成 C3140: The following sample generates C3140: // C3140.cpp  
// compile with: /c  
[emitidl];  
[module(name = "MyLibrary")];  
[module(name = "MyLibrary2")];   // C3140

编译器错误 C3141 Compiler Error C3141 11
：接口只支持公共继承使用定义的接口接口（或）关键字仅支持公共继承。下面的示例生成 C3141: The following sample generates C3141: // C3141.cpp  
__interface IBase {};  
__interface IDerived1 : protected IBase {};  // C3141  
__interface IDerived2 : private IBase {};    // C3141

编译器错误 C3142 Compiler Error C3142 11
：无法获取属性的地址属性的地址不供开发人员。下面的示例生成 C3142: The following sample generates C3142: // C3142_2.cpp  
// compile with: /clr  
using namespace System;  
ref class CSize {  
private:  
   property int Size {  
      int get();  
   }  
};  

int main() {  
    &CSize::Size; // C3142  
}

编译器错误 C3145 Compiler Error C3145 11
“”：全局或静态变量不可以具有托管或类型“”仅可在函数范围内定义或对象。下面的示例生成 C3145，并演示如何修复此错误： The following sample generates C3145 and shows how to fix it: // C3145.cpp  
// compile with: /clr  
using namespace System;   
ref class G {};   

G ^ ptr;   // C3145  
G ^ ptr2 = gcnew G;   // C3145  

ref class GlobalObjects {  
public:  
   static G ^ ptr;   // OK  
   static G ^ ptr2 = gcnew G;   // OK   
};   

int main() {  
   G ^ ptr;   // OK  
   G ^ ptr2 = gcnew G;   // OK  
} 下面的示例生成 C3145： The following sample generates C3145: // C3145b.cpp  
// compile with: /clr  
ref class MyClass {  
public:  
   static int data;  
};  

interior_ptr<int> p = &(MyClass::data);   // C3145  

void Test(interior_ptr<int> x) {}  

int main() {  
   MyClass ^ h_MyClass = gcnew MyClass;  
   interior_ptr<int> p = &(h_MyClass->data);  
}

编译器错误 C3149 Compiler Error C3149 11
：不能使用不顶级的情况下此类型声明未正确指定。例如，你可能具有定义在全局范围内的类型并尝试作为定义的一部分创建的变量的类型。因为不允许的类型的全局变量，编译器将生成。若要解决此错误，声明一个函数或类型定义中的类型的变量。下面的示例生成 C3149: The following sample generates C3149: // C3149.cpp  
// compile with: /clr  
using namespace System;  
int main() {  
   // declare an array of value types   
   array< Int32 ^> IntArray;   // C3149  
   array< Int32>^ IntArray2;   // OK  
} 下面的示例生成 C3149: The following sample generates C3149: // C3149b.cpp  
// compile with: /clr /c  
delegate int MyDelegate(const int, int);  
void Test1(MyDelegate m) {}   // C3149  
void Test2(MyDelegate ^ m) {}   // OK

编译器错误 C3150 Compiler Error C3150 11
只能应用到类、接口、数组或指针只能在类、接口或数组。才可访问使用过时的编译器选项。

编译器错误 C3152 Compiler Error C3152 11
“”“”只能应用于类、结构或虚拟成员函数某些关键字只能应用于类。下面的示例生成 C3152，并演示如何修复此错误： The following sample generates C3152 and shows how to fix it: // C3152.cpp  
// compile with: /clr /c  
ref class C {  
   int (*pfn)() sealed;   // C3152  
   virtual int g() sealed;   // OK  
};

编译器错误 C3153 Compiler Error C3153 11
：无法创建接口的实例接口不能实例化。若要使用接口的成员，从接口派生类，实现接口成员，然后使用这些成员。下面的示例生成 C3153: The following sample generates C3153: // C3153.cpp  
// compile with: /clr  
interface class A {  
};  

int main() {  
   A^ a = gcnew A;   // C3153  
}

编译器错误 C3154 Compiler Error C3154 11
预期，之前省略号。非逗号分隔的参数数组函数上不支持的省略号。未正确声明的变量自变量函数。有关详细信息，请参阅变量自变量列表（）示例下面的示例生成 C3154。 The following sample generates C3154. // C3154.cpp  
// compile with: /clr  
ref struct R {  
   void Func(int ... array<int> ^);   // C3154  
   void Func2(int i, ... array<int> ^){}   // OK  
   void Func3(array<int> ^){}   // OK  
   void Func4(... array<int> ^){}   // OK  
};  

int main() {  
   R ^ r = gcnew R;  
   r->Func4(1,2,3);  
}

编译器错误 C3155 Compiler Error C3155 11
属性索引器中不允许属性未正确声明索引的属性。有关详细信息，请参阅如何：使用属性在。示例下面的示例生成 C3155。 The following sample generates C3155. // C3155.cpp  
// compile with: /clr /c  
using namespace System;  
ref struct R {  
   property int F[[ParamArray] int] {   // C3155  
   // try the following line instead  
   // property int F[ int] {   // OK  
      int get(int i) {   
         return 0;   
      }  
   }  
};

编译器错误 C3156 Compiler Error C3156 11
“”：不能局部定义托管或类型函数不能包含托管或类、结构或接口的定义或声明。示例下面的示例生成 C3156。 The following sample generates C3156. // C3156.cpp  
// compile with: /clr /c  
void f() {  
   ref class X {};   // C3156  
   ref class Y;   // C3156  
}

编译器错误 C3157 Compiler Error C3157 11
属性只能应用到的最后一个参数属性被应用到了错误的参数。

编译器错误 C3159 Compiler Error C3159 11
指针：不能声明为指向值类型的指针的数组无法声明指向值类型的指针的数组。才可访问使用过时的编译器选项。

编译器错误 C3160 Compiler Error C3160 11
“”托管或类的数据成员不能具有此类型内部垃圾回收指针可能会指向托管或类的内部。因为它们比整个对象的指针慢，并且需要垃圾回收器进行特殊处理，因此你不能将内部托管的指针声明为类的成员。以下示例生成：

编译器错误 C3161 Compiler Error C3161 11
：嵌套类、结构、联合或接口中的接口是非法的嵌套接口类、结构或联合中的是非法只能出现在全局范围内或在某个命名空间。类、结构或联合不能出现在接口中。示例下面的示例生成 C3161。 The following sample generates C3161. // C3161.cpp  
// compile with: /c  
__interface X {  
   __interface Y {};   // C3161 A nested interface  
};

编译器错误 C3162 Compiler Error C3162 11
：具有析构函数的引用类型不能用作静态数据成员的类型公共语言运行时无法知道何时运行时类还包含静态成员函数的用户定义的析构函数。除非显式删除该对象，将决不会运行析构函数。有关详细信息，请参阅（公共语言运行时编译）位迁移的常见问题示例下面的示例生成 C3162。 The following sample generates C3162. // C3162.cpp  
// compile with: /clr /c  
ref struct A {  
   ~A() { System::Console::WriteLine("in destructor"); }  
   static A i;   // C3162  
   static A^ a = gcnew A;   // OK  
};  

int main() {  
   A ^ a = gcnew A;  
   delete a;  
}

编译器错误 C3163 Compiler Error C3163 11
：属性与以前的声明不一致应用于定义的属性应用于声明的属性与发生冲突。若要解决的一种方法是消除前向声明上的属性。前向声明的任何属性都应小于在定义的属性，或最多，等于到它们。错误的可能原因包括源代码注释语言。除非使用编译你的项目，否则宏不展开分析标志。如果你尝试重新编译使用，而无需完全编译分析的程序可能会引发分析选项。有关的详细信息，请参阅批注。示例下面的示例生成 C3163。 The following sample generates C3163. // C3163.cpp  
// compile with: /clr /c  
using namespace System;  

[CLSCompliant(true)] void f();  
[CLSCompliant(false)] void f() {}   // C3163  
// try the following line instead  
// [CLSCompliant(true)] void f() {} 请参阅 See Also SAL 批注 SAL Annotations

编译器错误 C3166 Compiler Error C3166 11
指针：不能将内部指针指向的指针声明为的成员编译器找到了无效的指针声明指向指针。。才可访问使用过时的编译器选项。

编译器错误 C3167 Compiler Error C3167 11
无法初始化：请确保已安装此计算机上未安装安装。

编译器错误 C3168 Compiler Error C3168 11
：非法枚举的基础类型基础类型为指定类型无效。基础类型必须为整型的类型或相应的类型。下面的示例生成 C3168: The following sample generates C3168: // C3168.cpp  
// compile with: /clr /c  
ref class G{};  

enum class E : G { e };   // C3168  
enum class F { f };   // OK

编译器错误 C3170 Compiler Error C3170 11
不能在项目中具有不同的模块标识符模块两个一次编译中的文件中发现了具有不同名称的特性。只有一个唯一属性可以指定每次编译。相同属性可以指定多个源代码文件中。例如，如果发现了以下 yiw特性：然后，成（请注意不同的名称）。

编译器错误 C3171 Compiler Error C3171 11
模块：无法在项目中指定不同的模块属性模块两个一次编译中的文件中发现了具有不同参数列表的特性。只有一个唯一属性可以指定每次编译。相同属性可以指定多个源代码文件中。例如，如果以下 yiw找属性：然后，成（请注意不同的版本值）。

编译器错误 C3172 Compiler Error C3172 11
模块名：不能在项目中指定不同特性属性具有相同名称但不同或中一次编译中的文件的两个找到的参数。只有一个唯一属性可以指定每次编译。相同属性可以指定多个源代码文件中。例如，如果以下 yiw找属性：然后，成（请注意不同的版本值）。

编译器错误 C3173 Compiler Error C3173 11
在合并的版本不匹配对象文件包含嵌入与以前的版本的编译器生成的时发生此错误。编译器将编码要确保用于生成的内容的文件中嵌入的同一编译器也用于合并嵌入的的同一编译器的版本号。更新你的安装，以便所有工具都均来自最新的发行版本。

编译器错误 C3174 Compiler Error C3174 11
未指定模块特性使用特性的程序未还使用模块属性，它在任何程序，使用属性必需。下面的示例生成 C3174: The following sample generates C3174: // C3174.cpp  
// C3174 expected  
// uncomment the following line to resolve this C3174  
// [module(name="x")];  
[export]  
struct S  
{  
   int i;  
};  

int main()  
{  
}

编译器错误 C3175 Compiler Error C3175 11
：不能将托管类型的方法调用从非托管函数非托管的函数不能调用托管类成员的函数。下面的示例生成 C3175: The following sample generates C3175: // C3175_2.cpp  
// compile with: /clr  

ref struct A {  
   static void func() {  
   }  
};  

#pragma unmanaged   // remove this line to resolve  

void func2() {  
   A::func();   // C3175  
}  

#pragma managed  

int main() {  
   A ^a = gcnew A;  
   func2();  
}

编译器错误 C3176 Compiler Error C3176 11
：不能声明本地值类型只能为值类型在全局范围内声明一个类。示例下面的示例生成 C3176。 The following sample generates C3176. // C3176.cpp  
// compile with: /clr  
int main () {  
   enum class C {};   // C3176  
}

编译器错误 C3179 Compiler Error C3179 11
不允许未命名的托管类型或类型所有与类和结构都必须具有名称。下面的示例生成 C3179，并演示如何修复此错误： The following sample generates C3179 and shows how to fix it: // C3179a.cpp  
// compile with: /clr /c  
typedef value struct { // C3179  
// try the following line instead  
// typedef value struct MyStruct {  
   int i;  
} V;

编译器错误 C3180 Compiler Error C3180 11
：名称超过了限制个字符的元数据限制编译器截断元数据中的托管类型的名称。截断将使该类型与不可用指令（或在另一种语言的等效项）。类型名称限制包括任何命名空间限定。

编译器错误 C3181 Compiler Error C3181 11
：无效的操作数用于运算符无效的参数传递到运算符。参数必须是托管的类型。请注意，编译器使用的本机类型的映射到公共语言运行时中类型的别名。下面的示例生成 C3181: The following sample generates C3181: // C3181a.cpp  
// compile with: /clr  
using namespace System;  

int main() {  
   Type ^pType1 = interior_ptr<int>::typeid;   // C3181  
   Type ^pType2 = int::typeid;   // OK  
}

编译器错误了 C3182 Compiler Error C3182 11
：成员声明或访问声明是在托管或非法使用声明无效的托管类的所有窗体中。下例生成了，并演示了如何对其进行修复。

编译器错误 C3183 Compiler Error C3183 11
不能在托管的或类型“”的内部定义未命名的类、结构或联合必须命名嵌入托管的或类型中的类型。下列示例生成：

编译器错误 C3185 Compiler Error C3185 11
在托管或类型“”上使用了“”，请改用“”不能将应用运算符为托管或类型请改用相反。下面的示例生成 C3185，并演示如何修复此错误： The following sample generates C3185 and shows how to fix it: // C3185a.cpp  
// compile with: /clr  
ref class Base {};  
ref class Derived : public Base {};  

int main() {  
   Derived ^ pd = gcnew Derived;  
   Base ^pb = pd;  
   const type_info & t1 = typeid(pb);   // C3185  
   System::Type ^ MyType = Base::typeid;   // OK  
};

编译器错误 C3187 Compiler Error C3187 11
：才函数体内可用预定义的宏在函数体外不可用。若要更正此错误，请将宏移到函数体内。

编译器错误 C3189 Compiler Error C3189 11
键入抽象声明符：不再支持此语法，请使用改为过时形式已使用，使用新的窗体。下面的示例生成 C3189: The following sample generates C3189: // C3189.cpp  
// compile with: /clr  
int main() {  
   System::Type^ t  = typeid<System::Object>;   // C3189  
   System::Type^ t2  = System::Object::typeid;   // OK  
}

编译器错误 C3190 Compiler Error C3190 11
实例，并且它提供的模板自变量不是的任何成员函数的显式实例化编译器检测到尝试进行显式函数实例化但是，提供的类型自变量不匹配任何可能的函数。下面的示例生成 C3190: The following sample generates C3190: // C3190.cpp  
// compile with: /LD  
template<class T>  
struct A {  
   A(int x = 0) {  
   }  
   A(int x, int y) {  
   }  
};  

template A<float>::A();   // C3190  
// try the following line instead  
// template A<int>::A(int);  

struct Y {  
   template<class T> void f(T);  
};  

template<class T> void Y::f(T) { }  

template void Y::f(int,int);   // C3190  

template<class OT> class X {  
   template<class T> void f2(T,OT);  
};  

template<class OT> template<class T> void X<OT>::f2(T,OT) {}  

template void X<float>::f2<int>(int,char);   // C3190  
// try one of the following lines instead  
// template void X<char>::f2(int, char);  
// template void X<char>::f2<int>(int,char);  
// template void X<char>::f2<>(int,char);

编译器错误 C3192 Compiler Error C3192 11
语法错误不是一个前缀运算符您的意思？句柄不能用作取消引用运算符。下面的示例生成 C3192: The following sample generates C3192: // C3192.cpp  
// compile with: /clr  
using namespace System;  

ref class MyClass {  
public:  
   MyClass () {}  
   MyClass(MyClass%) {}  
};  

int main() {  
   MyClass ^ s = gcnew MyClass;   
   MyClass b = ^s;   // C3192  

   // OK  
   MyClass b2 = *s;  
}

编译器错误 C3194 Compiler Error C3194 11
：值类型不能具有赋值运算符值类中不支持由编译器，如复制构造函数或复制赋值运算符需要自动调用的特殊成员函数。示例下面的示例生成 C3194。 The following sample generates C3194. // C3194.cpp  
// compile with: /clr /c  
value struct MyStruct {  
   MyStruct& operator= (const MyStruct& i) { return *this; }   // C3194  
};  

ref struct MyStruct2 {  
   MyStruct2% operator= (const MyStruct2% i) { return *this; }   // OK  
};

编译器错误 C3195 Compiler Error C3195 11
“”被保留并且不能用作类或值类型的成员。必须使用“”关键字定义或运算符编译器检测到了使用托管扩展语法的运算符定义。为运算符，必须使用语法。下面的示例生成 C3195，并演示如何修复此错误： The following sample generates C3195 and shows how to fix it: // C3195.cpp  
// compile with: /clr /LD  
#using <mscorlib.dll>  
value struct V {  
   static V op_Addition(V v, int i);   // C3195  
   static V operator +(V v, char c);   // OK for new C++ syntax   
};

编译器错误 C3196 Compiler Error C3196 11
：使用多个一次不止一次使用的关键字。下面的示例生成 C3196: The following sample generates C3196: // C3196.cpp  
// compile with: /clr  
ref struct R abstract abstract {};   // C3196  
ref struct S abstract {};   // OK

编译器错误 C3197 Compiler Error C3197 11
：仅可用于定义关键字用于声明中，但仅为定义中有效。下面的示例生成 C3197: The following sample generates C3197: // C3197.cpp  
// compile with: /clr /c  
ref struct R abstract;   // C3197  
ref struct R abstract {};   // OK  

public ref class MyObject;   // C3197  
ref class MyObject;   // OK  
public ref class MyObject {};   // OK

编译器错误 C3198 Compiler Error C3198 11
使用无效的浮点杂注：杂注仅在精确的模式下运行杂注已在使用以外的设置：精确。下面的示例生成 C3198: The following sample generates C3198: // C3198.cpp  
// compile with: /fp:fast  
#pragma fenv_access(on)   // C3198

编译器错误 C3199 Compiler Error C3199 11
使用无效的浮点杂注：非精确模式中不支持异常杂注用于指定浮点异常模型下的以外的设置：精确。下面的示例生成 C3199: The following sample generates C3199: // C3199.cpp  
// compile with: /fp:fast  
#pragma float_control(except, on)   // C3199

编译器错误 C3200 Compiler Error C3200 11
模板：模板参数的无效的模板自变量应为类模板到类模板传递了无效自变量。类模板作为参数需要模板。在下面的示例中，调用将生成。第一个参数应是一个模板，如。

编译器错误 C3201 Compiler Error C3201 11
类模板“”的模板参数列表与模板参数“”的模板参数列表不匹配将自变量中的类模板传递给了不使用模板参数的类模板，或为默认模板自变量传递了数量不匹配的模板自变量。

编译器错误 C3202 Compiler Error C3202 11
“”：模板参数“”的默认参数无效，应为类模板你向模板参数传递的默认参数无效。下面的示例生成 C3202： The following sample generates C3202: // C3202.cpp  
template<typename T>  
class X  
{  
};  

class Z  
{  
};  

template<template<typename U> class T1 = Z, typename T2> // C3202  
class Y  
{  
};

编译器错误 C3203 Compiler Error C3203 11
“类型”：未专用化的类模板或泛型不能用作模板或模板的泛型自变量或泛型参数“”，应为类型你传递了一个无效的自变量到类模板或泛型。类模板或泛型需要一种类型作为参数。为执行的编译器一致性工作可以导致此错误：专用的类模板不能用作基类列表中的模板参数。若要解决，则当将模板类型参数用作基类列表中的模板参数时，将其显式添加到模板类名称。以下示例将生成，并演示如何修复此错误：当使用泛型时，也可能发生：

编译器错误 C3204 Compiler Error C3204 11
不能从块内调用从块内使用对的调用时发生此错误。示例下面的示例生成 C3204： The following sample generates C3204: // C3204.cpp  
// compile with: /EHsc  
#include <malloc.h>  

void ShowError(void)  
{  
   try  
   {  
   }  
   catch(...)  
   {  
      _alloca(1);   // C3204  
   }  
}

编译器错误 C3205 Compiler Error C3205 11
缺少模板形参“”的实参列表缺少模板参数。示例下面的示例生成 C3205： The following sample generates C3205: // C3205.cpp  
template<template<class> class T> struct A {  
   typedef T unparameterized_type;   // C3205  
   // try the following line instead  
   // typedef T<int> unparameterized_type;  
};  

template <class T>  
struct B {  
   typedef int value_type;  
};  

int main() {  
   A<B> x;  
}

编译器错误 C3206 Compiler Error C3206 11
“”：“”的类型参数无效，缺少对类类型“”上的类型参数列表将模板函数定义为采用模板类型参数。但是，模板模板参数被传递。以下示例生成：可能的解决方法：使用泛型时，也可能发生：可能的解决方法：不允许类模板作为模板类型参数。下面的示例引发可能的解决方法：如果模板模板参数是必需的然后必须采用模板模板参数的模板类中包装该函数：

编译器错误 C3207 Compiler Error C3207 11
“”：“”的模板参数无效，应当是类模板将模板函数定义为采用模板模板参数。但是，传递的是模板类型参数。以下示例生成：

编译器错误 C3208 Compiler Error C3208 11
“”类模板“”的模板参数列表与模板参数“”的模板参数列表不匹配模板参数的模板参数数量与提供的类模板不同。下面的示例生成 C3208： The following sample generates C3208: // C3208.cpp  
template <template <class T> class TT >  
int f();  

template <class T1, class T2>  
struct S;  

template <class T1>  
struct R;  

int i = f<S>();   // C3208  
// try the following line instead  
// int i = f<R>();

编译器错误 C3209 Compiler Error C3209 11
：泛型类必须是托管或泛型类必须是托管类或运行时类。下面的示例生成 C3209，并演示如何修复此错误： The following sample generates C3209 and shows how to fix it: // C3209.cpp  
// compile with: /clr  
generic <class T>  
class C {};   // C3209  

// OK - ref class can be generic  
generic <class T>  
ref class D {};

编译器错误 C3210 Compiler Error C3210 11
：访问声明只能应用到基类成员声明未正确指定。示例下面的示例生成 C3210。 The following sample generates C3210. // C3210.cpp  
// compile with: /c  
struct A {  
protected:  
   int i;  
};  

struct B {  
   using A::i;   // C3210  
};  

struct C : public A {  
   using A::i;   // OK  
};

编译器错误 C3211 Compiler Error C3211 11
“显式专用化”显式专用化正在使用部分专用化语法，请改用模板显式专用化的格式不正确。以下示例生成：

编译器错误 C3212 Compiler Error C3212 11
“”：模板成员的显式专用化必须是显示专用化的成员显式专用化的格式不正确。以下示例生成：

编译器错误 C3213 Compiler Error C3213 11
基类“”的可访问性比“”低程序集中可见的类型必须使用公开可见的基类。以下示例生成：

编译器错误 C3214 Compiler Error C3214 11
“”：泛型“”的泛型形参“”的类型实参无效，不符合“”约束对不符合泛型类的约束的泛型类的实例化指定该类型。以下示例生成：

编译器错误 C3215 Compiler Error C3215 11
“”泛型类型参数已由“”进行约束已多次指定约束。有关泛型的详细信息，请参阅。下面的示例生成 C3215： The following sample generates C3215: // C3215.cpp  
// compile with: /clr  
interface struct A {};  

generic <class T>  
where T : A,A  
ref class C {};   // C3215 可能的解决方法： Possible resolution: // C3215b.cpp  
// compile with: /clr /c  
interface struct A {};  

generic <class T>  
where T : A  
ref class C {};

编译器错误 C3216 Compiler Error C3216 11
约束必须是泛型参数，而不是“”约束格式不正确。下面的示例生成 C3216： The following sample generates C3216: // C3216.cpp  
// compile with: /clr  
interface struct A {};  

generic <class T>  
where F : A   // C3216  
// Try the following line instead:  
// where T : A    // C3216  
ref class C {}; 下面的代码示例演示了可能的解决方法： The following example demonstrates a possible resolution: // C3216b.cpp  
// compile with: /clr /c  
interface struct A {};  

generic <class T>  
where T : A  
ref class C {};

编译器错误 C3217 Compiler Error C3217 11
“”泛型参数不能在此声明中进行约束约束的格式错误；约束泛型参数必须与泛型类模板参数一致。下面的示例生成 C3217： The following sample generates C3217: // C3217.cpp  
// compile with: /clr  
interface struct A {};  

generic <class T>  
ref class C {  
   generic <class T1>  
   where T : A   // C3217  
   void f();  
}; 以下示例演示了可能的解决方法： The following sample demonstrates a possible resolution: // C3217b.cpp  
// compile with: /clr /c  
interface struct A {};  

generic <class T>  
ref class C {  
   generic <class T1>  
   where T1 : A  
   void f();  
};

编译器错误 C3218 Compiler Error C3218 11
：不允许作为约束的类型为要约束的类型，它必须是值类型或托管的类或接口的引用。示例下面的示例生成 C3218。 The following sample generates C3218. // C3218.cpp  
// compile with: /clr /c  
class A {};  
ref class B {};  

// Delete the following 3 lines to resolve.  
generic <class T>  
where T : A   // C3218  
ref class C {};  

// OK  
generic <class T>  
where  T : B  
ref class D {};

编译器错误 C3219 Compiler Error C3219 11
“”泛型参数不能由多个非接口“”进行约束由两个或更多托管类约束泛型参数是无效的。下面的示例生成 C3219： The following sample generates C3219: // C3219.cpp  
// compile with: /clr  
ref class A {};  
ref class B {};  

generic <class T>  
where T : A, B  
ref class E {};   // C3219 以下示例演示了可能的解决方法： The following sample demonstrates a possible resolution: // C3219b.cpp  
// compile with: /clr /c  
ref class A {};  

interface struct C {};  

generic <class T>  
where T : A  
ref class E {};

编译器错误 C3222 Compiler Error C3222 11
“”无法为托管或类型或泛型函数的成员函数声明默认自变量不允许声明具有默认自变量的方法参数。方法的重载形式是一种用于解决此问题的方式。也就是说，定义具有相同名称但不带参数的方法，然后在方法体中初始化变量。以下示例生成：

编译器错误 C3223 Compiler Error C3223 11
“”：不能将“”应用于属性不能将应用于属性。示例以下示例生成。

编译器错误 C3224 Compiler Error C3224 11
“”：没有任何重载泛型类采用“”泛型类型参数编译器找不到适当的重载。下面的示例生成 C3224： The following sample generates C3224: // C3224.cs  
// compile with: /target:library  
public class C<T> {}  
public class C<T,U> {} 然后， And then, // C3224b.cpp  
// compile with: /clr  
#using "C3224.dll"  
int main() {  
   C<int,int,int>^ c = gcnew C<int,int,int>();   // C3224  
   C<int,int>^ c2 = gcnew C<int,int>();   // OK  
}

编译器错误 C3225 Compiler Error C3225 11
的泛型类型参数不能是，它必须是值类型或句柄类型泛型类型参数不是类型的正确。有关详细信息，请参阅泛型。示例无法实例化具有本机类型的泛型类型。下面的示例生成 C3225。 The following sample generates C3225. // C3225.cpp  
// compile with: /clr  
class A {};  

ref class B {};  

generic <class T>  
ref class C {};  

int main() {  
   C<A>^ c = gcnew C<A>;   // C3225  
   C<B^>^ c2 = gcnew C<B^>;   // OK  
} 示例 Example 下面的示例创建一个使用 C# 的组件。 The following sample creates a component using C#. 请注意，该约束指定泛型类型仅使用值类型进行实例化。 Notice that the constraint specifies that the generic type can only be instantiated with a value type. // C3225_b.cs  
// compile with: /target:library  
// a C# program  
public class MyList<T> where T: struct {} 示例 Example 此示例使用 C# 的创作组件，并且违反 MyList 只能约束而不使用值类型实例化 Nullable 。 This sample consumes the C#-authored component, and violates the constraint that MyList can only be instantiated with a value type other than Nullable . 下面的示例生成 C3225。 The following sample generates C3225. // C3225_c.cpp  
// compile with: /clr  
#using "C3225_b.dll"  
ref class A {};  
value class B {};  
int main() {  
   MyList<A> x;   // C3225  
   MyList<B> y;   // OK  
}

编译器错误 C3226 Compiler Error C3226 11
泛型声明内不允许出现模板声明在泛型类中使用泛型声明。以下示例生成：以下示例演示了可能的解决方法：

编译器错误 C3227 Compiler Error C3227 11
：不能使用分配的泛型类型若要实例化一个类型，相应的构造函数是必需的。但是，编译器不能以确保适当的构造函数可用。可以使用模板而不是泛型若要解决此错误，或者可以使用几种方法之一来创建类型的实例。示例下面的示例生成 C3227。 The following sample generates C3227. // C3227.cpp  
// compile with: /clr /c  
generic<class T> interface class ICreate {  
   static T Create();  
};  

generic <class T>  
where T : ICreate<T>  
ref class C {  
   void f() {  
      T t = new T;   // C3227  

      // OK  
      T t2 = ICreate<T>::Create();  
      T t3 = safe_cast<T>( System::Activator::CreateInstance(T::typeid) );  
   }  
};

编译器错误 C3228 Compiler Error C3228 11
“”：“”的泛型类型实参不能是“”，它必须是值类型或句柄类型作为泛型类型实参传递了不正确的类型。下面的示例生成 C3228： The following sample generates C3228: // C3228.cpp  
// compile with: /clr  
class A {};  

value class B {};  

generic <class T>  
void Test() {}  

ref class C {  
public:  
   generic <class T>  
   static void f() {}  
};  

int main() {  
   C::f<A>();   // C3228  
   C::f<B>();   // OK  

   Test<C>();   // C3228  
   Test<C ^>();   // OK  
}

编译器错误 C3229 Compiler Error C3229 11
“”：不允许泛型类型参数上的间接寻址泛型参数不能和、或一起使用。示例以下示例生成。示例以下示例生成。

编译器错误 C3230 Compiler Error C3230 11
“”：“”的模板类型参数不能包含泛型类型参数：“”模板在编译时实例化，而泛型在运行时实例化。因此，不能生成可调用模板的泛型代码，因为当泛型类型在最后才已知时，模板不能在运行时实例化。以下示例生成：

编译器错误 C3231 Compiler Error C3231 11
：模板类型参数不能使用泛型类型参数模板在编译时实例化，而泛型在运行时实例化。因此，不能生成可调用模板的泛型代码，因为当泛型类型在最后才已知时，模板不能在运行时实例化。下面的示例生成 C3231: The following sample generates C3231: // C3231.cpp  
// compile with: /clr /LD  
template <class T> class A;  

generic <class T>  
ref class C {  
   void f() {  
      A<T> a;   // C3231  
   }  
};

编译器错误 C3232 Compiler Error C3232 11
“”：泛型类型参数不能用于限定名中未正确使用泛型类型参数。以下示例生成：

编译器错误 C3233 Compiler Error C3233 11
“”：泛型类型形参已被约束在多个子句中约束一个泛型参数是无效的。下面的示例生成 C3233： The following sample generates C3233: // C3233.cpp  
// compile with: /clr /LD  

interface struct C {};  
interface struct D {};  

generic <class T>  
where T : C  
where T : D  
ref class E {};   // C3233

编译器错误 C3234 Compiler Error C3234 11
泛型类可能无法从泛型类型参数派生泛型类不能继承自泛型类型参数。示例以下示例生成。

编译器错误 C3235 Compiler Error C3235 11
“专用化”不允许显式专用化或部分专用化泛型类泛型类不能用于显式专用化或部分专用化。示例以下示例生成。

编译器错误 C3236 Compiler Error C3236 11
不允许显式实例化泛型编译器不允许泛型类的显式实例化。下面的示例生成 C3236： The following sample generates C3236: // C3236.cpp  
// compile with: /clr  
generic<class T>  
public ref class X {};  

generic ref class X<int>;   // C3236 以下示例演示了可能的解决方法： The following sample demonstrates a possible resolution: // C3236b.cpp  
// compile with: /clr /c  
generic<class T>  
public ref class X {};

编译器错误 C3237 Compiler Error C3237 11
“”泛型类不能是自定义特性泛型类不能是用户定义的特性。示例以下示例生成。

编译器错误 C3238 Compiler Error C3238 11
“”：已将某个同名类型转发到程序集“”通过在引用的程序集中类型转发语法，已在客户端应用程序中定义的类型也被定义了。两种类型均不能在应用程序的范围内定义。请参阅类型转发有关详细信息。示例下面的示例创建了一个包含从另一个程序集已转发的类型的程序集。示例下面的示例创建用来包含该类型定义的程序集，但不仅仅包含类型转发语法。示例以下示例生成。

编译器错误 C3239 Compiler Error C3239 11
“”：公共语言运行时不允许使用指向内部指针的指针编译器遇到了无效的类型。下面的示例生成 C3229： The following sample generates C3229: // C3239.cpp  
// compile with: /clr  
int main() {  
   interior_ptr<int>* pip0;   // C3239  

   // OK  
   int * pip1;  
   interior_ptr<int> pip2;  
   int ** pip;  
}

编译器错误 C3240 Compiler Error C3240 11
：必须是的非重载抽象成员函数基类型包含已定义的函数。函数必须是虚拟的。示例下面的示例生成 C3240。 The following sample generates C3240. // C3240.cpp  
// compile with: /c  
__interface I {  
   void f();  
};  

struct A1 : I {   
   void f() {}  
};  

struct A2 : I {   
   void f() = 0;  
};  

template <class T>   
struct A3 : T {  
   void T::f() {}  
};  

template <class T>   
struct A4 : T {  
   void T::f() {}  
};  

A3<A1> x;   // C3240  
A3<I> x2;  
A4<A2> x3;

编译器错误 C3241 Compiler Error C3241 11
：引入了此方法不由显式重写函数，函数签名必须与要重写的函数的声明完全匹配。下面的示例生成 C3241: The following sample generates C3241: // C3241.cpp  
#pragma warning(disable:4199)  

__interface IX12A {  
   void mf();  
};  

__interface IX12B {  
   void mf(int);  
};  

class CX12 : public IX12A, public IX12B { // C3241  
   void IX12A::mf(int);  
};

编译器错误 C3242 Compiler Error C3242 11
“函数”只能显式重写虚函数尝试显式重写非虚拟方法。

编译器错误 C3243 Compiler Error C3243 11
“”未引入任何重载函数你试图显式重写在指定接口中不存在的成员。下面的示例生成 C3243： The following sample generates C3243: // C3243.cpp  
#pragma warning(disable:4199)  
__interface IX14A {  
   void g();  
};  

__interface IX14B {  
   void f();  
   void f(int);  
};  

class CX14 : public IX14A, public IX14B {  
public:  
   void IX14A::g();  
   void IX14B::f();  
   void IX14B::f(int);  
};  

void CX14::IX14A::f()   // C3243 occurs here  
{  
}

编译器错误 C3244 Compiler Error C3244 11
“”：此方法由“”引入，而非属于“”试图显式重写不存在于指定接口但存在于另一个基类中的成员。下面的示例生成 C3244： The following sample generates C3244: // C3244.cpp  
#pragma warning(disable:4199)  

__interface IX15A {  
   void f();  
};  

__interface IX15B {  
   void g();  
};  

class CX15 : public IX15A, public IX15B {  
public:        
   void IX15A::f();  
   void IX15B::g();  
};  

void CX15::IX15A::g()   // C3244 occurs here  
{  
}

编译器错误 C3246 Compiler Error C3246 11
“”无法从“”继承，因为它已声明为“”标记为的类不能为任何其他类的基类。以下示例生成：

编译器错误 C3247 Compiler Error C3247 11
“”：组件类不能继承自另一个组件类“”特性标记的类不能继承自特性标记的另一个类。以下示例生成：

编译器错误 C3248 Compiler Error C3248 11
“”声明为的函数无法被“”重写派生的类试图重写虚方法。才可访问使用过时的编译器选项。

编译器错误 C3251 Compiler Error C3251 11
无法调用在数值类型实例上的基类方法由于是而不是的成员，所以将发生以下错误。

编译器错误 C3252 Compiler Error C3252 11
“”：不能降低托管或类型中虚方法的可访问性实现来自基类的虚方法或来自接口的任意方法的类不能减少该方法的访问。请注意，接口中的所有方法都是公共的。下列示例生成，并演示如何修复此错误：

编译器错误 C3253 Compiler Error C3253 11
：显式重写时出错显式重写未正确指定。例如，不能指定的替代，你还指定为纯的实现。有关详细信息，请参阅显式重写。下面的示例生成 C3253: The following sample generates C3253: // C3253.cpp  
// compile with: /clr  
public interface struct I {  
   void a();  
   void b();  
   void c();  
};  

public ref struct R : I {  
   virtual void a() = 0, I::a {}   // C3253  
   virtual void b() = I::a {}   // OK  
   virtual void c() = 0;   // OK  
};

编译器错误 C3254 Compiler Error C3254 11
显式重写：类包含显式重写替代，但不是派生接口包含函数声明当你显式重写方法，包含该重写的类必须直接或间接派生，从包含该函数的类型重写。下面的示例生成 C3254: The following sample generates C3254: // C3254.cpp  
__interface I  
{  
   void f();  
};  

__interface I1 : I  
{  
};  

struct A /* : I1 */  
{  
   void I1::f()  
   {   // C3254, uncomment : I1 to resolve this C3254  
   }  
};  

int main()  
{  
}

编译器错误 C3255 Compiler Error C3255 11
值类型：无法动态分配本机堆上的此值类型对象值类型的实例请参阅类和结构包含托管的成员可以创建在堆栈上但不是在堆上。下面的示例生成 C3255: The following sample generates C3255: // C3255.cpp  
// compile with: /clr  
using namespace System;  
value struct V {  
   Object^ o;  
};  

value struct V2 {  
   int i;  
};  

int main() {  
   V* pv = new V;   // C3255  
   V2* pv2 = new V2;  
   V v2;  
}

编译器错误 C3262 Compiler Error C3262 11
无效的数组索引：为“”维“”指定了“”维度数组的下标不正确。索引数与数组中的维数可能不匹配。下面的示例生成 C3262： The following sample generates C3262: // C3262.cpp  
// compile with: /clr  
#using <mscorlib.dll>  
using namespace System;  

#define ARRAY_SIZE 2  

ref class MyClass {  
public:  
   int m_i;  
};  

// returns a multidimensional managed array of a reference type  
array<MyClass^, 2>^ Test0() {  
   int i, j;  
   array< MyClass^, 2 >^ local = new array< MyClass^, 2 >  
      (ARRAY_SIZE, ARRAY_SIZE);  

   for (i = 0 ; i < ARRAY_SIZE ; i++)  
      for (j = 0 ; j < ARRAY_SIZE ; j++) {  
         local[i][j] = new MyClass;   // C3262  
         // try the following line instead  
         // local[i,j] = new MyClass;     
         local[i,j] -> m_i = i;  
      }  

      return local;  
}  

int main() {     
   int i, j;  

   array< MyClass^, 2 >^ MyClass0;  
   MyClass0 = Test0();  
}

编译器错误 C3264 Compiler Error C3264 11
“”构造函数不能有返回类型构造函数不能有返回类型。下面的示例生成 C3264： The following sample generates C3264: // C3264_2.cpp  
// compile with: /clr  

ref class X {  
   public:  
      static int X()   { // C3264  
      }  

      /* use the code below to resolve the error  
      static X() {  
      }  
      */  
};  
int main() {  
}

编译器错误 C3265 Compiler Error C3265 11
不能声明托管托管中构造非托管的非托管构造在非托管上下文中，不能包含托管的对象。下面的示例重新产生

编译器错误 C3266 Compiler Error C3266 11
“”：类构造函数必须具有“”参数列表使用编程的类中的类构造函数不能接受参数。下面的示例生成 C3266： The following sample generates C3266: // C3266.cpp  
// compile with: /clr  

ref class X {  
   static X(int i) { // C3266  
   // try the following line instead  
   // static X() {  
   }  
};  

int main() {  
}

编译器错误 C3268 Compiler Error C3268 11
“”：泛型函数或泛型类的成员函数不能包含变量参数列表和编译器选项在中已弃用。请参阅泛型有关详细信息。示例以下示例生成。

编译器错误 C3269 Compiler Error C3269 11
：托管或的成员函数不能使用声明托管和类成员函数不能声明可变长度的参数列表。下面的示例将生成，并演示如何修复此错误：

编译器错误 C3270 Compiler Error C3270 11
“”特性只能在上下文中使用，在该情况下它是必需的使用标记了一个字段，这仅允许时生效。下面的示例生成 C3270： The following sample generates C3270: // C3270_2.cpp  
// compile with: /clr /c  
using namespace System::Runtime::InteropServices;  

[ StructLayout(LayoutKind::Sequential) ]  
// try the following line instead  
// [ StructLayout(LayoutKind::Explicit) ]  
public value struct MYUNION  
{  
   [FieldOffset(0)] int a;   // C3270  
   // ...  
};

编译器错误 C3271 Compiler Error C3271 11
“”：特性的值“”无效将一个负数传递到了“”特性。以下示例生成：

编译器错误 C3272 Compiler Error C3272 11
“”：符号需要，因为它是用定义的类型的成员当有效时，必须用来标记字段。下面的示例生成 C3272： The following sample generates C3272: // C3272_2.cpp  
// compile with: /clr /c  
using namespace System;  
using namespace System::Runtime::InteropServices;  

[StructLayout(LayoutKind::Explicit)]  
ref struct X  
{  
   int data_;   // C3272  
   // try the following line instead  
   // [FieldOffset(0)] int data_;  
};

编译器错误 C3273 Compiler Error C3273 11
不能用于非托管代码中的异常块。下面的示例生成 C3273： The following sample generates C3273: // C3273.cpp  
// compile with: /GX  
int main()  
{     
   try  
   {  
   }  
   catch (int)  
   {  
   }  
   __finally   // C3273, remove __finally clause  
   {  
   }  
}

编译器错误 C3274 Compiler Error C3274 11
没有匹配的发现或语句没有匹配的。若要解决此问题，删除语句或为添加语句。以下示例生成：

编译器错误 C3275 Compiler Error C3275 11
“”：无法使用该无限定符的符号使用托管代码以及两个或多个枚举包含具有相同名称的标识符时，必须显式限定对标识符的引用。才可访问使用过时的编译器选项。

编译器错误 C3276 Compiler Error C3276 11
块中的跳转出现不可确定的行为在终止处理过程此错误是相同警告。但是，当使用时，此条件不能禁用与警告杂注。

编译器错误 C3277 Compiler Error C3277 11
不能定义托管的内的非托管的枚举枚举在托管类型内定义不正确。下面的示例生成 C3277: The following sample generates C3277: // C3277a.cpp  
// compile with: /clr  
ref class A  
{  
   enum E {e1,e2};   // C3277  
   // try the following line instead  
   // enum class E {e1,e2};  
};  

int main()  
{  
}

编译器错误 C3278 Compiler Error C3278 11
接口或纯方法“”的直接调用将在运行时失败对接口方法或纯方法进行了调用，这是不允许的。以下示例生成：

编译器错误 C3279 Compiler Error C3279 11
不允许对在命名空间中声明的类模板进行部分专用化、显式专用化和显式实例化命名空间由定义并包含伪模板。编译器不允许对此命名空间中的类模板进行用户定义专用化、部分专用化、显式专用化和显式实例化。以下示例生成：

编译器错误 C3280 Compiler Error C3280 11
“”无法将托管类型的成员函数编译成非托管函数托管的类成员函数不能编译为非托管函数。以下示例生成：

编译器错误 C3282 Compiler Error C3282 11
泛型参数列表只能出现在管理或、结构或函数未正确使用泛型参数列表。有关详细信息，请参阅泛型。示例下例生成了，并演示了如何对其进行修复。

编译器错误 C3283 Compiler Error C3283 11
“类型”接口不能包含实例构造函数接口不能包含实例构造函数。允许使用静态构造函数。以下示例生成可能的解决方法：

编译器错误 C3284 Compiler Error C3284 11
函数“”的泛型参数“”的约束必须与函数“”的泛型参数“”的约束匹配虚拟泛型函数所用的约束必须与基类中具有相同名称和参数集的虚拟函数的约束相同。以下示例生成：

编译器错误 C3285 Compiler Error C3285 11
语句不能对“类型”类型的变量进行操作语句针对数组或集合中每个元素重复执行一组嵌入语句。有关更多信息，请参见。示例以下示例生成

编译器错误 C3286 Compiler Error C3286 11
说明符：迭代变量不能包含任何存储类说明符存储类不能对指定迭代变量。有关详细信息，请参阅存储类（）和对于每一个，在。示例下面的示例生成 C3286，并还显示正确的使用情况。 The following sample generates C3286, and also shows correct usage. // C3286.cpp  
// compile with: /clr  
int main() {  
   array<int> ^p = { 1, 2, 3 };  
   for each (static int i in p) {}   // C3286   
   for each (int j in p) {}   // OK  
}

编译器错误 C3287 Compiler Error C3287 11
类型“”（的返回类型）必须具有适当的公共成员函数和公共的属性用户定义的集合类必须包含对和的定义。有关更多信息，请参见。示例以下示例生成。

编译器错误 C3288 Compiler Error C3288 11
：非法的取消引用的句柄类型编译器检测到句柄类型非法取消引用。你可以取消引用句柄类型，并将其分配为引用。有关详细信息，请参阅跟踪引用运算符。示例下面的示例生成 C3288。 The following sample generates C3288. // C3288.cpp  
// compile with: /clr  
ref class R {};  
int main() {  
   *(System::Object^) nullptr;   // C3288  

// OK  
   (System::Object^) nullptr;   // OK  
   R^ r;  
   R% pr = *r;  
}

编译器错误 C3289 Compiler Error C3289 11
“”：无法索引属性未正确声明属性。必须为索引的属性定义访问器。有关更多信息，请参见。示例下面的示例生成 C3289。 The following sample generates C3289. // C3289.cpp  
// compile with: /clr  
public ref struct C {  
   // user-defined simple indexer  
   property int indexer1[int];   // C3289  

   // user-defined indexer  
   property int indexer2[int] {  
      int get(int i) { return 0; }  
      void set(int i, int j) {}  
   }  
};  

int main() {  
   C ^ MyC = gcnew C();  
   MyC->indexer2[0] = 1;  
}

编译器错误 C3290 Compiler Error C3290 11
“”普通属性不能具有引用类型未正确声明属性。当声明普通属性时，编译器创建一个此属性将更新的变量，类中不能有跟踪引用变量。请参阅属性和跟踪引用运算符有关详细信息。示例下面的示例生成 C3290。 The following sample generates C3290. // C3290.cpp  
// compile with: /clr /c  
ref struct R {};  

ref struct X {  
   R^ mr;  

   property R % y;   // C3290  
   property R ^ x;   // OK  

   // OK  
   property R% prop {  
      R% get() {   
         return *mr;   
      }  

      void set(R%) {}  
   }  
};  

int main() {  
   X x;  
   R% xp = x.prop;  
}

编译器错误 C3291 Compiler Error C3291 11
“”不能作为属性的名称属性不能命名为。有关更多信息，请参见。示例以下示例生成。

编译器错误 C3292 Compiler Error C3292 11
命名空间不能重新打开命名空间不能在代码中声明。有关详细信息，请参阅平台、和命名空间。示例以下示例生成。

编译器错误 C3293 Compiler Error C3293 11
“”：使用“”访问“”类的默认属性（索引器）未正确访问索引的属性。请参阅如何：使用属性在有关详细信息。及更高版本的：在及更早版本中，在某些情况下编译器被错误地识别默认索引器作为默认属性。有可能通过使用标识符“”访问该属性来解决这个问题。在中将默认值引入为关键字后，解决方法本身会出现问题。因此，在中，需要解决方法的都已修复，现在将“”用于访问类的默认属性时，编译器会引发错误。示例下面的示例生成 C3293 在 Visual Studio 2015 及更早版本。 The following sample generates C3293 in Visual Studio 2015 and earlier. // C3293.cpp  
// compile with: /clr /c  
using namespace System;  
ref class IndexerClass {  
public:  
   // default indexer  
   property int default[int] {  
      int get(int index) { return 0; }  
      void set(int index, int value) {}  
   }  
};  

int main() {  
   IndexerClass ^ ic = gcnew IndexerClass;  
   ic->Item[0] = 21;   // C3293 in VS2015 OK in VS2017
   ic->default[0] = 21;   // OK in VS2015 and earlier

   String ^s = "Hello";  
   wchar_t wc = s->Chars[0];   // C3293 in VS2015 OK in VS2017
   wchar_t wc2 = s->default[0];   // OK in VS2015 and earlier  
   Console::WriteLine(wc2);  
}

编译器错误 C3295 Compiler Error C3295 11
“”只能在全局范围或命名空间范围上使用部分杂注不能在函数中使用。请参阅杂注指令和关键字有关详细信息。示例以下示例生成。

编译器错误 C3296 Compiler Error C3296 11
“”：已存在同名属性编译器遇到具有相同名称的多个属性。类型中的每个属性均必须具有唯一名称。有关详细信息，请参阅。示例以下示例生成。

编译器错误 C3297 Compiler Error C3297 11
“”：不能使用“”作为约束，因为“”具有值约束值类已密封。如果约束是值类，则永远无法从它派生其他约束。有关详细信息，请参阅泛型类型参数的约束。示例下面的示例生成 C3297。 The following sample generates C3297. // C3297.cpp  
// compile with: /clr /c  
generic<class T, class U>  
where T : value class  
where U : T   // C3297  
public ref struct R {};

编译器错误 C3298 Compiler Error C3298 11
“”：不能使用“”作为约束，因为“”具有约束，而“”具有值约束不能为约束指定相互排斥的特征。例如，不能同时将泛型类型参数约束为值类型和引用类型。有关详细信息，请参阅泛型类型参数的约束。示例下面的示例生成 C3298。 The following sample generates C3298. // C3298.cpp  
// compile with: /clr /c   
generic<class T, class U>  
where T : ref class  
where U : T, value class   // C3298  
public ref struct R {};

编译器错误 C3299 Compiler Error C3299 11
“”：无法指定约束，因为它们都继承自基方法替代泛型成员函数时，无法指定约束子句（重复约束意味着未继承约束）。将继承正在替代的泛型函数上的约束子句。有关详细信息，请参阅泛型类型参数的约束。示例下面的示例生成 C3299。 The following sample generates C3299. // C3299.cpp  
// compile with: /clr /c  
public ref struct R {  
   generic<class T>   
   where T : R  
   virtual void f();  
};  

public ref struct S : R {  
   generic<class T>   
   where T : R   // C3299  
   virtual void f() override;  
};

编译器错误 C3303 Compiler Error C3303 11
“特性”特性只能在“用法”上使用尝试使用无效的特性。

编译器错误 C3309 Compiler Error C3309 11
“”：模块名称不能是宏或关键字将传递给模块特性的属性的值不能为符号而必须是字符串文本，否则预处理器将无法展开。下面的示例生成 C3309： The following sample generates C3309: // C3309.cpp  
#define NAME MyModule  
[module(name="NAME")];   // C3309  
// Try the following line instead  
// [module(name="MyModule")];  
[coclass]  
class MyClass {  
public:  
   void MyFunc();  
};  

int main() {  
}

编译器错误 C3320 Compiler Error C3320 11
“”：类型不能和模块的“”属性同名导出的用户定义的类型，这可能是结构、类、枚举或联合，不能将相同的名称作为参数传递给模块特性的名称属性。示例以下示例生成：

编译器错误 C3322 Compiler Error C3322 11
“”：不是特性“”的有效属性向特性传递的属性（或参数）无效或无法识别。请查看该特性的文档。

编译器错误 C3333 Compiler Error C3333 11
“”：无法损坏的类型库编译器无法读取语句中指定的类型库。建议重新生成类型库（如可能），或从你的供应商请求提供新的类型库。建议使用随提供的查看器来查看类型库文件，以了解发生了什么情况。

编译器错误 C3334 Compiler Error C3334 11
无法损坏的类型库语句中的库文件已损坏，编译器无法使用它。损坏可来自于错误生成的模块、磁盘损坏，或者由于二进制文件以某种方式进行了编辑并修改。有关详细信息，请参阅指令。

编译器错误 C3340 Compiler Error C3340 11
“”：组件类“”中的接口不能同时是“”和“”特性和特性是互相排斥的。下面的示例生成 C3340： The following sample generates C3340: // C3340.cpp  
#include <windows.h>  
[module(name="MyModule")];  

[ object, uuid(373a1a4c-469b-11d3-a6b0-00c04f79ae8f) ]  
__interface IMyIface  
{  
   HRESULT f1();  
};  

[ coclass, uuid(373a1a4d-469b-11d3-a6b0-00c04f79ae8f),  
default(IMyIface),  
source(IMyIface),restricted(IMyIface) ]  
class CmyClass // C3340  
{  
};  

int main()  
{  
}

编译器错误 C3342 Compiler Error C3342 11
“”：不明确的特性编译器发现特性的多个定义。多次定义了特性。有关详细信息，请参阅。示例以下示例生成。

编译器错误 C3345 Compiler Error C3345 11
“”：模块名称的标识符无效模块的标识符包含一个或多个不可接受的字符。如果第一个字符是字母、下划线或高字符，且后续字符是字母数字、下划线或高字符，则标识符有效。更正此错误确保标识符不包含空格或其他不可接受的字符。示例下面的代码示例会导致错误消息，因为特性的参数包含一个空格。请参阅字符分类模块

编译器错误 C3347 Compiler Error C3347 11
“”：所需参数未在特性中指定所需参数未传递到特性。以下示例生成：

编译器错误 C3350 Compiler Error C3350 11
“”委托构造函数需要个参数创建委托实例时，必须传递两个参数，一个是包含委托函数的类型的实例，一个是该函数。下面的示例生成 C3350： The following sample generates C3350: // C3350.cpp  
// compile with: /clr  
delegate void SumDelegate();  

public ref class X {  
public:  
   void F() {}  
   static void F2() {}  
};  

int main() {  
   X ^ MyX = gcnew X();  
   SumDelegate ^ pSD = gcnew SumDelegate();   // C3350  
   SumDelegate ^ pSD1 = gcnew SumDelegate(MyX, &X::F);  
   SumDelegate ^ pSD2 = gcnew SumDelegate(&X::F2);  
}

编译器错误 C3351 Compiler Error C3351 11
“”：委托构造函数：第二个参数必须为静态成员函数或全局函数的地址编译器预期声明为的函数地址。以下示例生成：

编译器错误 C3352 Compiler Error C3352 11
：指定的函数委托类型不匹配参数列出和委托不匹配。有关详细信息，请参阅委托（组件扩展）。下面的示例生成 C3352: The following sample generates C3352: // C3352.cpp  
// compile with: /clr  
delegate int D( int, int );  
ref class C {  
public:  
   int mf( int ) {  
      return 1;  
   }  

   // Uncomment the following line to resolve.  
   // int mf(int, int) { return 1; }  
};  

int main() {  
   C^ pC = gcnew C;  
   System::Delegate^ pD = gcnew D( pC, &C::mf );   // C3352  
}

编译器错误 C3353 Compiler Error C3353 11
“”委托只能从全局函数或者托管或类型的成员函数中创建使用声明委托，委托关键字，只能在全局范围内声明。以下示例生成：

编译器错误 C3354 Compiler Error C3354 11
“”：该函数用于创建不能有返回类型“”的委托以下类型作为的返回类型无效：指向函数的指针指向成员的指针指向成员函数的指针对函数的引用对成员函数的引用以下示例生成：

编译器错误 C3356 Compiler Error C3356 11
“”无法使用完全限定名调用多路广播特性未正确指定由多个进程（例如编译器和提供程序）处理的特性。

编译器错误 C3358 Compiler Error C3358 11
“”：未找到符号找不到所需符号。以下示例生成：

编译器错误 C3360 Compiler Error C3360 11
“字符串”：无法创建名称传递给特性的值无效。以下示例生成：

编译器错误 C3363 Compiler Error C3363 11
“”：“”只能应用于类型运算符未正确使用。示例下面的示例生成 C3363。 The following sample generates C3363. // C3363.cpp  
// compile with: /clr  
int main() {  
   System::typeid;   // C3363  
}

编译器错误 C3364 Compiler Error C3364 11
：委托构造函数：参数必须是指向托管类的成员函数或全局函数该委托的构造函数的第二个参数采用成员函数的地址或任何类的静态成员函数的地址。同时将被视为简单的地址。下面的示例生成 C3364: The following sample generates C3364: // C3364_2.cpp  
// compile with: /clr  

delegate int D( int, int );  

ref class C {  
public:  
   int mf( int, int ) {  
      return 1;  
   }  
};  

int main() {  
   C^ pC = gcnew C;  
   System::Delegate^ pD = gcnew D( pC,pC->mf( 1, 2 ) ); // C3364  

   // try the following line instead  
   // System::Delegate^ pD = gcnew D(pC, &C::mf);  
}

编译器错误 C3365 Compiler Error C3365 11
运算符“”区分类型为“”和“”的操作数已尝试撰写具有不同类型的委托。请参阅如何：定义和使用委托有关委托的详细信息。示例以下示例生成：

编译器错误 C3366 Compiler Error C3366 11
：托管的静态数据成员或必须在类定义中定义尝试在或类接口定义外部引用该类或接口的静态成员。编译器需要知道类的完整定义（以在一次传递后发出元数据）并要求在类中初始化静态数据成员。例如，下面的示例生成 C3366，并演示如何修复此错误： For example, the following example generates C3366 and shows how to fix it: // C3366.cpp  
// compile with: /clr /c  
ref class X {  
   public:  
   static int i;   // initialize i here to avoid C3366  
};  

int X::i = 5;      // C3366

编译器错误 C3367 Compiler Error C3367 11
“”不能使用静态函数创建未绑定的委托当你调用未绑定的委托时，必须传递对象的实例。由于通过类名称调用静态成员函数，因此仅能通过实例成员函数实例化未绑定的委托。有关未绑定的委托的详细信息，请参阅如何：定义和使用委托。示例以下示例生成。

编译器错误 C3368 Compiler Error C3368 11
“”：的调用约定无效你只能在文件中使用或调用约定。以下示例生成：

编译器错误 C3369 Compiler Error C3369 11
“模块名”已经定义定义的使用只能在程序中出现一次。以下示例生成

编译器错误 C3370 Compiler Error C3370 11
“”：尚未定义使用在中指定入口点前，必须首先使用指定名称。以下示例生成：

编译器错误 C3371 Compiler Error C3371 11
“”此处只允许“”属性直接在函数声明上使用的除名称外不能有其他任何参数。以下示例生成：

编译器错误 C3372 Compiler Error C3372 11
必须至少为组件类的特性指定个接口对于某些特性，必须将接口名称作为参数传递。下面的示例生成 C3372： The following sample generates C3372: // C3372.cpp  
#include <windows.h>  
[module(name="MyModule")];  

[ object, uuid(373a1a4c-469b-11d3-a6b0-00c04f79ae8f) ]  
__interface IMyIface {  
   HRESULT f1();  
};  
// to resolve, pass an interface name to the source attribute  
// for example, source(IMyIface)  
[ coclass, uuid(373a1a4d-469b-11d3-a6b0-00c04f79ae8f), source,   
  default(IMyIface) ] // C3372  
class CMyClass {  
};  

int main() {  
}

编译器错误 C3373 Compiler Error C3373 11
除了针对组件类，特性“”不接受任何参数某些特性可以应用于多个构造，但特性的参数只允许在某些构造上使用。下面的示例生成 C3373： The following sample generates C3373: // C3373.cpp  
#include <windows.h>  

[module(name="MyModule")];  

[ object, uuid(373a1a4c-469b-11d3-a6b0-00c04f79ae8f) ]  
__interface IMyIface  
{  
   // arguments to source and restricted are not allowed when  
   // these attributes are applied to an interface  
   [source(IMyIface)] HRESULT f1();  
   [restricted(IMyIface)] HRESULT f2(); // C3373  
};  

[ coclass, uuid(373a1a4d-469b-11d3-a6b0-00c04f79ae8f) ]  
class CMyClass : public IMyIface {  
};  

int main() {  
}

编译器错误 C3374 Compiler Error C3374 11
不能采用“函数”的地址，除非创建委托实例在上下文中而不是委托实例的创建中采用函数的地址。以下示例生成：请参阅如何：定义和使用委托

编译器错误 C3375 Compiler Error C3375 11
“”：不明确的委托函数委托实例化可能已为静态成员函数，或为实例函数未绑定的委托，因此编译器出现此错误。有关详细信息，请参阅委托（组件扩展）。示例以下示例生成：

编译器错误 C3379 Compiler Error C3379 11
：嵌套的类不能将作为其声明的一部分的程序集访问说明符当应用于托管类型，例如类或结构，公共和私有关键字指示是否将程序集元数据通过公开的类。或不能应用于嵌套类，该类将继承封闭类的程序集访问权限。如果用于、和关键字指示该类受托管请参阅类和结构。下面的示例生成 C3379: The following sample generates C3379: // C3379a.cpp  
// compile with: /clr  
using namespace System;  

public ref class A {  
public:  
   static int i = 9;  

   public ref class BA {   // C3379  
   // try the following line instead  
   // ref class BA {  
   public:  
      static int ii = 8;  
   };  
};  

int main() {  

   A^ myA = gcnew A;  
   Console::WriteLine(myA->i);  

   A::BA^ myBA = gcnew A::BA;  
   Console::WriteLine(myBA->ii);  
}

编译器错误 C3380 Compiler Error C3380 11
“”程序集访问说明符无效只允许“”或“”应用于托管类或结构时，和关键字指示是否通过程序集元数据公开此类。程序中使用编译的类只可使用或。和关键字，与一起使用时，指示该类受托管请参阅类和结构。以下示例生成：

编译器错误 C3381 Compiler Error C3381 11
：程序集访问说明符才与选项编译的代码中可用本机类型可以是程序集，外部可见，但你只能指定中的本机类型的程序集访问编译。有关详细信息，请参阅键入可见性和（公共语言运行时编译）。示例下面的示例生成 C3381。 The following sample generates C3381. // C3381.cpp  
// compile with: /c  
public class A {};   // C3381

编译器错误 C3382 Compiler Error C3382 11
不支持将“”与一同使用编译的输出文件是可验证类型安全的文件，不支持，因为运算符的返回值是，其大小因操作系统而异。有关详细信息，请参阅运算符（公共语言运行时编译）位迁移的常见问题示例下面的示例生成 C3382。 The following sample generates C3382. // C3382.cpp  
// compile with: /clr:safe  
int main() {  
   sizeof( char );   // C3382  
}

编译器错误 C3383 Compiler Error C3383 11
不支持将“”与一起使用编译的输出文件可确保是类型安全的，且不支持指针。有关详细信息，请参阅（公共语言运行时编译）位迁移的常见问题示例下面的示例生成 C3383。 The following sample generates C3383. // C3383.cpp  
// compile with: /clr:safe  
int main() {  
   char* pCharArray = new char[256];  // C3383  
}

编译器错误 C3384 Compiler Error C3384 11
“”值约束与约束互相排斥无法将泛型类型约束为和。请参阅泛型类型参数的约束有关详细信息。示例下面的示例生成 C3384。 The following sample generates C3384. // C3384.cpp  
// compile with: /c /clr  
generic <typename T>  
where T : ref class  
where T : value class   // C3384  
ref class List {};

编译器错误 C3385 Compiler Error C3385 11
“”：具有自定义特性的函数不能返回类实例被定义为位于使用特性指定的文件中的函数不能返回类的实例。以下示例生成：

编译器错误 C3386 Compiler Error C3386 11
（不能应用于托管或和修饰符都不是有效的托管或运行时类型。下面的示例生成 C3386，并演示如何修复此错误： The following sample generates C3386 and shows how to fix it: // C3386.cpp  
// compile with: /clr /c  
ref class __declspec(dllimport) X1 {   // C3386  
// try the following line instead  
// ref class X1 {  
};

编译器错误 C3387 Compiler Error C3387 11
（不能应用于成员托管或类型和修饰符都不是有效的托管成员或运行时类型。下面的示例将生成，并演示如何修复此错误：

编译器错误 C3388 Compiler Error C3388 11
“”不允许作为约束，假定继续进行分析对泛型类型指定了约束，但是未正确地指定约束。请参阅泛型类型参数的约束有关详细信息。示例下面的示例生成 C3388。 The following sample generates C3388. // C3388.cpp  
// compile with: /clr /c  
interface class AA {};  

generic <class T>  
where T : interface class   // C3388  
ref class C {};  

// OK  
generic <class T>  
where T : AA  
ref class D {};

编译器错误 C3389 Compiler Error C3389 11
不能用于或和编译器选项在中已弃用。使用修饰符意味着每个进程状态。意味着每个状态。因此，声明的变量修饰符，并使用编译不允许。下面的示例生成 C3389: The following sample generates C3389: // C3389.cpp  
// compile with: /clr:pure /c  
__declspec(dllexport) int g2 = 0;   // C3389

编译器错误 C3390 Compiler Error C3390 11
“”对于泛型“”，泛型参数“”的类型实参无效，它必须是引用类型泛型类型实例化错误。检查类型定义。有关详细信息，请参阅泛型。示例第一个示例使用来创建包含具有中创建泛型类型时，不支持某些约束的泛型类型的组件。有关详细信息，请参阅类型参数的约束。可用组件时，下面的示例生成 C3390。 When the C3390.dll component is available, the following sample generates C3390. // C3390_b.cpp  
// Compile by using: cl /clr C3390_b.cpp
#using <C3390.dll>  
ref class R { R(int) {} };  
value class V {};  
ref struct N { N() {} };  

int main () {  
   GR<V, V, N^>^ gr2;   // C3390 first type must be a ref type  
   GR<R^, V, N^>^ gr2b; // OK  
}

编译器错误 C3391 Compiler Error C3391 11
：必须是不可为的值类型的泛型参数泛型的类型参数无效。泛型类型实例化错误。检查类型定义。有关详细信息，请参阅和泛型。示例下面的示例使用来创建包含具有中创建泛型类型时，不支持某些约束的泛型类型的组件。有关详细信息，请参阅类型参数的约束。可用组件时，下面的示例生成 C3391。 When the C3391.dll component is available, the following sample generates C3391. // C3391_b.cpp  
// Compile by using: cl /clr C3391_b.cpp  
#using <C3391.dll>  
using namespace System;  
value class VClass {};  

int main() {  
   GR< Nullable<VClass> >^ a =   
      gcnew GR< Nullable<VClass> >();   // C3391 can't be Nullable  
   GR<VClass>^ aa = gcnew GR<VClass>(); // OK  
}

编译器错误 C3392 Compiler Error C3392 11
“”对于泛型“”，泛型参数“”的类型变量无效，它必须具有公共无参数构造函数泛型类型实例化错误。检查类型定义。有关详细信息，请参阅泛型。示例下面的示例使用来创建包含具有中创建泛型类型时，不支持某些约束的泛型类型的组件。有关详细信息，请参阅类型参数的约束。可用组件时，下面的示例生成 C3392。 When the C3392.dll component is available, the following sample generates C3392. // C3392_b.cpp  
// Compile by using: cl /clr C3392_b.cpp  
#using <C3392.dll>  

ref class R { R(int) {} };  
ref class N { N() {} };  

value class V {};  

ref class N2 { public: N2() {} };  
ref class R2 { public: R2() {} };  

int main () {  
   GR<R^, V, N^>^ gr1;   // C3392  
   GR<R^, V, N2^>^ gr1a; // OK  

   GR<R^, N^, N^>^ gr3;  // C3392  
   GR<R^, V, N2^>^ gr3a; // OK  

   GR<R^, V, R^>^ gr4;   // C3392  
   GR<R^, V, R2^>^ gr4a; // OK  
}

编译器错误 C3393 Compiler Error C3393 11
子句有语法错误：“”不是一个类型传递给约束的标识符必须是一种类型，但该标识符不是一种类型。有关详细信息，请参阅泛型类型参数的约束。示例以下示例生成：

编译器错误 C3394 Compiler Error C3394 11
子句有语法错误：应为类型却发现“”约束格式不正确。有关详细信息，请参阅泛型类型参数的约束。示例下面的示例生成 C3394： The following sample generates C3394: // C3394.cpp  
// compile with: /clr /c  
ref class MyClass {};  
ref class R {  
   generic<typename T>  
   where T : static   // C3394  
   // try the following line instead  
   // where T : MyClass  
   void f() {}  
};

编译器错误 C3395 Compiler Error C3395 11
（）不能应用于具有函数调用约定和不兼容。有关详细信息，请参阅、。下面的示例生成 C3395: The following sample generates C3395: // C3395.cpp  
// compile with: /clr /c  

__declspec(dllexport) void __clrcall Test(){}   // C3395  
void __clrcall Test2(){}   // OK  
__declspec(dllexport) void Test3(){}   // OK

编译器错误 C3396 Compiler Error C3396 11
“”未能在“”中发现自定义特性指示你正在使用的不是最新的公共语言运行时。重新安装以解决问题。

编译器错误 C3397 Compiler Error C3397 11
默认参数中不允许进行聚合初始化未正确声明数组。请参阅数组有关详细信息。示例下面的示例生成 C3397。 The following sample generates C3397. // C3397.cpp  
// compile with: /clr  
// /clr /c  
void Func(array<int> ^p = gcnew array<int> { 1, 2, 3 });   // C3397  
void Func2(array<int> ^p = gcnew array<int> (3));   // OK  

int main() {  
   array<int> ^p = gcnew array<int> { 1, 2, 3};   // OK  
}

编译器错误 C3398 Compiler Error C3398 11
“”：无法从“”转换为“”。源表达式必须是函数符号当使用进行编译时，如果未指定调用约定，编译器将为每个函数生成两个入口点（地址）：一个本机入口点和一个托管入口点。默认情况下，编译器返回本机入口点，但有些情况需要托管入口点（例如将地址分配给函数指针时）。为了使编译器能够在分配中可靠地选择托管入口点，右侧必须为函数符号。

编译器错误 C3399 Compiler Error C3399 11
“”：创建泛型参数的实例时无法提供变量当指定约束时，指定约束类型将具有无参数的构造函数。因此，尝试实例化此类型并传递参数是错误的。请参阅泛型类型参数的约束有关详细信息。示例以下示例生成。

编译器错误 C3400 Compiler Error C3400 11
涉及“”和“”的循环约束依赖项编译器检测到循环约束。有关详细信息，请参阅泛型类型参数的约束。示例以下示例生成。

编译器错误 C3408 Compiler Error C3408 11
“”：模板定义中不允许使用特性特性不能应用于模板定义。示例以下示例生成。

编译器错误 C3409 Compiler Error C3409 11
不允许空特性块方括号被解释为编译器属性找到块，但没有属性。当你使用方括号的表达式定义的一部分时，编译器可能生成此错误。当编译器无法确定方括号是否定义或特性块的表达式的一部分时，将出现此错误。有关表达式的详细信息，请参阅表达式。更正此错误如果方括号特性块的一部分：提供的属性块中的一个或多个属性。删除该特性块。如果方括号是表达式的一部分：请确保在表达式遵循有效语法规则。有关表达式语法的详细信息，请参阅表达式语法。示例下面的示例生成 C3409。 The following example generates C3409. // C3409.cpp  
// compile with: /c  
#include <windows.h>  
[]   // C3409  
class a {};  

// OK  
[object, uuid("00000000-0000-0000-0000-000000000000")]  
__interface x {};  

[coclass, uuid("00000000-0000-0000-0000-000000000001")]  
class b : public x {}; 示例 Example 下面的示例生成 C3409，因为 lambda 表达式使用 mutable 规范中，但未提供参数列表。 The following example generates C3409 because a lambda expression uses the mutable specification, but does not provide a parameter list. 编译器无法确定方括号是否定义或特性块的 lambda 表达式的一部分。 The compiler cannot determine whether the square brackets are part of the definition of a lambda expression or of an attribute block. // C3409b.cpp  

int main()  
{  
   [] mutable {}();  
} 请参阅 See Also 属性 attribute Lambda 表达式 Lambda Expressions Lambda 表达式语法 Lambda Expression Syntax

编译器错误 C3412 Compiler Error C3412 11
无法使当前作用域中的模板专用化模板不能在类范围内，只能在全局或命名空间范围专用化。示例下面的示例生成 C3412。 The following sample generates C3412. // C3412.cpp  
template <class T>  
struct S {  
   template <>  
   struct S<int> {};   // C3412 in a class  
}; 示例 Example 下面的示例演示了可能的解决方法。 The following sample shows a possible resolution. // C3412b.cpp  
// compile with: /c  
template <class T>  
struct S {};  

template <>  
struct S<int> {};

编译器错误 C3413 Compiler Error C3413 11
“”：显式实例化无效编译器检测到格式不正确的显式实例化。下面的示例生成 C3413： The following sample generates C3413: // C3413.cpp  
template  
class MyClass {};   // C3413 可能的解决方法： Possible resolution: // C3413b.cpp  
// compile with: /c  
template <class T>  
class MyClass {};  

template <>  
class MyClass<int> {};

编译器错误 C3414 Compiler Error C3414 11
：不能定义导入的成员函数此外定义中引用的程序集中的代码中定义的成员。下面的示例生成 C3414: The following sample generates C3414: // C3414a2.cpp  
// compile with: /clr /LD  
public ref class MyClass {  
public:  
   void Test(){}  
}; 然后： and then: // C3414b2.cpp  
// compile with: /clr  
#using <C3414a2.dll>  

void MyClass::Test() {    // C3414  
}  

System::Object::Object() {    // C3414  
}

编译器错误 C3415 Compiler Error C3415 11
找到多个“”节，它们具有不同的属性（“”）在节杂注中指定了冲突值。是本节的当前设置，如中所指定。例如下面的示例生成 C3415： The following sample generates C3415: // C3415.cpp  
#pragma section("mysec1",write)  
#pragma section("mysec1",read)   // C3415

编译器错误 C3417 Compiler Error C3417 11
：值类型不能包含用户定义的特殊成员函数值类型不能包含如默认实例构造函数、析构函数或复制构造函数的函数。下面的示例生成 C3517: The following sample generates C3517: // C3417.cpp  
// compile with: /clr /c  
value class VC {  
   VC(){}   // C3417  

   // OK  
   static VC(){}  
   VC(int i){}  
};

编译器错误 C3418 Compiler Error C3418 11
不支持访问说明符“”不正确地指定了访问说明符。有关详细信息，请参阅类型可见性和成员可见性如何：定义和使用类和结构。示例下面的示例生成 C3418。 The following sample generates C3418. // C3418.cpp  
// compile with: /clr /c  
ref struct m {  
internal public:   // C3418  
   void test(){}  
};  

ref struct n {  
internal:   // OK  
   void test(){}  
};

编译器错误 C3420 Compiler Error C3420 11
“”终结器不能为虚终结器只能从其封闭类型进行非虚拟调用。因此，声明虚拟终结器是错误的。有关详细信息，请参阅析构函数和终结器中如何：定义和使用类和结构。示例下面的示例生成 C3420。 The following sample generates C3420. // C3420.cpp  
// compile with: /clr /c  
ref class R {  
   virtual !R() {}   // C3420  
};

编译器错误 C3421 Compiler Error C3421 11
“”由于该类的终结器不可访问或不存在，因此无法调用它终结器属于隐式专用，因此无法从其封闭类型外调用它。有关详细信息，请参阅析构函数和终结器中如何：定义和使用类和结构。示例下面的示例生成 C3421。 The following sample generates C3421. // C3421.cpp  
// compile with: /clr  
ref class A {};  

ref class B {   
   !B() {}  

public:  
   ~B() {}  
};  

int main() {  
   A a;  
   a.!A();   // C3421  

   B b;  
   b.!B();   // C3421  
}

编译器错误 C3446 Compiler Error C3446 11
类：默认成员初始值设定项不允许的值类成员在及更早版本中，（但会忽略）值类成员的默认成员初始值设定项。值类的默认初始化始终对成员执行零初始化；不允许使用默认构造函数。在中，默认成员初始值设定项引发

编译器错误，如下例所示： In Visual Studio 2017, default member initializers raise a compiler error, as shown in this example: 示例 Example 下面的示例生成 C3446 Visual Studio 2017 及更高版本： The following sample generates C3446 in Visual Studio 2017 and later: // C3446.cpp  
若要更正错误，删除初始值设定项：

编译器错误 C3450 Compiler Error C3450 11
“”：不是特性；不能指定或用户定义的托管特性必须继承自。运行时特性必须在命名空间中定义。有关详细信息，请参阅。示例下面的示例将生成，并演示如何修复此错误。

编译器错误 C3451 Compiler Error C3451 11
：无法将应用非托管的属性特性不能应用于类型。请参阅特性参考有关详细信息。有关详细信息，请参阅。此错误可能来自于为年执行的编译器一致性工作：属性不再允许在使用编程的用户定义的特性。请改用。示例下面的示例生成 C3451。 The following sample generates C3451. // C3451.cpp  
// compile with: /clr /c  
using namespace System;  
[ attribute(AttributeTargets::All) ]  
public ref struct MyAttr {};  

[ MyAttr, helpstring("test") ]   // C3451  
// try the following line instead  
// [ MyAttr ]  
public ref struct ABC {};

编译器错误 C3452 Compiler Error C3452 11
列出不是常量的参数成员参数被传递到一个特性，但此特性需要一个常量，即一个在编译时可计算出结果的值。示例下面的示例生成 C3452。 The following sample generates C3452. // C3452.cpp  
// compile with: /c  
int i;  
[module( name="mod", type=dll, custom={i} ) ];   // C3452  
// try the following line instead  
// [module( name="mod", type=dll, custom={"a"} ) ];

编译器错误 C3453 Compiler Error C3453 11
“”：由于限定符“”不匹配，因此没有应用特性程序集或模块级特性只能指定为独立的说明。示例下面的示例生成 C3453。 The following sample generates C3453. // C3453.cpp  
// compile with: /clr /c  
[assembly:System::CLSCompliant(true)]   // C3453  
// try the following line instead  
// [assembly:System::CLSCompliant(true)];  
ref class X {};

编译器错误 C3454 Compiler Error C3454 11
类声明中不允许出现必须为它定义一个类，使其成为特性。有关更多信息，请参见。示例下面的示例生成 C3454。 The following sample generates C3454. // C3454.cpp  
// compile with: /clr /c  
using namespace System;  

[attribute]   // C3454  
ref class Attr1;  

[attribute]   // OK  
ref class Attr2 {};

编译器错误 C3455 Compiler Error C3455 11
“”：没有任何特性构造函数匹配这些参数已使用无效的值声明特性。有关更多信息，请参见。示例以下示例生成

编译器错误 C3456 Compiler Error C3456 11
不可用于托管或类声明用于定义将被代码分析使用的自定义属性。只有当存在理解此属性的相应插件时，这些自定义属性才有用。

编译器错误 C3457 Compiler Error C3457 11
“”：特性不支持未命名参数源特性与自定义特性或编译器特性不同，仅支持命名参数。示例以下示例生成。

编译器错误 C3458 Compiler Error C3458 11
“”已为“”指定特性“”为同一个构造指定了两个互相排斥的特性。示例下面的示例生成 C3458 The following sample generates C3458 // C3458.cpp  
// compile with: /clr /c  
[System::Reflection::DefaultMember("Chars")]  
public ref class MyString {  
public:  
   [System::Runtime::CompilerServices::IndexerName("Chars")]   // C3458  
   property char default[int] {  
      char get(int index);  
      void set(int index, char c);  
   }  
};

编译器错误 C3459 Compiler Error C3459 11
“”：特性只允许出现在类索引器上（默认索引属性）错误地使用了设计为应用于类索引器属性的特性。有关详细信息，请参阅如何：使用属性在。示例下面的示例生成 C3459。 The following sample generates C3459. // C3459.cpp  
// compile with: /clr /c  
public ref class MyString {  
public:  
   [System::Runtime::CompilerServices::IndexerName("Chars")]   // C3459  
   property int Prop;  
};  

// OK  
public ref class MyString2 {  
   array<int>^ MyArr;  
public:  
   MyString2() {  
      MyArr = gcnew array<int>(5);  
   }  

   [System::Runtime::CompilerServices::IndexerName("Chars")]   // OK  
   property int default[int] {  
      int get(int index) {  
         return MyArr[index];  
      }  
      void set(int index, int value) {  
         MyArr[index] = value;  
      }  
   }  
};

编译器错误 C3460 Compiler Error C3460 11
“”仅可转发用户定义的类型有关详细信息，请参阅类型转发。示例下面的示例创建一个组件。示例下面的示例生成 C3460。 The following sample generates C3460. // C3460_b.cpp  
// compile with: /clr /c  
#using "C3460.dll"  
[assembly:TypeForwardedTo(int::typeid)];   // C3460  
[assembly:TypeForwardedTo(R::typeid)];

编译器错误 C3461 Compiler Error C3461 11
“”：仅可转发托管类型类型转发只会在类型上发生。请参阅类和结构有关详细信息。有关详细信息，请参阅类型转发。示例下面的示例创建一个组件。示例下面的示例生成 C3461。 The following sample generates C3461. // C3461b.cpp  
// compile with: /clr /c  
#using "C3461.dll"  
class N {};  
[assembly:TypeForwardedTo(N::typeid)];   // C3461  
[assembly:TypeForwardedTo(R::typeid)];   // OK

编译器错误 C3462 Compiler Error C3462 11
“”：只有导入的类型才能被转发特性必须应用于引用的元数据中的类型。有关详细信息，请参阅类型转发。示例下面的示例创建一个组件。示例下面的示例生成 C3462。 The following sample generates C3462. // C3462b.cpp  
// compile with: /clr /c  
#using "C3462.dll"  
ref class N {};  
[assembly:TypeForwardedTo(N::typeid)];   // C3462  
[assembly:TypeForwardedTo(R::typeid)];

编译器错误 C3463 Compiler Error C3463 11
“”：类型不允许出现在特性“”中向特性传递了一个无效类型。例如，可以传递一个接口到，但不能将一个指针传递到一个接口。示例以下示例生成。

编译器错误 C3464 Compiler Error C3464 11
“”嵌套类型不能被转发嵌套类型上不能进行类型转发。有关详细信息，请参阅类型转发。示例下面的示例创建一个组件。示例下面的示例生成 C3464。 The following sample generates C3464. // C3464_b.cpp  
// compile with: /clr /c  
#using "C3464.dll"  
[assembly:TypeForwardedTo(R::N::typeid)];   // C3464  
[assembly:TypeForwardedTo(R::typeid)];   // OK

编译器错误 C3465 Compiler Error C3465 11
若要使用类型“”，必须引用程序集“”在重新之前，类型转发都将适用于客户端应用程序。重新含客户端应用程序中所用类型定义的每个程序集都将需要一个引用。有关详细信息，请参阅类型转发。示例以下示例生成包含类型新位置的程序集。示例以下示例生成用来包含类型定义的程序集，但现在却包含此类型的转发语法。示例下面的示例生成 C3465。 The following sample generates C3465. // C3465_c.cpp  
// compile with: /clr  
// C3465 expected  
#using "C3465_b.dll"  
// Uncomment the following line to resolve.  
// #using "C3465.dll"  

int main() {  
   R^ r = gcnew R();  
}

编译器错误 C3466 Compiler Error C3466 11
：不能转发泛型类专用化不能使用类型转发泛型类的专用化。有关详细信息，请参阅类型转发。示例下面的示例创建一个组件。示例下面的示例生成 C3466。 The following sample generates C3466. // C3466_b.cpp  
// compile with: /clr /c  
#using "C3466.dll"  
[assembly:TypeForwardedTo(GR<int>::typeid)];   // C3466  
[assembly:TypeForwardedTo(GR2::typeid)];   // OK

编译器错误 C3467 Compiler Error C3467 11
“”：此类型已被转发了同一类型的多个转发类型声明。每个类型只允许具有一个声明。有关详细信息，请参阅类型转发。示例下面的示例创建一个组件。示例下面的示例生成 C3467。 The following sample generates C3467. // C3467_b.cpp  
// compile with: /clr /c  
#using "C3467.dll"  
[ assembly:TypeForwardedTo(R::typeid) ];  
[ assembly:TypeForwardedTo(R::typeid) ];   // C3467

编译器错误 C3468 Compiler Error C3468 11
“”只能将类型转发到程序集“”不是程序集只能转发程序集中的类型。有关详细信息，请参阅类型转发。示例下面的示例创建一个模块。示例下面的示例生成 C3468。 The following sample generates C3468. // C3468_b.cpp  
// compile with: /clr /c  
#using "C3468.netmodule"  
[ assembly:TypeForwardedTo(R::typeid) ];   // C3468

编译器错误 C3469 Compiler Error C3469 11
“”：不能转发泛型类不能对泛型类使用类型转发。有关详细信息，请参阅类型转发。示例下面的示例创建一个组件。示例下面的示例生成 C3466。 The following sample generates C3466. // C3469_b.cpp  
// compile with: /clr /c  
#using "C3469.dll"  
[assembly:TypeForwardedTo(GR::typeid)];   // C3469  
[assembly:TypeForwardedTo(GR2::typeid)];   // OK

编译器错误 C3470 Compiler Error C3470 11
“”：类不能同时具有索引器（默认索引属性）和运算符类型不能定义默认索引器和运算符。示例以下示例生成

编译器错误 C3480 Compiler Error C3480 11
“”：捕获变量必须来自封闭函数范围捕获变量不是来自封闭函数范围。更正此错误从表达式的捕获列表中删除该变量。示例下面的示例将生成，因为变量不是来自封闭函数范围：示例下面的示例通过从表达式的捕获列表中删除变量来解决：请参阅表达式

编译器错误 C3481 Compiler Error C3481 11
“”：未找到捕获变量编译器未找到传递给表达式捕获列表的变量的定义。更正此错误从表达式的捕获列表中删除该变量。示例下面的示例由于未定义变量而生成：请参阅表达式

编译器错误 C3482 Compiler Error C3482 11
“”只能在非静态成员函数中用作捕获不能将传递至在静态方法或全局函数中声明的表达式的捕获列表中。更正此错误将封闭函数转换为非静态方法，或从表达式的捕获列表中删除指针。示例以下示例生成：请参阅表达式

编译器错误 C3483 Compiler Error C3483 11
“”已经是捕获列表的一部分你不止一次向表达式的捕获列表传递了相同的变量。更正此错误从捕获列表中删除变量的所有其他实例。示例下面的示例将生成，因为变量在表达式的捕获列表中出现了多次。请参阅表达式

编译器错误 C3484 Compiler Error C3484 11
返回类型前应为“”你必须在表达式的返回类型前提供。更正此错误在返回类型前提供。示例下面的示例生成 C3484： The following example generates C3484: // C3484a.cpp  

int main()  
{  
   return []() . int { return 42; }(); // C3484  
} 示例 Example 下面的示例通过在 lambda 表达式的返回类型之前提供 -> 来解决 C3484： The following example resolves C3484 by providing -> before the return type of the lambda expression: // C3484b.cpp  

int main()  
{  
   return []() -> int { return 42; }();  
} 请参阅 See Also Lambda 表达式 Lambda Expressions

编译器错误 C3485 Compiler Error C3485 11
定义不能包含任何限定符不能使用或限定符作为表达式定义的一部分。更正此错误从表达式定义中删除或限定符。示例以下示例生成，因为它使用限定符作为表达式定义的一部分：请参阅表达式

编译器错误 C3487 Compiler Error C3487 11
“返回类型”所有返回表达式必须推导为相同类型以前为“返回类型”必须指定其返回类型，除非它包含单个返回语句。如果包含多个返回语句，则它们必须具有相同类型。更正此错误为指定结尾返回类型。验证的所有返回值都属于相同类型或可以隐式转换为返回类型。示例下面的示例生成 C3487，因为 lambda 的返回类型不匹配： The following example generates C3487 because the return types of the lambda do not match: // C3487.cpp  
// Compile by using: cl /c /W4 C3487.cpp  

int* test(int* pi) {  
   // To fix the error, uncomment the trailing return type below  
   auto odd_pointer = [=]() /* -> int* */ {  
      if (*pi % 2)   
         return pi;  
      return nullptr; // C3487 - nullptr is not an int* type  
   };  
   return odd_pointer();  
} 请参阅 See Also Lambda 表达式 Lambda Expressions

编译器错误 C3488 Compiler Error C3488 11
当默认捕获模式为按引用捕获时，不允许使用“”当指定表达式的默认捕获模式为按引用捕获时，无法按引用将变量传递给该表达式的捕获子句。更正此错误不要显式将变量传递给捕获子句，或者不要将按引用指定为默认捕获模式，或者将按值指定为默认捕获模式，或者按值将变量传递到捕获子句。（这可能会更改表达式的行为。）示例下面的示例生成 C3488，因为对变量 n 的引用出现在默认模式为按引用的 lambda 表达式的捕获子句中： The following example generates C3488 because a reference to the variable n appears in the capture clause of a lambda expression whose default mode is by-reference: // C3488a.cpp  

int main()  
{  
   int n = 5;  
   [&, &n]() { return n; } (); // C3488  
} 示例 Example 下面的示例演示 C3488 的四种可能的解决方法： The following example shows four possible resolutions to C3488: // C3488b.cpp  

int main()  
{  
   int n = 5;  

   // Possible resolution 1:  
   // Do not explicitly pass &n to the capture clause.  
   [&]() { return n; } ();  

   // Possible resolution 2:  
   // Do not specify by-reference as the default capture mode.  
   [&n]() { return n; } ();  

   // Possible resolution 3:  
   // Specify by-value as the default capture mode.  
   [=, &n]() { return n; } ();  

   // Possible resolution 4:  
   // Pass n by value to the capture clause.  
   [n]() { return n; } ();  
} 请参阅 See Also Lambda 表达式 Lambda Expressions

编译器错误 C3489 Compiler Error C3489 11
当默认捕获模式为按值捕获时，要求使用“”当你指定表达式的默认捕获模式是按值捕获时，不能按值将变量传递给该表达式的捕获子句。更正此错误不要显式将变量传递给捕获子句，或者不要将按值捕获指定为默认捕获模式，或者将按引用捕获指定为默认捕获模式，或者按引用将变量传递给捕获子句。（这可能会更改表达式的行为。）示例下面的示例将生成。变量按值出现在默认模式为按值捕获的表达式的捕获子句中：示例下面的示例演示的四种可能解决方法：请参阅表达式

编译器错误 C3490 Compiler Error C3490 11
无法修改，因为正在通过对象对其进行访问在方法中声明的表达式不能修改不可变成员数据。更正此错误从方法声明删除修饰符。示例下面的示例生成 C3490，因为它修改 _i 方法中的成员变量 const ： The following example generates C3490 because it modifies the member variable _i in a const method: // C3490a.cpp  
// compile with: /c  

class C  
{  
   void f() const   
   {  
      auto x = [=]() { _i = 20; }; // C3490  
   }  

   int _i;  
}; 示例 Example 下面的示例通过从方法声明删除 const 修饰符解决了错误 C3490： The following example resolves C3490 by removing the const modifier from the method declaration: // C3490b.cpp  
// compile with: /c  

class C  
{  
   void f()  
   {  
      auto x = [=]() { _i = 20; };  
   }  

   int _i;  
}; 请参阅 See Also Lambda 表达式 Lambda Expressions

编译器错误 C3491 Compiler Error C3491 11
“”：不能在非可变中修改按值捕获非可变表达式不能修改通过值捕获的变量的值。更正此错误用关键字声明表达式，或者将该变量按引用传递到表达式的捕获列表。示例下面的示例生成 C3491，因为非可变 lambda 表达式的主体修改了捕获变量 m ： The following example generates C3491 because the body of a non-mutable lambda expression modifies the capture variable m : // C3491a.cpp  

int main()  
{  
   int m = 55;  
   [m](int n) { m = n; }(99); // C3491  
} 示例 Example 下面的示例通过使用 mutable 关键字声明 lambda 表达式来解决 C3491： The following example resolves C3491 by declaring the lambda expression with the mutable keyword: // C3491b.cpp  

int main()  
{  
   int m = 55;  
   [m](int n) mutable { m = n; }(99);  
} 请参阅 See Also Lambda 表达式 Lambda Expressions

编译器错误 C3492 Compiler Error C3492 11
“”不能捕获匿名联合的成员不能捕获未命名联合的成员。更正此错误为联合提供一个名称，并将整个此联合结构传递到表达式的捕获列表。示例以下示例将生成，因为它捕获匿名联合的成员：示例通过给此联合提供名称以及将整个联合结构传递给表达式的捕获列表，下面的示例解析了：请参阅表达式

编译器错误 C3493 Compiler Error C3493 11
无法隐式捕获“”，因为尚未指定默认捕获模式空表达式捕获指定表达式不显式或隐式捕获任何变量。更正此错误提供默认捕获模式，或显式捕获一个或多个变量。示例下面的示例生成 C3493，因为它将修改外部变量，但指定空的 capture 子句： The following example generates C3493 because it modifies an external variable but specifies the empty capture clause: // C3493a.cpp  

int main()  
{  
   int m = 55;  
   [](int n) { m = n; }(99); // C3493  
} 示例 Example 下面的示例通过将“按引用”指定为默认捕获模式来解决 C3493。 The following example resolves C3493 by specifying by-reference as the default capture mode. // C3493b.cpp  

int main()  
{  
   int m = 55;  
   [&](int n) { m = n; }(99);  
} 请参阅 See Also Lambda 表达式 Lambda Expressions

编译器错误 C3495 Compiler Error C3495 11
“”：捕获必须有自动存储持续时间不能捕获没有自动存储持续时间的变量，如标记为或的变量。更正此错误不要将或变量传递到表达式的捕获列表。示例下面的示例将生成，因为表达式的捕获列表中出现了变量：请参阅表达式

编译器错误 C3496 Compiler Error C3496 11
“”始终按值捕获已忽略“”不能按引用捕获指针。更正此错误按值捕获指针。示例下面的示例将生成，因为表达式的捕获列表中出现了对指针的引用：请参阅表达式

编译器错误 C3498 Compiler Error C3498 11
：无法捕获具有托管的变量或无法在中捕获具有托管类型或运行时类型的变量。更正此错误将托管或运行时变量传递到表达式的参数列表。示例下面的示例将生成，因为表达式的捕获列表中出现了具有托管类型的变量：示例下面的示例通过将托管变量传递到表达式的参数列表，解决了：请参阅表达式

编译器错误 C3499 Compiler Error C3499 11
已指定返回类型为的无法返回值当将指定为返回类型的表达式返回值时，编译器产生此错误；或者当表达式包含多条语句并返回一个值，但是未指定其返回类型时也会产生此错误。更正此错误请勿从表达式返回值，或提供表达式的返回类型，或将构成表达式主体的语句合并成一条语句。示例以下示例将生成，因为表达式的主体包含多条语句并返回一个值，但表达式未指定返回类型：示例以下示例演示的两个可能的解决方法。第一个解决方法是提供表达式的返回类型。第二个解决方法是将构成表达式主体的语句合并成一条语句。请参阅表达式

编译器错误 C3500 Compiler Error C3500 11
的无效使用指定了一个无效的语句。检查注册表，以确保指定一个有效。

编译器错误 C3501 Compiler Error C3501 11
没有为的注册任何类型库类给定不具有关联的类型库。因此，则无法将传递到语句。

编译器错误 C3505 Compiler Error C3505 11
无法加载类型库如果你正在运行位、承载交叉编译器位的则可能导致，目标在位计算机，因为编译器在下运行，并且只能读取位注册表配置单元。你可以通过构建你尝试导入，类型库的位和位版本中解决此错误，然后注册这两个。或者可以使用本机位编译器，要求你将更改你目录以指向的位编译器中的属性。有关详细信息，请参阅如何：在命令行上启用位工具集如何：针对位平台配置项目

编译器错误 C3506 Compiler Error C3506 11
没有为注册任何类型库未正确注册类型库。使用注册类型库。

编译器错误 C3507 Compiler Error C3507 11
可以具有不能超过个字符也不包含除了任何标点。也不能以数字开头属性将限制对可能需要的值。下面的示例生成 C3507: The following sample generates C3507: // C3507.cpp  
[module(name="x")];  
[  
coclass,  
progid("0123456789012345678901234567890123456789"),  
uuid("00000000-0000-0000-0000-000000000001") // C3507 expected  
]  
struct CMyStruct {  
};  
int main() {  
}

编译器错误 C3508 Compiler Error C3508 11
：不是有效的自动化类型指定了无效的类型。示例下面的示例生成 C3508: The following sample generates C3508: // C3508.cpp  
#define _ATL_DEBUG_QI  

#define WIN32_LEAN_AND_MEAN  
#define STRICT  
#ifndef _WIN32_WINNT  
#define _WIN32_WINNT 0x0400  
#endif  

#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
extern CComModule _Module;  
#include <atlcom.h>  
#include <atlctl.h>  
#include <atlstr.h>  

extern "C" int printf_s(const char*, ...);  

[module(name=oso)];  

union U  
// try the following two lines instead  
// [export]  
// struct U  
{  
   int i, j;  
};  

[dispinterface]  
__interface I  
{  
   [id(1)] HRESULT func(U* u);  
};  

[coclass]  
struct C : I  
{  
   HRESULT func(U*)   // C3508  
   {  
      return E_FAIL;  
   }  
};  

int main()  
{  
}

编译器错误 C3509 Compiler Error C3509 11
：无效的自动化返回类型当参数标记，返回类型必须是，或接口中的方法必须返回还是的。下面的示例生成 C3509: The following sample generates C3509: // C3509.cpp  
#define _ATL_DEBUG_QI  

#define WIN32_LEAN_AND_MEAN   // Exclude rarely-used stuff from Windows headers  
#define STRICT  
#ifndef _WIN32_WINNT  
#define _WIN32_WINNT 0x0400  
#endif  

#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
extern CComModule _Module;  
#include <atlcom.h>  
#include <atlctl.h>  
#include <atlstr.h>  

[module(name=oso)];  

[dispinterface, uuid(00000000-0000-0000-0000-000000000001)]  
__interface I {  
   [id(1)] int f([out, retval] int*);   // C3509  
   // try the following line instead  
   // [id(1)] void f([out, retval] int*);  
};  

[coclass, uuid(00000000-0000-0000-0000-000000000002)]  
struct C : I {  
   int f(int*) {  
   // try the following line instead, and delete return statement  
   // void f(int*) {  
      return 0;  
   }  
};  

int main() {  
}

编译器错误 C3510 Compiler Error C3510 11
找不到依赖类型库和传递给但编译器找不到引用的类型库。若要解决此错误，请确保所有类型库和引用的类型库都是可用于编译器。下面的示例生成 C3510: The following sample generates C3510: 假定以下两个类型库生成，并且 C3510a.tlb 已被删除或不在路径。 Assume that the following two type libraries were built, and that C3510a.tlb was deleted or not on the path. // C3510a.idl  
[uuid("f87070ba-c6d9-405c-a8e4-8cd9ca25c12b")]  
library C3510aLib  
{  
   [uuid("f87070ba-c6d9-405c-a8e4-8cd9ca25c12c")]  
   enum E_C3510  
   {  
      one, two, three  
   };  
}; 然后第二个类型库的源代码： And then the source code for the second type library: // C3510b.idl  
// post-build command: del /f C3510a.tlb  
[uuid("f87070ba-c6d9-405c-a8e4-8cd9ca25c12e")]  
library C3510bLib  
{  
   importlib ("C3510a.tlb");  
   [uuid("f87070ba-c6d9-405c-a8e4-8cd9ca25c12d")]  
   struct S_C3510 {  
      enum E_C3510 e;  
   };  
}; 然后客户端代码： And then the client code: // C3510.cpp  
#import "c3510b.tlb" no_registry auto_search   // C3510  
int main() {  
   C3510aLib::S_C4336 ccc;  
}

编译器错误 C3519 Compiler Error C3519 11
特性的参数无效参数传递到属性，但编译器无法识别的参数。有关允许的唯一参数是和。下面的示例生成 C3519: The following sample generates C3519: // C3519.cpp  
// compile with: /LD  
[module(name="MyLib2")];  
#import "C:\testdir\bin\importlib.tlb" embedded_idl("no_emitidcl")     
// C3519  
#import "C:\testdir\bin\importlib.tlb" embedded_idl("no_emitidl")     
// OK

编译器错误 C3530 Compiler Error C3530 11
不能与任何其他类型说明符组合与使用的类型说明符关键字。更正此错误请勿使用的变量声明中使用的类型说明符关键字。示例下面的示例会产生，因为变量声明两个关键字和类型，而使用编译该示例是因为。请参阅关键字

编译器错误 C3531 Compiler Error C3531 11
：的符号的类型包含必须具有初始值设定项指定的变量不具有初始值设定项表达式。更正此错误指定的声明变量时使用等号语法，一个简单赋值语句之类的初始值设定项表达式。示例下面的示例会产生，因为变量，，和未初始化。请参阅关键字

编译器错误 C3532 Compiler Error C3532 11
用法不正确指明的类型不能用声明关键字。例如，不能使用关键字来声明一个数组或方法返回类型。更正此错误确保初始化表达式结果是有效类型。确保不要声明数组或方法的返回类型。示例下面的示例会产生，因为关键字不能声明方法的返回类型。示例下面的示例会产生，因为关键字不能声明数组。请参阅关键字

编译器错误 C3533 Compiler Error C3533 11
参数不能具有包含的类型方法或模板的参数不能用声明关键字如果默认值编译器选项将生效。更正此错误删除从参数声明的关键字。示例下面的示例会产生，因为它声明的函数参数关键字和它进行编译的。示例下面的示例会产生，因为它声明的模板参数关键字和它进行。请参阅关键字（推导变量类型）

编译器错误 C3535 Compiler Error C3535 11
无法推导出的类型从声明的变量的类型无法从初始化表达式的类型推导关键字。例如，此错误发生的初始化表达式的计算结果为，这不是类型。更正此错误确保初始化表达式的类型不是。确保声明不是指向基本类型的指针。有关详细信息，请参阅基本类型。请确保如果该声明是指向类型的指针，初始化表达式是指针类型。示例下面的示例会产生，因为初始化表达式的计算结果为。示例下面的示例会产生，因为该语句声明变量作为指向推导出的类型，但初始值设定项的类型的表达式进行双。因此，推导变量类型。示例下面的示例会产生，因为变量声明指针指向推导出的类型，但初始化表达式不是指针类型。请参阅关键字基本类型

编译器错误 C3536 Compiler Error C3536 11
：不能在初始化之前在初始化之前，不能使用指定的符号。在实践中，这意味着无法使用变量来初始化自身。更正此错误未初始化变量对其自身。示例下面的示例生成 C3536，因为每个变量初始化与其自身。 The following example yields C3536 because each variable is initialized with itself. // C3536.cpp  
// Compile with /Zc:auto  
int main()  
{  
   auto a = a;     //C3536  
   auto b = &b;    //C3536  
   auto c = c + 1; //C3536  
   auto* d = &d;   //C3536  
   auto& e = e;    //C3536  
   return 0;  
}; 请参阅 See Also auto 关键字 auto Keyword

编译器错误 C3537 Compiler Error C3537 11
：你不能强制转换为包含的类型不能强制转换为指定的类型的变量，因为该类型包含关键字和默认值编译器选项将生效。示例下面的代码会产生，因为变量强制转换为包含的类型关键字。请参阅关键字

编译器错误 C3538 Compiler Error C3538 11
在声明符列表中，“”必须始终推导为同一类型声明列表中的所有已声明变量不解析为同一类型。更正此错误确保列表中的所有声明都推导为同一类型。示例下面的语句生成。每条语句声明多个变量，但关键字的每次使用都不推导为同一类型。请参阅关键字

编译器错误 C3539 Compiler Error C3539 11
：模板自变量不能包含的类型指定的模板自变量类型不能包含的用法关键字。更正此错误未指定模板参数与关键字。示例下面的示例生成 C3539。 The following example yields C3539. // C3539.cpp  
// Compile with /Zc:auto  
template<class T> class C{};  
int main()  
{  
   C<auto> c;   // C3539  
   return 0;  
} 请参阅 See Also auto 关键字 auto Keyword

编译器错误 C3540 Compiler Error C3540 11
：不能应用于包含的类型运算符不能应用于指定的类型，因为它包含说明符。示例下面的示例生成 C3540。 The following example yields C3540. // C3540.cpp  
// Compile with /Zc:auto  
int main() {  
    auto x = 123;  
    sizeof(x);    // OK  
    sizeof(auto); // C3540  
    return 0;  
} 请参阅 See Also auto 关键字 auto Keyword /Zc: auto （推导变量类型） /Zc:auto (Deduce Variable Type) sizeof 运算符 sizeof Operator

编译器错误 C3541 Compiler Error C3541 11
不能应用于包含的类型运算符不能应用于指定的类型，因为它包含说明符。示例下面的示例生成 C3541。 The following example yields C3541. // C3541.cpp  
// Compile with /Zc:auto  
#include <typeinfo>  
int main() {  
    auto x = 123;  
    typeid(x);    // OK  
    typeid(auto); // C3541  
    return 0;  
} 请参阅 See Also auto 关键字 auto Keyword /Zc: auto （推导变量类型） /Zc:auto (Deduce Variable Type) typeid typeid

编译器错误 C3550 Compiler Error C3550 11
此上下文只允许纯“”如果用作函数的返回类型的占位符，则它必须被其自身使用。它无法用作指针声明、引用声明或其他此类限定的一部分。请参阅

编译器错误 C3551 Compiler Error C3551 11
“应为后期指定的返回类型”如果你使用关键字作为函数返回类型的占位符，必须提供后指定返回类型。在下面的示例中，函数的后期指定返回类型是一个指针，该指针指向由四个类型的元素组成的数组。请参阅

编译器错误 C3552 Compiler Error C3552 11
“”后指定返回类型不能包含“”如果你使用关键字作为函数返回类型的占位符，必须提供后指定返回类型。但是，不能使用其他关键字来指定后指定返回类型。例如，下述代码片段产生错误。

编译器错误 C3553 Compiler Error C3553 11
应为表达式而不是类型关键字要求使用表达式作为参数，而非类型的名称。例如，以下代码片段中的最后一个语句生成错误。

编译器错误 C3554 Compiler Error C3554 11
“”不能与任何其他类型说明符组合不可用任何类型说明符来限定关键字。例如，下述代码片段产生错误。

编译器错误 C3555 Compiler Error C3555 11
“”的参数不正确自变量表达式类型说明符不是有效的表达式。不大可能发生。如果编译器发出，可能是因为发生了内部编译器错误。请参阅编译器错误错误

编译器错误 C3556 Compiler Error C3556 11
表达式的参数不正确编译器无法推导作为类型说明符参数的表达式的类型。示例在下面的代码示例中，编译器无法推导参数的类型，因为会进行重载。若要解决此问题，无法使用来创建一个指向特定实例重载函数中指定表达式。

编译器错误 C3603 Compiler Error C3603 11
：类型尚不支持你尝试使用托管对象的运行时尚不支持的数据类型。

编译器错误 C3609 Compiler Error C3609 11
“成员”：密封的或最终函数必须是虚拟函数密封和最终关键字标记的类、结构或成员函数上只允许。以下示例生成：

编译器错误 C3610 Compiler Error C3610 11
：在调用方法之前必须将值类型装箱默认情况下，值类型不是托管堆上。你可以调用的方法从运行时类，如之前，你需要将值类型移至托管堆。才可访问使用过时的编译器选项。

编译器错误 C3611 Compiler Error C3611 11
：密封的函数不能有纯说明符未正确声明密封的函数。有关详细信息，请参阅密封。示例下面的示例生成 C3611。 The following sample generates C3611. // C3611.cpp  
// compile with: /clr /c  

ref struct V {  
   virtual void Test() sealed = 0;   // C3611  
   virtual void Test2() sealed;   // OK  
   virtual void Test3() = 0;   // OK  
};

编译器错误 C3612 Compiler Error C3612 11
：密封的类不能是抽象使用定义的类型默认情况下，都密封的而类是抽象的除非它实现其基类的所有方法。密封的抽象类可以既不是基类，也可以将它实例化。有关详细信息，请参阅类和结构。示例下面的示例生成 C3612: The following sample generates C3612: // C3612.cpp  
// compile with: /clr /c  
value struct V: public System::ICloneable {};   // C3612  

// OK  
value struct V2: public System::ICloneable {  
   Object^ Clone();  
};

编译器错误 C3618 Compiler Error C3618 11
：不能定义标记的方法方法标记为定义中指定。。示例下面的示例生成 C3618。 The following sample generates C3618. // C3618.cpp  
// compile with: /clr /c  
using namespace System;  
using namespace System::Runtime::InteropServices;  

[ DllImport("user32.dll", EntryPoint="MessageBox", CharSet=CharSet::Ansi) ]  // CHANGED   
void Func();   

void Func() {}   // C3618, remove this function definition to resolve

编译器错误 C3619 Compiler Error C3619 11
不能在托管或类型中声明模板不允许在托管或类或接口使用类模板。才可访问使用过时的编译器选项。

编译器错误 C3622 Compiler Error C3622 11
类声明为不能实例化尝试实例化类标记为抽象。一个类标记为可以是基类，但它不能实例化。示例下面的示例生成 C3622。 The following sample generates C3622. // C3622.cpp  
// compile with: /clr  
ref class a abstract {};  

int main() {  
   a aa;   // C3622  
}

编译器错误 C3623 Compiler Error C3623 11
“”托管或类型中不支持位域不允许在托管或类的变量上使用位域。以下示例生成：

编译器错误 C3624 Compiler Error C3624 11
：使用此类型需要对程序集的引用未指定编译你的代码所需的程序集（引用）传递到程序集指令。示例下面的示例生成 C3624: The following sample generates C3624: // C3624.cpp  
// compile with: /clr /c  
#using <System.Windows.Forms.dll>  

// Uncomment the following 2 lines to resolve.  
// #using <System.dll>  
// #using <System.Drawing.dll>  

using namespace System;  

public ref class MyForm : public Windows::Forms::Form {};   // C3624

编译器错误 C3625 Compiler Error C3625 11
“”：本机类型不能从托管或类型“”派生本机类不能从托管或类继承。有关详细信息，请参阅类和结构。示例以下示例生成：

编译器错误 C3626 Compiler Error C3626 11
关键字只能在接口、成员函数和都是指向委托的数据成员未正确使用一个关键字。下面的示例生成 C3626: The following sample generates C3626: // C3626.cpp  
// compile with: /c  
struct A {  
   __event int i;   // C3626  
// try the following line instead  
// __event int i();  
};

编译器错误 C3627 Compiler Error C3627 11
进行装箱值类型只有值类型可以进行装箱。

编译器错误 C3628 Compiler Error C3628 11
：托管或仅支持公共继承尝试使用托管或类用作私有或保护基类。托管数组或类只能用作基类与公共访问。下面的示例生成 C3628，并演示如何修复此错误： The following sample generates C3628 and shows how to fix it: // C3628a.cpp  
// compile with: /clr  
ref class B {  
};  

ref class D : private B {   // C3628  

// The following line resolves the error.  
// ref class D : public B {  
};  

int main() {  
}

编译器错误 C3630 Compiler Error C3630 11
错误处理标记时无法处理在源代码中的令牌。

编译器错误 C3631 Compiler Error C3631 11
“函数”：无法重载托管事件或事件无法重载托管事件或事件。才可访问使用过时的编译器选项。

编译器错误 C3632 Compiler Error C3632 11
：非法样式事件构造声明并非在所有构造中有效。才可访问使用过时的编译器选项。

编译器错误 C3633 Compiler Error C3633 11
不能定义为托管的的成员引用类数据成员不能是非类型。仅可以实例化本机类型中的类型。例如，类型不能包含复制构造函数或赋值运算符。示例下面的示例生成 C3633。 The following sample generates C3633. // C3633.cpp  
// compile with: /clr /c  
#pragma warning( disable : 4368 )  

class A1 {  
public:  
   A1() { II = 0; }  
   int II;  
};  

ref class B {  
public:  
   A1 a1;   // C3633  
   A1 * a2;   // OK  
   B() : a2( new A1 ) {}  
    ~B() { delete a2; }  
};

编译器错误 C3634 Compiler Error C3634 11
：不能定义托管或的一个抽象方法可在托管或类中声明一个抽象方法，但不能定义它。示例以下示例生成：

编译器错误 C3637 Compiler Error C3637 11
：友元函数定义不能为函数类型的专用化友元函数已定义为模板或泛型的不正确。下面的示例生成 C3637: The following sample generates C3637: // C3637.cpp  
template <class T>  
void f();  

struct S {  
   friend void f<int>() {}   // C3637  
}; 可能的解决方法： Possible resolution: // C3637b.cpp  
// compile with: /c  
template <class T>  
void f();  

struct S {  
   friend void f() {}  
}; 使用泛型时，也可能发生 C3637: C3637 can also occur when using generics: // C3637c.cpp  
// compile with: /clr  

generic <class T>  
void gf();  

struct S {  
   friend void gf<int>() {}   // C3637  
}; 可能的解决方法： Possible resolution: // C3637d.cpp  
// compile with: /clr /c  
generic <class T>  
void gf();  

struct S {  
   friend void gf() {}  
};

编译器错误 C3638 Compiler Error C3638 11
：不能重新定义的标准装箱和取消装箱转换运算符编译器定义的转换运算符为每个托管类以支持隐式装箱。此运算符不能重新定义。有关详细信息，请参阅隐式装箱。下面的示例生成 C3638: The following sample generates C3638: // C3638.cpp  
// compile with: /clr  
value struct V {  
   V(){}  
   static operator V^(V);   // C3638  
};  

int main() {  
   V myV;  
   V ^ pmyV = myV;   // operator supports implicit boxing  
}

编译器错误 C3640 Compiler Error C3640 11
：必须定义的本地类的引用或虚拟成员函数编译器需要定义某些功能。下面的示例生成 C3640: The following sample generates C3640: // C3640.cpp  
void f()   
{  
   struct S  
   {  
      virtual void f1();   // C3640  
      // Try the following line instead:  
      // virtual void f1(){}  
   };  
}

编译器错误 C3641 Compiler Error C3641 11
：无效的使用编译的函数调用约定或和编译器选项在中已弃用。仅调用约定允许使用。下面的示例生成 C3641: The following sample generates C3641: // C3641.cpp  
// compile with: /clr:pure /c  
void __cdecl f() {}   // C3641

编译器错误 C3642 Compiler Error C3642 11
参数：无法从本机代码调用约定的与调用函数将标有一个函数调用约定不能从本机（非托管）代码调用。是函数的名称或的一种尝试调用的函数。通过函数指针进行调用时，使用的类型。若要从本地上下文调用托管的函数，你可以添加将调用包装器函数函数。或者，你可以使用封送处理机制请参阅：封送函数指针使用有关详细信息。下面的示例生成 C3642: The following sample generates C3642: // C3642.cpp  
// compile with: /clr  
using namespace System;  
struct S {  
   void Test(String ^ s) {   // CLR type in signature, implicitly __clrcall  
      Console::WriteLine(s);  
   }  
   void Test2(char * s) {  
      Test(gcnew String(s));  
   }  
};  

#pragma unmanaged  
int main() {  
   S s;  
   s.Test("abc");   // C3642  
   s.Test2("abc");   // OK  
}

编译器错误 C3644 Compiler Error C3644 11
：无法编译将生成托管的代码的函数在函数中的某些关键字的存在将导致要编译到本机的函数。下面的示例生成 C3644: The following sample generates C3644: // C3644.cpp  
// compile with: /clr  
// processor: x86  

void __clrcall Func2(int i) {  
   __asm {}   // C3644  
}

编译器错误 C3645 Compiler Error C3645 11
不能用于函数编译为本机代码在函数中的某些关键字的存在将导致要编译到本机的函数。示例下面的示例生成 C3645。 The following sample generates C3645. // C3645.cpp  
// compile with: /clr /c  
#pragma unmanaged   
int __clrcall dog() {}   // C3645

编译器错误 C3646 Compiler Error C3646 11
：未知的重写说明符编译器在其中它需要查找重写说明符，但令牌不由编译器识别出的位置中找到一个令牌。有关详细信息，请参阅重写说明符。下面的示例生成 C3646: The following sample generates C3646: // C3646.cpp  
// compile with: /clr /c  
ref class C {  
   void f() unknown;   // C3646  
   // try the following line instead  
   // virtual void f() abstract;  
};

编译器错误 C3648 Compiler Error C3648 11
此显式重写语法要求在编译的最新的托管语法时，编译器找到显式重写对于以前的版本不再受支持的语法。有关详细信息，请参阅显式重写。示例下面的示例生成 C3648: The following sample generates C3648: // C3648.cpp  
// compile with: /clr  
public interface struct I {  
   void f();  
};  

public ref struct R : I {  
   virtual void I::f() {}   // C3648  
   // try the following line instead  
   // virtual void f() = I::f{}  
};

编译器错误 C3650 Compiler Error C3650 11
：不能用作显式重写，必须为基类的虚拟成员函数尝试在不是虚拟成员上执行显式重写。有关详细信息，请参阅显式重写。下面的示例生成 C3650: The following sample generates C3650: // C3650.cpp  
// compile with: /clr  
public interface struct I {  
   void a();  
};  

public ref class S {  
public:  
   static int f() { return 0; }  
   static int g() { return 0; }  
};  

public ref struct T1 : public S, I {  
   virtual int f() new sealed = S::f;   // C3650  
   virtual int g() { return 0; }   // OK does not override S::g  
   virtual void a() new sealed = I::a {}   // OK  
};

编译器错误 C3651 Compiler Error C3651 11
：不能用作显式重写，必须是基类的成员指定显式重写，但不是基类型的类型中已被重写的函数。有关详细信息，请参阅显式重写。下面的示例生成 C3651: The following sample generates C3651: // C3651.cpp  
// compile with: /clr /c  
ref class C {  
public:  
   virtual void func2();  
};  

ref class Other {  
public:  
   virtual void func();  
};  

ref class D : public C {  
public:  
   virtual void func() new sealed = Other::func;   // C3651  
   virtual void func2() new sealed = C::func2;   // OK  
};

编译器错误 C3652 Compiler Error C3652 11
重写：显式重写的函数必须是虚拟的一个不显式重写函数必须是虚拟的。有关详细信息，请参阅显式重写。下面的示例生成 C3652: The following sample generates C3652: // C3652.cpp  
// compile with: /clr /c  
public interface class I {  
   void f();  
};  

public ref struct R : I {  
   void f() = I::f {}   // C3652  
   // try the following line instead  
   // virtual void f() = I::f {}  
};

编译器错误 C3653 Compiler Error C3653 11
：不能用作命名重写：重写未找到函数是否忘记使用显式命名函数运算符？显式重写指定未在任何接口中找到的函数。有关详细信息，请参阅显式重写。下面的示例生成 C3653: The following sample generates C3653: // C3653.cpp  
// compile with: /clr  
public interface struct I {  
   void h();  
};  

public ref struct X : public I {  
   virtual void f() new sealed = J {};   // C3653 no J in scope  
   virtual void g() {}   // OK  
   virtual void h() new sealed = I::h {};   // OK  
};

编译器错误 C3654 Compiler Error C3654 11
文本：显式重写中的语法错误显式重写中有意外的字符串。有关详细信息，请参阅显式重写。下面的示例生成 C3654: The following sample generates C3654: // C3654.cpp  
// compile with: /clr /c  
public ref struct B {  
   virtual void f() = 0;  
   virtual void g() = 0;  
   virtual void h() = 0;  
};  

public ref struct Q : B {  
   virtual void f() = B::f, 3 {}   // C3654  
   // try the following line instead  
   // virtual void g() = B::g, B::h {}  
};

编译器错误 C3655 Compiler Error C3655 11
：函数已显式重写可以仅显式重写函数一次。有关详细信息，请参阅显式重写。下面的示例生成 C3655: The following sample generates C3655: // C3655.cpp  
// compile with: /clr /c  
public ref struct B {  
   virtual void f();  
   virtual void g();  
};  

public ref struct D : B {  
   virtual void f() new sealed = B::f;  
   virtual void g() new sealed = B::f;   // C3655  
   // try the following line instead  
   // virtual void g() new sealed = B::g;  
};

编译器错误 C3656 Compiler Error C3656 11
重写：重写说明符不能重复显式重写关键字只能指定一次。有关详细信息，请参阅显式重写。下面的示例生成 C3656: The following sample generates C3656: // C3656.cpp  
// compile with: /clr /c  
public interface struct O {  
   int f();  
};  

public ref struct V : O {  
   int f() override override { return 0; }   // C3656  
   // try the following line instead  
   // int f() override { return 0; }  
};

编译器错误 C3657 Compiler Error C3657 11
析构函数不能显式重写或被显式重写析构函数或终结器不能显式重写。有关详细信息，请参阅显式重写。示例下面的示例生成 C3657。 The following sample generates C3657. // C3657.cpp  
// compile with: /clr  
public ref struct I {  
   virtual ~I() { }  
   virtual void a();  
};  

public ref struct D : I {  
   virtual ~D() = I::~I {}   // C3657  
   virtual void a() = I::a {}   // OK  
};

编译器错误 C3661 Compiler Error C3661 11
显式重写列表未找到要重写任何方法显式重写指定一个或多个类型名称。但是，没有具有所需匹配重写函数的签名的类型中的任何函数。如果你尝试重写基于类型名称，与重写的函数的签名匹配的指定类型中必须有一个或多个虚函数。有关详细信息，请参阅显式重写。

编译器错误 C3662 Compiler Error C3662 11
“”：重写说明符“”只允许在托管类或类的成员函数上使用不允许在本机类型的成员上使用重写说明符。有关详细信息，请参阅显式重写。示例下面的示例生成 C3662。 The following sample generates C3662. // C3662.cpp  
// compile with: /clr /c  
struct S {  
   virtual void f();  
};  

struct S1 : S {  
   virtual void f() new;   // C3662  
};  

ref struct T {  
   virtual void f();  
};  

ref struct T1 : T {  
   virtual void f() new;   // OK  
};

编译器错误 C3665 Compiler Error C3665 11
析构函数：重写说明符不允许对析构函数终结器使用析构函数或终结器上不允许的关键字。例如，无法在析构函数或终结器上请求新的槽。有关详细信息，请参阅显式重写和析构函数和终结器。下面的示例生成 C3665: The following sample generates C3665: // C3665.cpp  
// compile with: /clr  
public ref struct R {  
   virtual ~R() { }  
   virtual void a() { }  
};  

public ref struct S : R {  
   virtual ~S() new {}   // C3665  
   virtual void a() new {}   // OK  
};

编译器错误 C3666 Compiler Error C3666 11
：重写说明符不允许在构造函数重写说明符已用于一个构造函数，而不允许的。有关详细信息，请参阅重写说明符。示例下面的示例生成 C3666。 The following sample generates C3666. // C3666.cpp  
// compile with: /clr /c  
ref struct R {  
   R() new {}   // C3666  
   R(int i) {}   // OK  
};

编译器错误 C3668 Compiler Error C3668 11
：重写说明符替代方法未进行重写任何基类方法尝试重写不存在函数的函数。有关详细信息，请参阅显式重写。示例下面的示例生成 C3668。 The following sample generates C3668. // C3668.cpp  
// compile with: /c  
__interface I {  
   void f(int);   // virtual by default  
};  

class J {  
public:  
   void g(int);  
   virtual void h(int);  
};  

struct R : I,J {  
   virtual void f() override {}   // C3668  
   virtual void f(int) override {}   // OK  

   virtual void g(int) override {}   // C3668  
   virtual void h(int) override {}   // OK  
};

编译器错误 C3669 Compiler Error C3669 11
：重写的说明符替代不允许在静态成员函数或构造函数未正确指定替代。有关详细信息，请参阅显式重写。示例下面的示例生成 C3669。 The following sample generates C3669. // C3669.cpp  
// compile with: /clr  
public ref struct R {  
   R() override {}   // C3669  
};

编译器错误 C3670 Compiler Error C3670 11
重写：不能重写无法访问基类方法替代仅会在其访问级别使其可派生类型中的函数上发生。有关详细信息，请参阅显式重写。下面的示例生成 C3670: The following sample generates C3670: // C3670.cpp  
// compile with: /clr /c  
public ref class C {  
// Uncomment the following line to resolve.  
// public:  
   virtual void g() { }  
};  

public ref class D : public C {  
public:  
   virtual void f() new sealed = C::g {};   // C3670  
};

编译器错误 C3671 Compiler Error C3671 11
：函数不重写使用显式重写语法时，编译器将生成错误，如果函数未重写。请参阅显式重写有关详细信息。示例下面的示例生成 C3671。 The following sample generates C3671. // C3671.cpp  
// compile with: /clr /c  
ref struct S {  
   virtual void f();  
};  

ref struct S1 : S {  
   virtual void f(int) new sealed = S::f;   // C3671  
   virtual void f() new sealed = S::f;  
};

编译器错误 C3672 Compiler Error C3672 11
伪析构函数表达式仅用作函数调用的一部分未正确调用析构函数。有关详细信息，请参阅析构函数。示例下面的示例生成 C3672。 The following sample generates C3672. // C3672.cpp  
template<typename T>  
void f(T* pT) {  
   &pT->T::~T;   // C3672  
   pT->T::~T();   // OK  
};  

int main() {  
   int i;  
   f(&i);  
}

编译器错误 C3673 Compiler Error C3673 11
：类没有复制构造函数用户定义的构造函数需要复制引用类型的对象。有关详细信息，请参阅对于引用类型的堆栈语义。示例下面的示例生成 C3673。 The following sample generates C3673. // C3673.cpp  
// compile with: /clr  
public ref struct R {  
public:  
   R() {}  
   // Uncomment the following line to resolve.  
   // R(R% p) {}  
};  

int main() {  
   R r;  
   R s = r;   // C3673  
} 示例 Example 下面的示例生成 C3673。 The following sample generates C3673. // C3673_b.cpp  
// compile with: /clr /c  
// C3673 expected  
using namespace System;  
[AttributeUsage(AttributeTargets::Class)]  
ref class MyAttr : public Attribute {  
public:  
   MyAttr() {}  
   // Uncomment the following line to resolve.  
   // MyAttr(int i) {}  
   property int Priority;  
   property int Version;  
};  

[MyAttr]   
ref class ClassA {};   // OK, no arguments  

[MyAttr(Priority = 1)]   
ref class ClassB {};   // OK, named argument  

[MyAttr(123)]  
ref class ClassC {};   // Positional argument  

[MyAttr(123, Version = 1)]  
ref class ClassD {};   // Positional and named

编译器错误 C3675 Compiler Error C3675 11
：是保留的因为没有定义属性。在声明简单属性时，编译器将生成和访问器方法，以及那些名称是你的程序的作用域中存在。通过预先计算和到属性名称形成编译器生成的名称。因此，不能声明具有同名的编译器生成的访问器函数。有关更多信息，请参见。示例下面的示例生成 C3675。 The following sample generates C3675. // C3675.cpp  
// compile with: /clr /c  
ref struct C {  
public:  
   property int Size;  
   int get_Size() { return 0; }   // C3675  
};

编译器错误 C3697 Compiler Error C3697 11
限定符：不能使用此限定符跟踪句柄已应用于它未设计为其的限定符。下面的示例生成 C3697: The following sample generates C3697: // C3697.cpp  
// compile with: /clr  
using namespace System;  
int main() {  
   String ^__restrict s;   // C3697  
   String ^ s2;   // OK  
}

编译器错误 C3698 Compiler Error C3698 11
：不能将此类型用作参数的未正确声明托管的对象。下面的示例生成了 C3698: The following sample generates C3698: // C3698.cpp  
// compile with: /clr  

int main() {  
   array<int>^a = new array<int>^(20);   // C3698  
   array<int>^a2 = gcnew array<int>(20);   // OK  
}

编译器错误 C3699 Compiler Error C3699 11
：不能使用类型的此间接寻址尝试使用不允许的间接寻址。示例下面的示例生成 C3699。 The following sample generates C3699. // C3699.cpp  
// compile with: /clr /c  
using namespace System;  
int main() {  
   String * s;   // C3699  
   // try the following line instead  
   // String ^ s2;  
} 示例 Example Trivial 属性不能具有引用类型。 A trivial property cannot have reference type. 有关更多信息，请参见 property 。 See property for more information. 下面的示例生成 C3699。 The following sample generates C3699. // C3699_b.cpp  
// compile with: /clr /c  
ref struct C {  
   property System::String % x;   // C3699  
   property System::String ^ y;   // OK  
}; 示例 Example "指向的指针"语法的等价内容是跟踪引用的句柄。 The equivalent of a "pointer to a pointer" syntax is a handle to a tracking reference. 下面的示例生成 C3699。 The following sample generates C3699. // C3699_c.cpp  
// compile with: /clr /c  
using namespace System;  
void Test(String ^^ i);   // C3699  
void Test2(String ^% i);

编译器错误 C3701 Compiler Error C3701 11
具有任何事件你尝试使用上不具有任何事件方法的类。若要解决此错误，请向该类中添加一个或多个事件。下面的示例生成 C3701: The following sample generates C3701: // C3701.cpp  
[ event_source(native) ]  
class CEventSrc {  
public:  
   // uncomment the following line to resolve this C3701  
   // __event void fireEvent(int i);  
};   // C3701  

int main() {  
}

编译器错误 C3702 Compiler Error C3702 11
是所必需的事件你试图使用事件，而不包括必要的标头文件。下面的示例生成 C3702: The following sample generates C3702: // C3702.cpp  
// uncomment the following line to resolve  
// #define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
#include <atlcom.h>  
#include <atlctl.h>  

[module(dll, name=idid, uuid="12341234-1234-1234-1234-123412341234")];  

[object]  
__interface IEvents : IUnknown  
{  
   HRESULT event1([in] int i);  
};  

[dual]  
__interface IBase  
{  
   HRESULT fireEvents();  
};  

[coclass, event_source(com)]  
class CEventSrc : public IBase  
{  
   public:  
   __event __interface IEvents;  

   HRESULT fireEvents()  
   {  
      HRESULT hr = IEvents_event1(123);  
      return hr;  
   }  
};   // C3702  

int main() {  
}

编译器错误 C3703 Compiler Error C3703 11
事件处理程序：事件处理程序方法必须具有相同的存储类作为源事件具有不同的存储类它挂钩的事件处理程序。例如，如果该事件处理程序的静态成员函数和事件不是静态的则会发生此错误。若要修复此错误，给予事件和事件处理程序相同的存储类。下面的示例生成 C3703: The following sample generates C3703: // C3703.cpp  
// C3703 expected  
#include <stdio.h>  

[event_source(type=native)]  
class CEventSrc {  
public:  
   __event static void MyEvent();  
};  

[event_receiver(type=native)]  
class CEventHandler {  
public:  
   // delete the following line to resolve  
   void MyHandler() {}  

   // try the following line instead  
   // static void MyHandler() {}  

   void HookIt(CEventSrc* pSource) {  
      __hook(CEventSrc::MyEvent, pSource, &CEventHandler::MyHandler);  
   }  

   void UnhookIt(CEventSrc* pSource) {  
      __unhook(CEventSrc::MyEvent, pSource, &CEventHandler::MyHandler);  
   }  
};  

int main() {  
   CEventSrc src;  
   CEventHandler hnd;  

   hnd.HookIt(&src);  
   __raise src.MyEvent();  
   hnd.UnhookIt(&src);  
}

编译器错误 C3704 Compiler Error C3704 11
方法不能激发事件你尝试使用方法。若要修复此错误，请替换调用调用下面的代码示例中所示。下面的示例生成 C3704: The following sample generates C3704: // C3704.cpp  
[ event_source(native) ]  
class CEventSrc {  
   public:  
      __event void fireEvent(int i, ...);   // C3704  
      // try the following line instead:  
      // __event void fireEvent(int i);  
};  

int main() {  
}

编译器错误 C3705 Compiler Error C3705 11
：找不到事件接口你必须定义要使用事件的事件接口。请注意，在下面的示例所示的标头文件的行所需的使用事件。若要解决此错误，取消注释的定义示例代码中的接口。下面的示例生成 C3705: The following sample generates C3705: // C3705.cpp  
// compile with: /c  
#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
#include <atlcom.h>  
#include <atlctl.h>  

[module(dll, name="idid", uuid="12341234-1234-1234-1234-123412341234")];  

// Uncomment the following 4 lines to resolve.  
// [object, uuid("00000000-0000-0000-0000-000000000003")]  
// __interface IEvents : IUnknown {  
//    HRESULT event1([in] int i);  
// };  

[dual, uuid("00000000-0000-0000-0000-000000000001")]  
__interface IBase {  
   HRESULT fireEvents();  
};  

[coclass, event_source(com), uuid("00000000-0000-0000-0000-000000000002")]  
class CEventSrc : public IBase {  
public:  
   __event __interface IEvents;   // C3705 uncomment IEvents to resolve  
   HRESULT fireEvents() {  
      HRESULT hr = IEvents_event1(123);  
      return hr;  
   }  
};

编译器错误 C3706 Compiler Error C3706 11
：必须是一个接口激发事件使用激发事件的事件接口必须是接口。在此情况下，接口也应通过使用特性，定义，或使用导入从具有的特性的类型库。请注意，在下面的示例所示的标头文件的行所需的使用事件。若要修复此错误，请（事件接口）接口定义属性的接口通过应用以下项之一：对象，双重，或调度接口。如果接口是从由生成的标头文件中，编译器将无法识别它为接口。下面的示例生成 C3706: The following sample generates C3706: // C3706.cpp  
// compile with: /c  
// C3706 expected  
#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
#include <atlcom.h>  
#include <atlctl.h>  

[module(dll, name="idid", uuid="12341234-1234-1234-1234-123412341234")];  

// Uncomment the following line to resolve.  
// [object, uuid="12341234-1234-1234-1234-123412341237"]  
__interface IEvents : IUnknown {  
   HRESULT event1(/*[in]*/ int i);   // uncomment [in]  
};  

[dual, uuid="12341234-1234-1234-1234-123412341235"]  
__interface IBase {  
   HRESULT fireEvents();  
};  

[coclass, event_source(com), uuid="12341234-1234-1234-1234-123412341236"]  
class CEventSrc : public IBase {  
   public:  
   __event __interface IEvents;  

   HRESULT fireEvents() {  
      HRESULT hr = IEvents_event1(123);  
      return hr;  
   }  
};

编译器错误 C3707 Compiler Error C3707 11
：调度接口方法必须具有一个如果你使用方法，你必须将其分配。若要修复此错误，分配到方法，例如，通过取消注释在下面的示例方法的特性。有关详细信息，请参阅属性调度接口和。下面的示例生成 C3707: The following sample generates C3707: // C3707.cpp  
#include <atlbase.h>  
#include <atlcom.h>  
#include <atlctl.h>  

[module(name="xx")];  
[dispinterface]  
__interface IEvents : IDispatch  
{  
   HRESULT event1([in] int i);   // C3707  
   // try the following line instead  
   // [id(1)] HRESULT event1([in] int i);  
};  

int main() {  
}

编译器错误 C3708 Compiler Error C3708 11
不正确使用必须是兼容的事件源的成员若要声明作为事件的接口，事件声明必须是事件源。下面的示例生成 C3708: The following sample generates C3708: // C3708.cpp  
// compile with: /c  
#define _ATL_ATTRIBUTES 1  
#include "atlbase.h"  
#include "atlcom.h"  

[ module(name="MyLibrary")];  

[ object, uuid("00000000-0000-0000-0000-000000000001") ]  
__interface I {  
   HRESULT func();  
};  

[ object, uuid("00000000-0000-0000-0000-000000000002") ]  
__interface II {  
   HRESULT func();  
};  

__event __interface I;   // C3708  

// put the event in an event source  
[ coclass, event_source(com), uuid("00000000-0000-0000-0000-000000000003") ]  
struct E : II {  
   __event __interface II;  
};

编译器错误 C3709 Compiler Error C3709 11
：不正确的语法指定中事件当指定的事件源或、第一个参数必须是有效的事件方法和第二个参数必须是有效的事件源对象（而不是方法）。下面的示例生成 C3709: The following sample generates C3709: // C3709.cpp  
// compile with: /LD  
[event_source(native)]  
class CEventSrc  
{  
public:  
   __event void event1();  
};  

[event_receiver(native)]  
class CEventRec  
{  
public:  
   void handler1()  
   {  
   }  

   void HookEvents(CEventSrc* pSrc)  
   {  
      __hook(bad, pSrc, CEventRec::handler1);   // C3709  
      // Try the following line instead:  
      // __hook(&CEventSrc::event1, pSrc, CEventRec::handler1);  
   }  

   void UnhookEvents(CEventSrc* pSrc)  
   {  
      __unhook(&CEventSrc::event1, pSrc, CEventRec::handler1);  
   }  
};

编译器错误 C3710 Compiler Error C3710 11
：不正确的语法，用于指定事件处理程序中当你指定事件处理程序替换或，该处理程序必须是有效的方法。示例下面的示例生成 C3710 The following sample generates C3710 // C3710.cpp  
// compile with: /link /opt:noref  
#include <atlbase.h>  
#include <atlcom.h>  
#include <atlctl.h>  
#include <stdio.h>  

[event_source(native)]  
class CEventSrc  
{  
public:  
    __event void event1();  
};  

[event_receiver(native)]  
class CEventRec  
{  
public:  
    void handler1()  
    {  
        printf_s("Executing handler1().\n");  
    }  

    void HookEvents(CEventSrc* pSrc)   
    {  
        __hook(&CEventSrc::event1, pSrc, 0);   // C3710  
        // try the following line instead  
        // __hook(&CEventSrc::event1, pSrc, &CEventRec::handler1);  
    }  

    void UnhookEvents(CEventSrc* pSrc)  
    {  
        __unhook(&CEventSrc::event1, pSrc, &CEventRec::handler1);  
    }  
};  

int main()  
{  
    CEventSrc eventSrc;  
    CEventRec eventRec;  
    eventRec.HookEvents(&eventSrc);  
    eventSrc.event1();  
    eventRec.UnhookEvents(&eventSrc);  
}

编译器错误 C3711 Compiler Error C3711 11
：非托管事件源方法必须返回或整数类型中的事件源的未返回或整型类型定义的方法。若要修复此错误，请在事件和事件处理程序具有返回类型的或整型类型，如或。下面的示例生成 C3711: The following sample generates C3711: // C3711.cpp  
#include <atlbase.h>  
#include <atlcom.h>  
#include <atlctl.h>  

[event_source(native)]  
class CEventSrc {  
public:  
   __event float event1();   // C3711  
   // try the following line instead  
   // __event int event1();  
   // also change the handler, below  
};  

[event_receiver(native)]  
class CEventRec {  
public:  
   float handler1() {         // change float to int  
      return 0.0;             // change 0.0 to 0  
   }  
   void HookEvents(CEventSrc* pSrc) {  
      __hook(CEventSrc::event1, pSrc, CEventRec::handler1);  
   }  
   void UnhookEvents(CEventSrc* pSrc) {  
      __unhook(CEventSrc::event1, pSrc, CEventRec::handler1);  
   }  
};  

int main() {  
}

编译器错误 C3712 Compiler Error C3712 11
：事件处理程序方法必须返回与源相同的类型您定义未返回与源事件方法的类型相同的事件处理程序方法。若要修复此错误，给予事件处理程序方法相同的源事件方法的返回类型。下面的示例生成 C3712: The following sample generates C3712: // C3712.cpp  
// compile with: /c  
[event_source(native)]  
class CEventSrc {  
public:  
   __event void event1();  
};  

[event_receiver(native)]  
class CEventRec {  
public:  
   int handler1() { return 0; }  
   // try the following line instead  
   // void handler1() {}  

   void HookEvents(CEventSrc* pSrc) {  
      __hook(&CEventSrc::event1, pSrc, &CEventRec::handler1);   // C3712  
   }  
   void UnhookEvents(CEventSrc* pSrc) {  
      __unhook(&CEventSrc::event1, pSrc, &CEventRec::handler1);   // C3712  
   }  
};

编译器错误 C3713 Compiler Error C3713 11
：事件处理程序方法必须具有相同的函数参数作为源您定义未使用相同的参数作为源事件方法的事件处理程序方法。若要修复此错误，给予事件处理程序方法与这些源事件方法相同的参数。下面的示例生成 C3713: The following sample generates C3713: // C3713.cpp  
// compile with: /c  
[event_source(native)]  
class CEventSrc {  
public:  
   __event void event1(int nValue);  
   // try the following line instead  
   // __event void event1();  
};  

[event_receiver(native)]  
class CEventRec {  
public:  
   void handler1() {}  

   void HookEvents(CEventSrc* pSrc) {  
      __hook(&CEventSrc::event1, pSrc, &CEventRec::handler1);   // C3713  
   }  

   void UnhookEvents(CEventSrc* pSrc) {  
      __unhook(&CEventSrc::event1, pSrc, &CEventRec::handler1); // C3713  
   }  
};

编译器错误 C3714 Compiler Error C3714 11
：事件处理程序方法必须具有相同的调用约定为源您定义未使用的相同的调用约定作为源事件方法的事件处理程序方法。若要修复此错误，赋予事件处理程序方法与源事件方法的相同的调用约定。例如，在下面的代码中，进行的调用约定和匹配或或其他人。删除调用约定关键字从这两个声明将还解决问题，并导致和默认为调用约定。请参阅调用约定有关详细信息。下面的示例生成 C3714: The following sample generates C3714: // C3714.cpp  
// compile with: /c  
// processor: x86  
[event_source(native)]  
class CEventSrc {  
public:  
   __event void __cdecl event1();  
   // try the following line instead  
   // __event void __stdcall event1();  
};  

[event_receiver(native)]  
class CEventRec {  
public:  
   void __stdcall handler1() {}  

   void HookEvents(CEventSrc* pSrc) {  
      __hook(&CEventSrc::event1, pSrc, &CEventRec::handler1);   // C3714  
   }  

   void UnhookEvents(CEventSrc* pSrc) {  
      __unhook(&CEventSrc::event1, pSrc, &CEventRec::handler1); // C3714  
   }  
};

编译器错误 C3715 Compiler Error C3715 11
指针：必须是指向指定中的指针或包含不指向有效的类。若要解决此错误，请确保你和调用对指定指向有效的类的指针。

编译器错误 C3717 Compiler Error C3717 11
：不能定义激发事件的方法声明包含一个实现的事件方法。方法声明不能有一个定义。若要解决此错误，请确保没有事件方法声明具有定义。例如，在下面的代码中，删除从函数体按注释所示的声明。下面的示例生成 C3717: The following sample generates C3717: // C3717.cpp  
[event_source(native)]  
class CEventSrc {  
public:  
   __event void event1() {   // C3717  
   }  

   // remove definition for event1 and substitute following declaration  
   // __event void event1();  
};  

[event_receiver(native)]  
class CEventRec {  
public:  
   void handler1() {  
   }  

   void HookEvents(CEventSrc* pSrc) {  
      __hook(CEventSrc::event1, pSrc, CEventRec::handler1);  
   }  

   void UnhookEvents(CEventSrc* pSrc) {  
      __unhook(CEventSrc::event1, pSrc, CEventRec::handler1);  
   }  
};  

int main() {  
}

编译器错误 C3718 Compiler Error C3718 11
只能接收类的成员函数的上下文中调用仅可以从接收类中调用。示例下面的示例生成 C3718: The following sample generates C3718: // C3718.cpp  
#define _ATL_ATTRIBUTES 1  
#include "atlbase.h"  
#include "atlcom.h"  

[module(name="test")];  

[object, uuid("00000000-0000-0000-0000-000000000001")]  
__interface I  
{  
    HRESULT f();  
};  

[event_source(com), coclass, uuid("00000000-0000-0000-0000-000000000002")]  
struct E  
{  
    __event __interface I;  
};  

[event_receiver(com)]  
struct R  
{  
    void b()  
    {  
        printf_s("B::bar()\n");   
    }  

    void HookAndRun(E* pE)  
    {  
        __hook(&I::f, pE->GetUnknown(), &R::b);  
        __raise pE->f();  
    }  
};  

int main()  
{  
    CComObject<E>* pE;  
    CComObject<E>::CreateInstance(&pE);  

    __hook(&I::f, pE->GetUnknown(), &R::b, &r);   // C3718  
    __raise pE->f();  
    // try the following lines instead  
    // R r;  
    // r.HookAndRun(pE);  
}

编译器错误 C3719 Compiler Error C3719 11
：接口基于的事件源仅用于事件声明中的非上下文的接口。下面的示例生成 C3719: The following sample generates C3719: // C3719a.cpp  
#define _ATL_ATTRIBUTES 1  
#include "atlbase.h"  
#include "atlcom.h"  

[module(name="MyLibrary", version="1.2", helpfile="MyHelpFile")];  

[object]  
__interface I {  
   HRESULT func1();  
};  

[event_source(native), coclass]  
struct A {  
   __event __interface I;   // C3719  

   // try the following line instead  
   // __event func2();  
};  

int main() {  
} 若要修复此错误，应用 对象 ， 组件类 ， event_source ，和 event_receiver 属性相应地进行在其中使用接口 COM 类的类。 To fix this error, apply the object , coclass , event_source , and event_receiver attributes appropriately to make the classes in which you are using the interface COM classes. 例如: For example: // C3719b.cpp  
#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
#include <atlcom.h>  

[module(name="xx")];  
[object, uuid("00000000-0000-0000-0000-000000000001")]  
__interface I {  
   HRESULT f();  
};  

[coclass, event_source(com) , uuid("00000000-0000-0000-0000-000000000002")]  
struct MyStruct {  
   __event __interface I;  
};  

[event_receiver(com)]  
struct MyStruct2 {  
   void f() {  
   }  
   MyStruct2(I* pB) {  
      __hook(&I::f, pB, &MyStruct2::f);  
   }  
};  

int main()  
{  
}

编译器错误 C3721 Compiler Error C3721 11
签名：事件不兼容的签名未正确声明事件。有关详细信息，请参阅。才可访问使用过时的编译器选项。

编译器错误 C3722 Compiler Error C3722 11
不允许泛型事件编译器仅允许泛型类、结构和函数。有关详细信息，请参阅泛型。下面的示例生成 C3722: The following sample generates C3722: // C3722.cpp  
// compile with: /clr  
generic <typename T>  
public delegate void MyEventHandler(System::Object^ sender, System::EventArgs^ e, T optional);  

generic <class T>  
public ref struct MyButton {  
   generic<typename U>  
   event MyEventHandler<U>^ Click;   // C3722  
};

编译器错误 C3723 Compiler Error C3723 11
：无法解析事件无法解析要调用的事件。下面的示例生成 C3723: The following sample generates C3723: // C3723.cpp  
struct A {  
   // To resolve, comment void f(int); and uncomment the __event function  
   void f(int);  
   // __event void f(int);  
   void f(float);  

};  

struct B {  
   void g(int);  
   B(A* a) {  
   __hook(&A::f, a, &B::g);   // C3723  
   }  
};  

int main() {  
} __hook 和 __unhook 与 /clr 编程不兼容。 __hook and __unhook are not compatible with /clr programming. 改为使用 + = 和-= 运算符。 Use the += and -= operators instead. 下面的示例生成 C3723: The following sample generates C3723: // C3723b.cpp  
// compile with: /clr  
using namespace System;  

public delegate void delegate1();  

public ref class CPSource {  
public:  
   event delegate1^ event1;  
};  

public ref class CReceiver {  
public:  
   void Handler1() {  
   }  

   void UnhookAll(CPSource^ pSrc) {  
      __unhook(&CPSource::event1, pSrc, &CReceiver::Handler1); // C3723  
      // Try the following line instead.  
      // pSrc->event1 -= gcnew delegate1(this, &CReceiver::Handler1);  
   }  
};  

int main() {  
}

编译器错误 C3724 Compiler Error C3724 11
必须若要使用多线程处理使用事件文件是必需的如果你使用多线程处理使用事件。若要修复此错误，将添加到接收方定义的哪些事件源和事件中的文件的顶部。

编译器错误 C3727 Compiler Error C3727 11
：托管的事件必须是成员函数或是指向委托的指针的数据成员事件必须是指向委托类型的指针。

编译器错误 C3728 Compiler Error C3728 11
：事件不具有引发方法使用一种语言，创建的元数据，如中，不允许在定义它在类外部从引发事件，不包括指令，而是使用尝试的编程的程序引发事件。若要引发事件如语言开发的程序中，包含事件的类需要还定义引发事件的公共方法。

编译器错误 C3731 Compiler Error C3731 11
不兼容事件和处理程序事件源和事件处理程序必须是同一类型事件源和事件接收器必须具有相同的类型（例如与类型）。若要修复此错误，请事件源和事件处理程序匹配的类型。下面的示例生成 C3731: The following sample generates C3731: // C3731.cpp  
// compile with: /clr  
#using <mscorlib.dll>  
[event_source(native)]  
struct A {  
   __event void MyEvent();  
};  

[event_receiver(managed)]  
// try the following line instead  
// [event_receiver(native)]  
struct B {  
   void func();  
   B(A a) {  
      __hook(&A::MyEvent, &a, &B::func);   // C3731  
   }  
};  

int main() {  
}

编译器错误 C3732 Compiler Error C3732 11
：不能从继承自定义接口激发事件支持事件的接口不能继承自。有关详细信息，请参阅中的事件处理。以下的错误生成

编译器错误 C3733 Compiler Error C3733 11
：用于指定的事件不正确的语法是否忘记了？为事件时使用的错误的语法。若要修复此错误，更改的事件类型或更正语法，使符合事件的规则。下面的示例生成 C3733: The following sample generates C3733: #define _ATL_ATTRIBUTES 1  
#include "atlbase.h"  
#include "atlcom.h"  

[coclass, event_source(com), // change 'com' to 'native' to resolve  
uuid("00000000-0000-0000-0000-000000000001")]  
class A  
{  
   __event void func();   // C3733  
};  

int main()  
{  
}

编译器错误 C3734 Compiler Error C3734 11
“”托管或类不能是组件类组件类属性不能用于托管或类。下面的示例生成 C3734，并演示如何修复此错误： The following sample generates C3734 and shows how to fix it: // C3734.cpp  
// compile with: /clr /c  
[module(name="x")];  

[coclass]  
ref class CMyClass {   // C3734 remove the ref keyword to resolve  
};

编译器错误 C3736 Compiler Error C3736 11
：必须是一种方法，或在托管事件中（可选）的数据成员本机和事件必须是方法。事件也可以是数据成员。下面的示例生成 C3736: The following sample generates C3736: // C3736.cpp  
struct A {  
   __event int e();  
};  

struct B {  
   int f;   // C3736  
   // The following line resolves the error.  
   // int f();  
   B(A* a) {  
      __hook(&A::e, a, &B::f);  
   }  
};  

int main() {  
}

编译器错误 C3737 Compiler Error C3737 11
：委托可能没有显式调用约定不能指定调用约定为。示例下面的示例生成 C3737: The following sample generates C3737: // C3737a.cpp  
// compile with: /clr  
delegate void __stdcall MyFunc();   // C3737  
// Try the following line instead.  
// delegate void MyFunc();  

int main() {  
}

编译器错误 C3738 Compiler Error C3738 11
：显式实例化的调用约定必须匹配的实例化的模板建议你不要指定的调用约定上的显式实例化。如果你必须不过，必须匹配调用约定。示例下面的示例生成 C3738。 The following sample generates C3738. // C3738.cpp  
// compile with: /clr  
// processor: x86  
#include <stdio.h>  
template< class T >  
void f ( T arg ) {   // by default calling convention is __cdecl  
   printf ( "f: %s\n", __FUNCSIG__ );  
}  

template   
void __stdcall f< int > ( int arg );   // C3738  
// try the following line instead  
// void f< int > ( int arg );  

int main () {  
   f(1);  
   f< int > ( 1 );  
}

编译器错误 C3739 Compiler Error C3739 11
参数为时，仅支持语法你尝试以挂钩整个事件的接口，但上属性不为必须将一个事件挂钩一次。下面的示例生成 C3739: The following sample generates C3739: // C3739.cpp  
struct A  
{  
   __event void e();  
};  

// event_receiver is implied  
// [ event_receiver(layout_dependent=false)]  

// use the following line instead  
// [event_receiver(com, layout_dependent=true), coclass ]  
struct B  
{  
   void f();  
   B(A* a)  
   {  
      __hook(A, a, &B::f);   // C3739  
      // use the following line instead to hook a single event  
      // __hook(&A::e, a, &B::f);  
   }  
};  

int main()  
{  
}

编译器错误 C3740 Compiler Error C3740 11
模板不能发出或接收事件模板类或结构不能包含事件。下面的示例生成 C3740: The following sample generates C3740: // C3740.cpp  
template <typename T>   // Delete the template specification  
struct E {  
   __event void f();   // C3740  
};  

int main() {  
}

编译器错误 C3741 Compiler Error C3741 11
：必须能是组件类时参数当为类，则类还必须具有组件类属性。下面的示例生成 C3741 The following sample generates C3741 // C3741.cpp  
// compile with: /c  
// C3741 expected  
#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
#include <atlcom.h>  
[module(name="xx")];  

[object, uuid("00000000-0000-0000-0000-000000000001")]  
__interface I{ HRESULT f(); };  

// Delete the following line to resolve.  
[ event_receiver(com, layout_dependent=true)]  

// class or struct must be declared with coclass  
// Uncomment the following line to resolve.  
// [ event_receiver(com, layout_dependent=true), coclass, uuid("00000000-0000-0000-0000-000000000002")]  
struct R : I {  
   HRESULT f(){ return 0; }  
   R(){}  
   R(I* a){ __hook(I, a); }  
};

编译器错误 C3743 Compiler Error C3743 11
可以仅挂钩解除挂钩整个接口参数为时函数在它传递给的值将基于的参数的数目会有所不同中的参数类。下面的示例生成 C3743: The following sample generates C3743: // C3743.cpp  
#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
#include <atlcom.h>  
[module(name="xx")];  
[object] __interface I { HRESULT f(); };  

[event_receiver(com, layout_dependent=true), coclass]  
struct R : I {  
        HRESULT f() {  
      return 0;  
   }  
        R() {  
   }  

   R(I* a) {  
      __hook(I, a, &R::f);   // C3743  
      // The following line resolves the error.  
      // __hook(I, a);  
   }  
};

编译器错误 C3744 Compiler Error C3744 11
必须具有针对托管事件至少个自变量函数必须采用三个参数在托管扩展编译的程序中使用时。和与编程不兼容。改为使用和运算符。才可访问使用过时的编译器选项。

编译器错误 C3745 Compiler Error C3745 11
：只有事件可以被引发仅与定义的函数关键字可以传递给关键字。下面的示例生成 C3745: The following sample generates C3745: // C3745.cpp  
struct E {  
   __event void func();  
   void func(int) {  
   }  

   void func2() {  
   }  

   void bar() {  
      __raise func();  
      __raise func(1);   // C3745  
      __raise func2();   // C3745  
   }  
};  

int main() {  
   E e;  
   __raise e.func();  
   __raise e.func(1);   // C3745  
   __raise e.func2();   // C3745  
}

编译器错误 C3747 Compiler Error C3747 11
缺少默认的类型参数：参数使用默认值的泛型或模板参数不能跟在参数列表中没有默认值的参数。下面的示例生成 C3747: The following sample generates C3747: // C3747.cpp  
template <class T1 = int, class T2>   // C3747  
struct MyStruct {}; 可能的解决方法： Possible resolution: // C3747b.cpp  
// compile with: /c  
template <class T1, class T2 = int>  
struct MyStruct {};

编译器错误 C3748 Compiler Error C3748 11
：托管的接口可能不会激发事件关键字不能出现在接口内。下面的示例生成 C3748: The following sample generates C3748: // C3748.cpp  
__interface I {  
// try the following line instead  
// struct I {  
   __event void f();   // C3748  
};  

int main() {  
}

编译器错误 C3749 Compiler Error C3749 11
：不能在函数内使用的自定义特性不能在函数内使用的自定义特性。自定义特性的详细信息，请参阅主题属性。示例下面的示例生成 C3749: The following sample generates C3749: // C3749a.cpp  
// compile with: /clr /c  
using namespace System;  

[AttributeUsage(AttributeTargets::All)]  
public ref struct ABC : public Attribute {  
   ABC() {}  
};  

void f1() { [ABC]; };  // C3749

编译器错误 C3752 Compiler Error C3752 11
属性类：不能将属性不应在此上下文中未正确应用用户定义的特性。

编译器错误 C3753 Compiler Error C3753 11
不允许泛型属性。泛型参数列表只能出现在托管的类、结构或函数。有关详细信息，请参阅泛型和属性。示例下面的示例生成 C3753。 The following sample generates C3753. // C3753.cpp  
// compile with: /clr /c  
ref struct A {  
   generic <typename T>  
   property int i;   // C3753 error  
};

编译器错误 C3754 Compiler Error C3754 11
委托构造函数：不能在类型的实例上调用成员函数通过为某种类型的值不包含函数指针的函数进行调用。示例下面的示例生成 C3754: The following sample generates C3754: // C3754a.cpp  
// compile with: /clr  
using namespace System;  

delegate void MyDel();  

interface class MyInterface {};  

ref struct MyClass : MyInterface {  
   void f() {}  
};  

int main() {  
   MyInterface^ p = gcnew MyClass;  
   MyDel^ q = gcnew MyDel(p, &MyClass::f);   // C3754  
   // try the following line instead  
//   MyDel^ q = gcnew MyDel(safe_cast<MyClass^>(p), &MyClass::f);  
}

编译器错误 C3755 Compiler Error C3755 11
：不能定义委托委托（组件扩展）可以声明但未定义。示例下面的示例生成 C3755。 The following sample generates C3755. // C3755.cpp  
// compile with: /clr /c  
delegate void MyDel() {};   // C3755 示例 Example 如果你尝试创建委托模板，也会发生 C3755。 C3755 can also occur if you attempt to create a delegate template. 下面的示例生成 C3755。 The following sample generates C3755. // C3755_b.cpp  
// compile with: /clr /c  
ref struct R {  
   template<class T>  
   delegate void D(int) {}   // C3755  
};

编译器错误 C3761 Compiler Error C3761 11
只能出现在函数的最后一个参数属性未在列表中的最后一个参数的函数参数上使用。下面的示例生成 C3761: The following sample generates C3761: // C3761.cpp  
#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
#include <atlcom.h>  

[ module(name=test) ];  

[dispinterface]  
__interface I  
{  
   [id(1)] HRESULT func([out, retval] int* i, [in] int j);  
   // try the following line instead  
   // [id(1)] HRESULT func([in] int i, [out, retval] int* j);  
};  

[coclass]  
struct C : I {   // C3761  
   HRESULT func(int* i, int j)  
   // try the following line instead  
   // HRESULT func(int j, int* i)  
   {  
      return S_OK;  
   }  
};  

int main()  
{  
}

编译器错误 C3762 Compiler Error C3762 11
无法处理特性继承自的用户定义的特性用于定义的安全特性。这样一个属性不能使用相同的程序集中定义它。

编译器错误 C3763 Compiler Error C3763 11
和只能出现在数据指针类型出或特性只能出现在参数的类型指针。或者删除该特性，或者创建的参数的类型指针。下面的示例生成 C3763: The following sample generates C3763: // C3763.cpp  
#define _ATL_ATTRIBUTES 1  
#include <atlbase.h>  
#include <atlplus.h>  
#include <atlcom.h>  

[ module(name=test) ];  

[ dispinterface, uuid("00000000-0000-0000-0000-000000000001") ]  
__interface IF84 : IDispatch  
{  
   [id(0x00000002)]HRESULT m2([out]unsigned char);  
};  

[ coclass, uuid("00000000-0000-0000-0000-000000000002") ]  
class CF84 : public IF84  
{   // C3763  
public:  
   HRESULT __stdcall m2(unsigned char i)  
   {  
      return S_OK;  
   }  
};  

int main()  
{  
}

编译器错误 C3764 Compiler Error C3764 11
：不能重写基类方法编译器检测到的格式不正确的重写。例如，基类函数未。有关详细信息，请参阅重写。示例下面的示例生成 C3764。 The following sample generates C3764. // C3764.cpp  
// compile with: /clr /c  
public ref struct A {  
   void g(int);  
   virtual void h(int);  
};  

public ref struct B : A {  
   virtual void g(int) override {}   // C3764  
   virtual void h(int) override {}   // OK  
}; 示例 Example C3764 基类方法既显式时也会发生和名为重写。 C3764 can also occur when a base class method is both explicitly and named overridden. 下面的示例生成 C3764。 The following sample generates C3764. // C3764_b.cpp  
// compile with: /clr /c  
ref struct A {  
   virtual void Test() {}  
};  

ref struct B : public A {  
   virtual void Test() override {}  
   virtual void Test2() = A::Test {}   // C3764  
};

编译器错误 C3765 Compiler Error C3765 11
：无法在标记为类结构中定义事件如果类用来标记属性，此类不能包含声明。下面的示例生成 C3765: The following sample generates C3765: // C3765.cpp  
[event_receiver(native)]  
struct ER2 {  
   __event void f();   // C3765  
   __event void b(int);   // C3765  
};

编译器错误 C3766 Compiler Error C3766 11
必须提供接口的实现方法从接口继承的类必须实现接口成员。示例下面的示例生成 C3766。 The following sample generates C3766. // C3766.cpp  
// compile with: /clr /c  

delegate void MyDel();  

interface struct IFace {  
   virtual event MyDel ^ E;  
};  

ref struct Class1 : public IFace {};   // C3766  

// OK  
ref struct Class2 : public IFace {  
   virtual event MyDel ^ E {  
      void add(MyDel ^) {}  
      void remove(MyDel ^) {}  
   }  
};

编译器错误 C3767 Compiler Error C3767 11
候选函数不可访问类中定义的友元函数不应被视为已定义，并且可以在全局命名空间范围中声明。它可以但是，找不到由依赖于参数的查找。还可能引起一项重大更改：本机类型现在是在默认情况下私有编译，请参阅键入可见性有关详细信息。示例下面的示例生成 C3767: The following sample generates C3767: // C3767a.cpp  
// compile with: /clr  
using namespace System;  
public delegate void TestDel();  

public ref class MyClass {  
public:  
   static event TestDel^ MyClass_Event;  
};  

public ref class MyClass2 : public MyClass {  
public:  
   void Test() {  
      MyClass^ patient = gcnew MyClass;  
      patient->MyClass_Event();  
    }  
};  

int main() {  
   MyClass^ x = gcnew MyClass;  
   x->MyClass_Event();   // C3767  

   // OK  
   MyClass2^ y = gcnew MyClass2();  
   y->Test();  
}; 下面的示例生成 C3767: The following sample generates C3767: // C3767c.cpp  
// compile with: /clr /c  

ref class Base  {  
protected:  
   void Method() {  
      System::Console::WriteLine("protected");  
   }  
};  

ref class Der : public Base {  
   void Method() {  
      ((Base^)this)->Method();   // C3767  
      // try the following line instead  
      // Base::Method();  
   }  
};

编译器错误 C3768 Compiler Error C3768 11
不能将虚拟函数的地址采用纯托管代码编译器选项在中已弃用。使用编译时，不能采用的虚拟地址函数。示例下面的示例生成 C3768: The following sample generates C3768: // C3768.cpp  
// compile with: /clr:pure  
struct A  
{  
   virtual void f(...);  
};  

int main()  
{  
   &(A::f);   // C3768  
}

编译器错误 C3769 Compiler Error C3769 11
：嵌套的类不能具有同名的立即封闭类嵌套的类不能具有同名的立即封闭类。示例下面的示例生成 C3769。 The following sample generates C3769. // C3769.cpp  
// compile with: /c  
class x {  
   class x {};   // C3769  
   class y {  
      class x{};   // OK  
   };  
};

编译器错误 C3771 Compiler Error C3771 11
“标识符”在最近的命名空间范围内无法找到友元声明无法在当前命名空间中找到指定模板的类模板声明标识符。更正此错误确保在当前命名空间中定义了模板标识符的类模板声明，或模板标识符是完全限定的名称。示例下列代码示例在命名空间中声明一个类模板和函数，但试图在命名空间中声明友元函数模板。请参阅模板

编译器错误 C3772 Compiler Error C3772 11
“”友元模板声明无效声明类模板专用化的友元无效。不能声明一个类模板的显式或部分专用化，也不能在同一语句中声明该专用化的友元。名称占位符标识无效的声明。更正此错误不能声明类模板专用化的友元。如果对应用程序适用，请声明类模板的友元，或声明特定部分专用化或显式专用化的友元。示例下面的代码示例失败，因为它声明的是类模板部分专用化的友元。请参阅模板模板专用化

编译器错误 C3797 Compiler Error C3797 11
重写：事件声明不能重写说明符（应该放在事件添加删除引发方法相反）不能重写具有另一个常用事件的普通事件（而无需显式定义访问器方法的事件）。重写事件必须定义访问器函数使用其行为。有关详细信息，请参阅事件。示例下面的示例生成 C3797。 The following sample generates C3797. // C3797.cpp  
// compile with: /clr /c  
delegate void MyDel();  

ref class Class1 {  
public:  
   virtual event MyDel ^ E;  
};  

ref class Class2 : public Class1 {  
public:  
   virtual event MyDel ^ E override;   // C3797  
};  

// OK  
ref class Class3 : public Class1 {  
public:  
   virtual event MyDel ^ E {  
      void add(MyDel ^ d) override {}  
      void remove(MyDel ^ d) override {}  
   }  
};

编译器错误 C3798 Compiler Error C3798 11
：属性声明不能重写说明符（应能将置于属性改为方法）未正确声明属性。有关详细信息，请参见属性示例下面的示例生成 C3798 The following sample generates C3798 // C3798.cpp  
// compile with: /clr /c  
ref struct A {  
   property int Prop_1 abstract;   // C3798  
   property int Prop_2 sealed;   // C3798  

   // OK  
   property int Prop_3 {  
      virtual int get() abstract;  
      virtual void set(int i) abstract;  
   }  

   property int Prop_4 {  
      virtual int get() sealed;  
      virtual void set(int i) sealed;  
   }  
};

编译器错误 C3799 Compiler Error C3799 11
索引的属性不能具有空的参数列表未正确声明索引的属性。有关详细信息，请参阅如何：使用属性在。示例下面的示例生成 C3799，并演示如何修复此错误。 The following sample generates C3799 and shows how to fix it. // C3799.cpp  
// compile with: /clr /c  
ref struct C {  
   property int default[] {   // C3799  
   // try the following line instead  
   // property int default[int] {  
      int get(int index) { return 0; }  
      void set(int index, int value) {}  
   }  
};

编译器错误 C3800 Compiler Error C3800 11
：不能混合属性和事件不能声明为属性和事件的构造。才可访问使用过时的编译器选项。：属性具有与一个其访问器不兼容的类型与定义的属性的类型属性与其中一个其访问器函数的返回类型不匹配。下面的示例生成 C3803: The following sample generates C3803: // C3803.cpp  
struct A  
{  
   __declspec(property(get=GetIt)) int i;  
   char GetIt()  
   {  
      return 0;  
   }  

   /*  
   // try the following definition instead  
   int GetIt()  
   {  
      return 0;  
   }  
   */  
}; // C3803  

int main()  
{  
}

编译器错误 C3804 Compiler Error C3804 11
：访问器方法的属性必须为所有静态或所有非静态在定义非属性时，访问器函数可以是静态或实例，但不是两者。有关更多信息，请参见。示例下面的示例生成 C3804。 The following sample generates C3804. // C3804.cpp  
// compile with: /c /clr  
ref struct A {  

   property int i {  
      static int get() {}  
      void set(int i) {}  
   }   // C3804 error  

   // OK  
   property int j {  
      int get() { return 0; }  
      void set(int i) {}  
   }  

   property int k {  
      static int get() { return 0; }  
      static void set(int i) {}  
   }  
};

编译器错误 C3805 Compiler Error C3805 11
：意外的标记，应输入或标识符定义一个属性时遇到无效的标记。删除无效的令牌。

编译器错误 C3807 Compiler Error C3807 11
：具有特性的类不能从派生，则允许仅接口的实现派生自类型仅可以实现接口。示例下面的示例生成 C3807。 The following sample generates C3807. // C3807.cpp  
// compile with: /clr /c  
ref struct S {};  
interface struct I {};  

[System::Runtime::InteropServices::ComImportAttribute()]  
ref struct S1 : S {};   // C3807  
ref struct S2 : I {};

编译器错误 C3808 Compiler Error C3808 11
：具有特性的类不能定义成员，而仅抽象或允许使用函数派生自类型不能定义。和编译器选项在中已弃用。示例下面的示例生成 C3808。 The following sample generates C3808. // C3808.cpp  
// compile with: /c /clr:pure user32.lib  
using namespace System::Runtime::InteropServices;  

[System::Runtime::InteropServices::ComImportAttribute()]  
ref struct S1 {  
   int f() {}   // C3808  
   virtual int g() abstract;   // OK  

   [DllImport("msvcrt.dll")]  
   int printf(System::String ^, int i);   // OK  
};

编译器错误 C3809 Compiler Error C3809 11
“”托管或类型不能有任何友元函数类接口托管类型和运行时类型不允许使用友元。若要修复此错误，请不要声明在托管或运行时类型内声明友元。下面的示例生成 C3809： The following sample generates C3809: // C3809a.cpp  
// compile with: /clr  
ref class A {};  

ref class B  
{  
public:  
   friend ref class A;   // C3809  
};  

int main()  
{  
}

编译器错误 C3812 Compiler Error C3812 11
属性必须为属性声明中的第一个标记声明属性时关键字必须是在行上的第一个标记。才可访问使用过时的编译器选项。

编译器错误 C3813 Compiler Error C3813 11
属性声明只能在托管类型或类型的定义内出现属性仅可以在托管或运行时内声明类型。本机类型不支持关键字。示例下面的示例生成 C3813，并演示如何修复此错误： The following sample generates C3813 and shows how to fix it: // C3813.cpp  
// compile by using: cl /c /clr C3813.cpp  
class A  
{  
   property int Int; // C3813  
};  

ref class B  
{  
   property int Int; // OK - declared within managed type  
};

编译器错误 C3815 Compiler Error C3815 11
方法返回类型必须与的最后一个参数的类型匹配声明属性的返回值时方法必须与匹配的声明访问器方法中的最后一个参数。才可访问使用过时的编译器选项。

编译器错误 C3816 Compiler Error C3816 11
以前声明或定义与不同的托管或前向声明和实际声明要求特性声明中不存在任何冲突或不一致。下面的示例生成 C3816，并演示如何修复此错误： The following sample generates C3816 and shows how to fix it: // C3816a.cpp  
// compile with: /clr /c  
class C1;  
// try the following line instead  
// ref class C1;  

ref class C1{  // C3816, forward declaration does not use ref  
};

编译器错误 C3817 Compiler Error C3817 11
：属性可以仅应用于函数关键字只能应用于函数定义。才可访问使用过时的编译器选项。

编译器错误 C3818 Compiler Error C3818 11
数组属性声明不应使过载索引属性当有一个索引器，另一个是数组属性，是不可能的属性重载。才可访问使用过时的编译器选项。

编译器错误 C3820 Compiler Error C3820 11
“”初始值设定项必须是托管的托管类型的初始值设定项也必须是托管的。更正此错误指定托管初始值设定项方法。请参阅初始值设定项附加启动注意事项

编译器错误 C3821 Compiler Error C3821 11
：托管的类型或函数不能在非托管函数使用内联程序集的函数或不能包含值类型或托管的类。若要修复此错误，删除内联程序集和或删除托管的对象。如果你尝试在函数中使用自动存储，也可能发生。有关详细信息，请参阅变量自变量列表（）和对于引用类型的堆栈语义。示例下面的示例生成 C3821。 The following sample generates C3821. // C3821a.cpp  
// compile with: /clr /c  
public ref struct R {};  
void test1(...) {  
   R r;   // C3821  
} 示例 Example 下面的示例生成 C3821。 The following sample generates C3821. // C3821b.cpp  
// compile with: /clr  
// processor: /x86  
ref class A {  
   public:  
   int i;  
};  

int main() {  
   // cannot use managed classes in this function  
   A ^a;     

   __asm {  
      nop  
   }  
} // C3821

编译器错误 C3824 Compiler Error C3824 11
：此类型不能出现在此上下文（函数参数、返回类型或静态成员）钉住指针不能为函数参数、返回类型，或声明。示例下面的示例生成 C3824: The following sample generates C3824: // C3824a.cpp  
// compile with: /clr /c  
void func() {  
   static pin_ptr<int> a; // C3824  
   pin_ptr<int> b; // OK  
}

编译器错误 C3825 Compiler Error C3825 11
：托管或可以仅支持托管或托管类中只支持事件。运行时类中只支持运行时事件。要在托管代码中修复此错误，请将和的类型参数从更改为。或者，删除该属性。示例下面的示例生成 C3825，并演示如何修复此错误： The following sample generates C3825 and shows how to fix it: // C3825a.cpp  
// compile with: /clr  
public delegate void del1();  

[event_source(native)]           // To fix, change 'native' to 'managed' or delete this line  
ref class CEventSrc  
{  
public:  
   event del1^ event1;       // C3825  

   void FireEvents() {  
      event1();  
   }  
};  

[event_receiver(native)]         // To fix, change 'native' to 'managed' or delete this line  
ref class CEventRec  
{  
public:  
   void handler1()  
   {  
      System::Console::WriteLine("Executing handler1().\n");  
   }  
   void HookEvents(CEventSrc^ pSrc)   
   {  
      pSrc->event1 += gcnew del1(this, &CEventRec::handler1);  
   }  
   void UnhookEvents(CEventSrc^ pSrc)   
   {  
      pSrc->event1 -= gcnew del1(this, &CEventRec::handler1);  
   }  
};  

int main()   
{  
   CEventSrc^ pEventSrc = gcnew CEventSrc;  
   CEventRec^ pEventRec = gcnew CEventRec;  
   pEventRec->HookEvents(pEventSrc);  
   pEventSrc->FireEvents();  
   pEventRec->UnhookEvents(pEventSrc);  
}

编译器错误 C3828 Compiler Error C3828 11
：时创建的实例托管，不允许使用位置自变量或时创建的托管的类型或运行时类型的对象时，不能使用运算符的放置形式、或新。下列示例生成并演示如何修复此错误：

编译器错误 C3830 Compiler Error C3830 11
：不能从，值类型只能继承自接口类继承值类型不能继承的基类。有关详细信息，请参阅类和结构。示例下面的示例生成 C3830: The following sample generates C3830: // C3830a.cpp  
// compile with: /clr /c  
public value struct MyStruct4 {  
   int i;  
};  

public value class MyClass : public MyStruct4 {};   // C3830  

// OK  
public interface struct MyInterface4 {  
   void i();  
};  

public value class MyClass2 : public MyInterface4 {  
public:  
   virtual void i(){}  
};

编译器错误 C3831 Compiler Error C3831 11
不能具有固定的数据成员或成员函数返回钉住指针未正确使用。示例下面的示例生成 C3831: The following sample generates C3831: // C3831a.cpp  
// compile with: /clr  
ref class Y  
{  
public:  
   int i;  
};  

ref class X  
{  
   pin_ptr<int> mbr_Y;   // C3831  
   int^ mbr_Y2;   // OK  
};  

int main() {  
   Y y;  
   pin_ptr<int> p = &y.i;  
}

编译器错误 C3832 Compiler Error C3832 11
：类型库看上去就好像它为位指针生成请更改限定符显式信息随附属性指令未与类型库中找到的编译器不一致。

编译器错误 C3833 Compiler Error C3833 11
的目标类型无效或未正确声明。下面的示例生成 C3833: The following sample generates C3833: // C3833.cpp  
// compile with: /clr  

ref class MyClass {  
public:  
   int data;  
   MyClass() : data(35) {}  
};  

int main() {  
   interior_ptr<MyClass> p;   // C3833  

   // OK  
   MyClass ^ h_MyClass = gcnew MyClass;  
   interior_ptr<int> i = &(h_MyClass->data);  
   System::Console::WriteLine(*i);  
} 下面的示例生成 C3833: The following sample generates C3833: // C3833b.cpp  
// compile with: /clr /c  
ref class G {  
public:  
   int i;  
};  

int main() {  
   G ^ pG = gcnew G;  
   pin_ptr<G> ppG = &pG;   // C3833 can't pin a whole object  

   // OK  
   pin_ptr<int> ppG2 = &pG->i;  
   *ppG2 = 54;  
   int * pi = ppG2;  
   System::Console::WriteLine(*pi);  
   System::Console::WriteLine(*ppG2);  

   *pi = 55;  
   System::Console::WriteLine(*pi);  
   System::Console::WriteLine(*ppG2);  

   *ppG2 = 56;  
   System::Console::WriteLine(*pi);  
   System::Console::WriteLine(*ppG2);  
}

编译器错误 C3834 Compiler Error C3834 11
非法显式强制转换为固定的指针改为使用固定的本地变量不允许显式强制转换为固定指针。示例下面的示例生成 C3834。 The following sample generates C3834. // C3834.cpp  
// compile with: /clr  
int main() {  
   int x = 33;  

   pin_ptr<int> p = safe_cast<pin_ptr<int> >(&x);   // C3834  
   pin_ptr<int> p2 = &x;   // OK  
}

编译器错误 C3836 Compiler Error C3836 11
静态构造函数不允许具有成员初始值设定项列表托管的类不能具有静态构造函数还具有成员初始化列表。静态类构造函数所调用的公共语言运行时类初始化，初始化静态数据成员。示例下面的示例生成 C3836: The following sample generates C3836: // C3836a.cpp  
// compile with: /clr  
ref class M  
{  
   static int s_i;  

public:  
   static M() :  s_i(1234)   // C3836, delete initializer to resolve  
   {  
   }  
};  

int main()  
{  
}

编译器错误 C3838 Compiler Error C3838 11
从不能显式继承指定不能充当任何类的基类。示例下面的示例生成 C3838: The following sample generates C3838: // C3838a.cpp  
// compile with: /clr /c  
public ref class B : public System::Enum {};   // C3838

编译器错误 C3839 Compiler Error C3839 11
无法更改托管或类型中的对齐方式变量的对齐在托管或运行时类型由或运行时控制，并且不能修改与对齐。下面的示例生成 C3839： The following sample generates C3839: // C3839a.cpp  
// compile with: /clr  
ref class C  
{  
public:  
   __declspec(align(32)) int m_j; // C3839  
};  

int main()  
{  
}

编译器错误 C3842 Compiler Error C3842 11
“函数”不支持在或托管类型的成员函数上使用“”和“”限定符和易失性不支持的运行时或托管的类型的成员函数上。下面的示例生成 C3842： The following sample generates C3842: // C3842a.cpp  
// compile with: /clr /c  
public ref struct A {  
   void f() const {}   // C3842  
   void f() volatile {}   // C3842  

   void f() {}  
};

编译器错误 C3846 Compiler Error C3846 11
：无法导入中的符号：如具有已导入从另一个程序集不是从被引用程序集导入符号，因为以前从被引用程序集将它导入。示例下面的示例生成 C3846: The following sample generates C3846: // C3846a.cpp  
// compile with: /LD /clr  
public ref struct G  
{  
}; 然后编译此： And then compile this: // C3846b.cpp  
// compile with: /clr  
#using "c3846a.dll"  
#using "c3846a.obj"   // C3846  

int main()  
{  
}

编译器错误 C3848 Compiler Error C3848 11
具有类型的表达式都将丢失某些限定符，才能调用使用指定的量可变类型的变量只能调用成员函数定义具有相同或更高版本易失性限制。以下示例生成

编译器错误 C3849 Compiler Error C3849 11
在类型的表达式上的函数样式调用都将丢失所有数字可用运算符重载的和或可变限定符使用指定的量可变类型的变量只能调用成员函数定义具有相同或更高版本易失性限制。若要修复此错误，提供适当的成员函数。无法对常数或可变限定的对象执行转换，转换会导致丢失的限定。你可以获得限定符，但不能丢失在转换中的限定符。以下示例生成

编译器错误 C3850 Compiler Error C3850 11
“”：通用字符名称指定的字符无效表示为通用字符名称的字符必须表示范围内的有效码位。通用字符名称不能包含代理项范围、或编码的代理项对中的值。编译器从有效码位自动生成代理项对。在编译为语言的代码中，通用字符名称不能表示（含）范围内的字符，（“”）、（“”）和（“”）除外。在编译为的代码中，通用字符名称可以使用字符串或字符文本中的任意有效码位。在文字之外，通用字符名称不能表示或（均含）范围内的控制字符或基本源字符集成员。有关详细信息，请参阅。示例下面的示例生成 C3850，并演示如何修复此错误： The following sample generates C3850, and shows how to fix it: // C3850.cpp  
int main() {  
   int \u0019 = 0;   // C3850, not in allowed range for an identifier  
   const wchar_t * wstr_bad  = L"\UD840DC8A"; // C3850, UCN is surrogate pair  
   const wchar_t * wstr_good = L"\U0002008A"; // Okay, UCN is valid code point  
}

编译器错误 C3851 Compiler Error C3851 11
“”：通用字符名称不能指定基本字符集中的字符在编译为的代码中，无法使用在字符串或字符文本之外表示基本源字符集中的字符的通用字符名称。有关详细信息，请参阅。在编译为的代码中，无法使用范围至（包含和）以内的字符的通用字符名称，、或除外。下面的示例生成 C3851，并显示如何修复此问题： The following samples generate C3851, and show how to fix it: // C3851.cpp  
int main()  
{  
   int test1_\u0041 = 0;   // C3851, \u0041 = 'A' in basic character set  
   int test2_A = 0;        // OK  
}

编译器错误 C3852 Compiler Error C3852 11
具有类型：聚合初始化无法初始化此成员尝试将默认初始化聚合初始化的一部分作为分配给不能在聚合初始化接收默认初始化的数据成员。以下示例生成

编译器错误 C3853 Compiler Error C3853 11
是非法的重新初始化引用或通过引用向函数分配无法分配到通过函数的指针的引用，因为函数都不是左值。以下示例生成

编译器错误 C3854 Compiler Error C3854 11
左侧的的表达式计算的函数。无法分配到函数（函数不是左值）无法重新初始化引用。取消对函数的引用将生成一个函数，这是右值，您不能向其分配。因此，不能通过对函数的引用将分配。下面的示例生成 C3854: The following sample generates C3854: // C3854.cpp  
int afunc(int i)  
{  
   return i;  
}  

typedef int (& rFunc_t)(int);  
typedef int (* pFunc_t)(int);  

int main()  
{  
   rFunc_t rf = afunc;   // OK binding a reference to function  
   pFunc_t pf = &afunc;   // OK initializing a pointer to function  

   *pf = &afunc;   // C3854  
   // try the following line instead  
   // pf = &afunc;  
   *rf = &afunc;   // C3854  
}

编译器错误 C3855 Compiler Error C3855 11
：类型参数不兼容与声明编译器发现模板或泛型参数具有不同名称。这可以在模板专用化的定义中指定的模板参数是与其声明不匹配时发生。下面的示例生成 C3855: The following sample generates C3855: // C3855.cpp  
template <int N>  
struct C {  
   void f();  
};  

template <char N>  
void C<N>::f() {}   // C3855 可能的解决方法： Possible resolution: // C3855b.cpp  
// compile with: /c  
template <int N>  
struct C {  
   void f();  
};  

template <int N>  
void C<N>::f() {} 使用泛型时，也可能发生 C3855: C3855 can also occur when using generics: // C3855c.cpp  
// compile with: /clr  
generic <class T>  
ref struct GC1 {  
   generic <class U>  
   ref struct GC2;  
};  

generic <class T>  
generic <class U>  
generic <class V>  
ref struct GC1<T>::GC2 { };   // C3855 可能的解决方法： Possible resolution: // C3855d.cpp  
// compile with: /clr /c  
generic <class T>  
ref struct GC1 {  
   generic <class U>  
   ref struct GC2;  
};  

generic <class T>  
generic <class U>  
ref struct GC1<T>::GC2 { };

编译器错误 C3856 Compiler Error C3856 11
：类不是类类型此错误最常见原因是当没有更泛型或模板参数列出在定义比在声明。下面的示例生成 C3856: The following sample generates C3856: // C3856.cpp  
template <class T>   
struct S {  
   template <class T1>   
   struct S1;   
   void f();   
};  

template <class T>   // C3856  
template <class T1>  
template <class T2>  // extra template parameter list in definition  
struct S<T>::S1{}; 可能的解决方法： Possible resolution: // C3856b.cpp  
// compile with: /c  
template <class T>   
struct S {  
   template <class T1>   
   struct S1;   
   void f();   
};  

template <class T>  
template <class T1>  
struct S<T>::S1{}; 使用泛型时，也可能发生 C3856: C3856 can also occur when using generics: // C3856c.cpp  
// compile with: /clr  
generic <class T>  
ref struct GS {  
   generic <class U>  
   ref struct GS2;  
};  

generic <class T>  
generic <class U>  
generic <class V>  
ref struct GS<T>::GS2 {};   // C3856 可能的解决方法： Possible resolution: // C3856d.cpp  
// compile with: /clr /c  
generic <class T>  
ref struct GS {  
   generic <class U>  
   ref struct GS2;  
};  

generic <class T>  
generic <class U>  
ref struct GS<T>::GS2 {};

编译器错误 C3857 Compiler Error C3857 11
：不允许多个类型参数列表为同一类型，这不允许指定多个模板或泛型。下面的示例生成 C3857: The following sample generates C3857: // C3857.cpp  
template <class T, class TT>  
template <class T2>    // C3857  
struct B {}; 可能的解决方法： Possible resolution: // C3857b.cpp  
// compile with: /c  
template <class T, class TT, class T2>   
struct B {}; 使用泛型时，也可能发生 C3857: C3857 can also occur when using generics: // C3857c.cpp  
// compile with: /clr  
generic <typename T>  
generic <typename U>  
ref class GC;   // C3857 可能的解决方法： Possible resolution: // C3857d.cpp  
// compile with: /clr /c  
generic <typename U>  
ref class GC;

编译器错误 C3858 Compiler Error C3858 11
：不能重新声明在当前范围内不能两次在同一范围内声明类型。下面的示例生成 C3858: The following sample generates C3858: // C3858.cpp  
// compile with: /LD  
template <class T>  
struct Outer  
{  
   struct Inner;  
};  

template <class T>  
struct Outer<T>::Inner;   // C3858  
// try the following line instead  
// struct Outer<T>::Inner{};

编译器错误 C3859 Compiler Error C3859 11
超过了的虚拟内存范围；请使用“”或更大的命令行选项重新编译预编译标头对于编译器尝试放入其中的数据量太小。使用编译器标志可指定预编译标头文件的更大值。有关详细信息，请参阅（指定预编译头内存分配限制）。

编译器错误 C3860 Compiler Error C3860 11
类类型名称后面的类型自变量列表必须列表中使用类型参数列表的顺序的参数泛型或模板的自变量列表的格式不正确。下面的示例生成 C3860: The following sample generates C3860: // C3860.cpp  
// compile with: /LD  
template <class T1, class T2>  
struct A {  
   void f();  
};  

template <class T2, class T1>  
void A<T1, T2>::f() {}   // C3860 可能的解决方法： Possible resolution: // C3860b.cpp  
// compile with: /c  
template <class T1, class T2>  
struct A {  
   void f();  
};  

template <class T2, class T1>  
void A<T2, T1>::f() {} 使用泛型时，也可能发生 C3860: C3860 can also occur when using generics: // C3860c.cpp  
// compile with: /clr  
generic<class T,class U>  
ref struct GC {  
   void f();  
};  

generic<class T, class U>  
void GC<T,T>::f() {}   // C3860 可能的解决方法： Possible resolution: // C3860d.cpp  
// compile with: /clr /c  
generic<class T,class U>  
ref struct GC {  
   void f();  
};  

generic<class T, class U>  
void GC<T,U>::f() {}

编译器错误 C3861 Compiler Error C3861 11
标识符：找不到标识符即使使用自变量相关的查找，编译器也无法解析对标识符的引用。若要修复此错误，比较使用标识符到标识符声明的大小写和拼写。验证范围解析运算符和命名空间指令的用法正确。如果在标头文件中声明该标识符，请验证引用标识符之前已包含该头。如果标识符旨在是外部可见的请确保它在使用它的任何源文件中声明。此外请检查标识符声明或定义不排除通过条件编译指令。若要从中的运行时库中删除过时函数的更改可能会导致。若要解决此错误，删除对这些函数的引用，或将它们替换为其安全的替代方法，如果有。有关详细信息，请参阅过时函数。如果项目在迁移后显示从旧版本的编译器错误，则可能产生与支持的版本相关的问题。不再支持面向、、、或。如果你或宏分配给这些版本之一，则必须修改宏。有关详细信息，请参阅修改和。示例下面的示例生成 C3861，因为未定义标识符。 The following sample generates C3861 because the identifier is not defined. // C3861.cpp  
void f2(){}  
int main() {  
   f();    // C3861  
   f2();   // OK  
} 示例 Example 下面的示例生成 C3861 因为标识符仅在其定义，文件作用域中可见，除非它在使用它的其他源文件中声明。 The following sample generates C3861 because an identifier is only visible in the file scope of its definition, unless it is declared in other source files that use it. // C3861_a1.cpp
// Compile with: cl /EHsc /W4 C3861_a1.cpp C3861_a2.cpp  
#include <iostream>
// Uncomment the following line to fix:
// int f();  // declaration makes external function visible
int main() {  
   std::cout << f() << std::endl;    // C3861
} // C3861_a2.cpp  
int f() {  // declared and defined here
   return 42;  
} 示例 Example C + + 标准库中的异常类需要 std 命名空间。 Exception classes in the C++ Standard Library require the std namespace. // C3861_b.cpp  
// compile with: /EHsc  
#include <iostream>  
int main() {  
   try {  
      throw exception("Exception");   // C3861  
      // try the following line instead  
      // throw std::exception("Exception");  
   }  
   catch (...) {  
      std::cout << "caught an exception" << std::endl;  
   }  
} 示例 Example 已从 CRT 库中删除过时函数。 Obsolete functions have been removed from the CRT library. // C3861_c.cpp  
#include <stdio.h>  
int main() {  
   char line[21]; // room for 20 chars + '\0'  
   gets( line );  // C3861  
   // Use gets_s instead.  
   printf( "The line entered was: %s\n", line );  
} 下面的示例生成 C3767，因为编译器不能用于 FriendFunc 依赖于自变量的查找： The following sample generates C3767 because the compiler cannot use argument dependent lookup for FriendFunc: namespace N {  
   class C {  
      friend void FriendFunc() {}  
      friend void AnotherFriendFunc(C* c) {}  
   };  
}  

int main() {  
   using namespace N;  
   FriendFunc();   // C3861 error  
   C* pC = new C();  
   AnotherFriendFunc(pC);   // found via argument-dependent lookup  
} 若要修复此错误，声明友元类作用域中的，并在命名空间范围中定义它： To fix the error, declare the friend in class scope and define it in namespace scope: 类 MyClass { class...

编译器错误 C3862 Compiler Error C3862 11
：无法编译非托管的函数使用或和编译器选项在中已弃用。使用编译或将生成仅映像，不包含本机（非托管）代码的映像。因此，不能使用中的杂注或编译。有关详细信息，请参阅（公共语言运行时编译）和、。示例下面的示例生成 C3862: The following sample generates C3862: // C3862.cpp  
// compile with: /clr:pure /c  
#pragma unmanaged  
void f() {}   // C3862

编译器错误 C3865 Compiler Error C3865 11
：只能在本机成员函数在已全局函数的函数或托管的成员函数上使用的调用约定。只能对本机（非托管）的成员函数进行的调用约定。有关详细信息，请参阅调用约定。下面的示例生成 C3865: The following sample generates C3865: // C3865.cpp  
// compile with: /clr  
// processor: x86  
void __thiscall Func(){}   // C3865  

// OK  
struct MyType {  
   void __thiscall Func(){}  
};

编译器错误 C3866 Compiler Error C3866 11
函数调用缺少参数列表非静态成员函数内部的析构函数或终结器调用没有自变量列表。下面的示例生成 C3866: The following sample generates C3866: // C3866.cpp  
// compile with: /c  
class C {  
   ~C();  
   void f() {  
      this->~C;   // C3866  
      this->~C();   // OK  
   }  
};

编译器错误 C3867 Compiler Error C3867 11
“”函数调用缺少自变量列表；请使用“”创建指向成员的指针你曾尝试在不使用成员函数的类名称和运算符限定成员函数的情况下采用其地址。此错误还可能来自于为执行的编译器一致性工作：增强了指针到成员一致性。使用之前的版本编译的代码现在将生成。示例可能会从带有误导性的建议解决方案的编译器发出。如可能，请使用派生程度最高的类。下面的示例生成 C3867，并演示如何修复此错误： The following sample generates C3867 and shows how to fix it. // C3867_1.cpp  
// compile with: /c  
struct Base {   
protected:   
   void Test() {}  
};  

class Derived : public Base {   
   virtual void Bar();  
};  

void Derived::Bar() {  
   void (Base::*p1)() = Test;   // C3867  
   &Derived::Test;   // OK  
} 示例 Example 下面的示例生成 C3867，并演示如何修复此错误： The following sample generates C3867 and shows how to fix it. // C3867_2.cpp  
#include<stdio.h>  

struct S {  
   char *func() {  
      return "message";  
   }  
};  

class X {  
public:  
   void f() {}  
};  

int main() {  
   X::f;   // C3867  

   // OK  
   X * myX = new X;  
   myX->f();  

   S s;  
   printf_s("test %s", s.func);   // C3867  
   printf_s("test %s", s.func());   // OK  
} 示例 Example 下面的示例生成 C3867，并演示如何修复此错误： The following sample generates C3867 and shows how to fix it. // C3867_3.cpp  
class X {  
public:  
   void mf(){}  
};  

int main() {  
   void (X::*pmf)() = X::mf;   // C3867  

   // try the following line instead  
   void (X::*pmf2)() = &X::mf;  
} 示例 Example 下面的示例生成 C3867。 The following sample generates C3867. // C3867_4.cpp  
// compile with: /c  
class A {  
public:  
   void f(int) {}  

   typedef void (A::*TAmtd)(int);  

   struct B {  
      TAmtd p;  
   };  

   void g() {  
      B b1;  
      b1.p = f;   // C3867  
   }  
}; 示例 Example 下面的示例生成 C3867。 The following sample generates C3867. // C3867_5.cpp  
// compile with: /EHsc  
#include <iostream>  

class Testpm {  
public:  
   void m_func1() {  
      std::cout << m_num << "\tm_func1\n";   
    }  

   int m_num;  
   typedef void (Testpm::*pmfn1)();  
   void func(Testpm* p);  
};  

void Testpm::func(Testpm* p) {  
   pmfn1 s = m_func1;   // C3867  
   pmfn1 s2 = &Testpm::m_func1;   // OK  
   (p->*s2)();  
}  

int main() {  
   Testpm *pTestpm = new Testpm;  
   pTestpm->m_num = 10;  

   pTestpm->func(pTestpm);  
}

编译器错误 C3868 Compiler Error C3868 11
：泛型参数的约束与不同，在声明上多个声明必须具有相同的泛型约束。有关详细信息，请参阅泛型。示例下面的示例生成 C3868。 The following sample generates C3868. // C3868.cpp  
// compile with: /clr /c  
interface struct I1;  

generic <typename T> ref struct MyStruct;  
generic <typename U> where U : I1 ref struct MyStruct;   // C3868  

// OK  
generic <typename T> ref struct MyStruct2;  
generic <typename U> ref struct MyStruct2;  

generic <typename T> where T : I1 ref struct MyStruct3;  
generic <typename U> where U : I1 ref struct MyStruct3;

C3869 Compiler Error C3869 11
 gcnew 约束缺少空的参数列表 '（）' gcnew constraint is missing empty parameter list '()' gcnew 特殊约束指定不为空的参数列表。 The gcnew special constraint was specified without the empty parameter list. 请参阅 泛型类型参数的约束 (C + + /cli CLI) 有关详细信息。 See Constraints on Generic Type Parameters (C++/CLI) for more information. 示例 Example 下面的示例生成 C3869。 The following sample generates C3869. // C3869.cpp  
// compile with: /c /clr  
using namespace System;  
generic <typename T>  
where T : gcnew   // C3869  
// try the following line instead  
// where T : gcnew()  
ref class List {};

编译器错误 C3872 Compiler Error C3872 11
“”：此字符不允许在标识符中使用编译器对于标识符中允许的字符遵循标准。仅允许在标识符中使用某些范围的字符和通用字符名称。其他限制适用于标识符的初始字符。有关允许的字符和通用字符名称范围的详细信息和列表，请参阅。编译代码时，标识符中允许的字符范围限制更少。使用编译的代码中的标识符应遵循标准：公共语言基础结构。下面的示例生成 C3872： The following sample generates C3872: // C3872.cpp  
int main() {  
   int abc_\u0040;   // C3872, U+0040 is in base char set  
   int abc_\u3001;   // C3872, U+3001 is not in allowed range  
   int \u30A2_abc_\u3042;   // OK, UCNs in allowed range  
}

编译器错误 C3873 Compiler Error C3873 11
“”：不允许将此字符作为标识符的第一个字符编译器对于标识符中允许的字符遵循标准。仅允许在标识符中使用某些范围的字符和通用字符名称。其他限制适用于标识符的初始字符。有关允许的字符和通用字符名称范围的详细信息和列表，请参阅。编译代码时，标识符中允许的字符范围限制更少。使用编译的代码中的标识符应遵循标准：公共语言基础结构。下面的示例生成 C3873： The following sample generates C3873: // C3873.cpp  
int main() {  
   int \u036F_abc;   // C3873, not in allowed range for initial character  
   int abc_\u036F;   // OK, in allowed range for non-initial character  
}

编译器错误 C3874 Compiler Error C3874 11
的返回类型应为而不是函数没有所需的编译器的返回类型。下面的示例生成 C3874: The following sample generates C3874: // C3874b.cpp  
double main()  
{   // C3874  
}

编译器错误 C3880 Compiler Error C3880 11
：不能为数据成员一种文本必须是属性，或编译时转换为，以下类型之一：整型字符串具有整型或基础类型的枚举下面的示例生成 C3880: The following sample generates C3880: // C3880.cpp  
// compile with: /clr /c  
ref struct Y1 {  
   literal System::Decimal staticConst1 = 10;   // C3880  
   literal int staticConst2 = 10;   // OK  
};

编译器错误 C3883 Compiler Error C3883 11
：必须初始化静态数据成员变量标记为未正确初始化。下面的示例生成 C3883: The following sample generates C3883: // C3883.cpp  
// compile with: /clr  
ref struct Y1 {  
   initonly  
   static int staticConst1;   // C3883  
}; 以下示例演示了可能的解决方法： The following sample demonstrates a possible resolution: // C3883b.cpp  
// compile with: /clr /c  
ref struct Y1 {  
   initonly  
   static int staticConst2 = 0;  
}; 下面的示例演示如何在静态构造函数初始化： The following sample shows how to initialize in a static constructor: // C3883c.cpp  
// compile with: /clr /LD  
ref struct Y1 {  
   initonly  
   static int staticConst1;  

   static Y1() {  
      staticConst1 = 0;  
   }  
};

编译器错误 C3886 Compiler Error C3886 11
：必须初始化数据成员文本时，必须初始化变量。下面的示例生成 C3886: The following sample generates C3886: // C3886.cpp  
// compile with: /clr /c  
ref struct Y1 {  
   literal int staticConst;   // C3886  
   literal int staticConst2 = 0;   // OK  
};

编译器错误 C3887 Compiler Error C3887 11
数据成员的初始值设定项必须是常量表达式文本数据成员可以仅用常量表达式进行初始化。下面的示例生成 C3887: The following sample generates C3887: // C3887.cpp  
// compile with: /clr  
ref struct Y1 {  
   static int i = 9;  
   literal  
   int staticConst = i;   // C3887  
}; 可能的解决方法： Possible resolution: // C3887b.cpp  
// compile with: /clr /c  
ref struct Y1 {  
   literal  
   int staticConst = 9;  
};

编译器错误 C3888 Compiler Error C3888 11
“”：不支持与此数据成员关联的常量表达式使用关键字声明的名称数据成员是使用编译器不支持的值初始化的。编译器仅支持常量整型、枚举或字符串类型。错误可能的原因是数据成员是使用字节数组初始化的。更正此错误检查声明的数据成员是否是支持的类型。请参阅名称

编译器错误 C3890 Compiler Error C3890 11
：不能采用数据成员的地址垃圾回收堆上存在的数据成员。可以移动已垃圾回收堆上的对象，因此采用的地址不是很有用。下面的示例生成 C3890: The following sample generates C3890: // C3890.cpp  
// compile with: /clr  
ref struct Y1 {  
   literal int staticConst = 9;  
};  

int main() {  
   int p = &Y1::staticConst;   // C3890  
   int p2 = Y1::staticConst;   // OK  
}

编译器错误 C3891 Compiler Error C3891 11
数据成员不能用作左值文本变量为常量，并在声明中初始化之后，不能更改其值。下面的示例生成 C3891: The following sample generates C3891: // C3891.cpp  
// compile with: /clr  
ref struct Y1 {  
   literal int staticConst = 9;  
};  

int main() {  
   Y1::staticConst = 0;   // C3891  
}

编译器错误 C3892 Compiler Error C3892 11
：不能将其分配给为常量类型的变量声明和初始化后，不能更改变量。下面的示例生成 C3892: The following sample generates C3892: // C3892.cpp  
// compile with: /clr  
ref struct Y1 {  
   static const int staticConst = 9;  
};  

int main() {  
   Y1::staticConst = 0;   // C3892  
}

编译器错误 C3893 Compiler Error C3893 11
：左值使用数据成员仅允许用在类类型名称的实例构造函数静态数据成员只能在静态构造函数采用其地址。实例（非静态）数据成员只能在实例（非静态）构造函数采用其地址。下面的示例生成 C3893: The following sample generates C3893: // C3893.cpp  
// compile with: /clr  
ref struct Y1 {  
   Y1() : data_var(0) {  
      int% i = data_var;   // OK  
   }  
   initonly int data_var;  
};  

int main(){  
   Y1^ y= gcnew Y1;  
   int% i = y->data_var;   // C3893  
}

编译器错误 C3894 Compiler Error C3894 11
：类的类构造函数中只允许左值使用静态数据成员静态数据成员仅用作其位置的声明，或在静态构造函数的左值。实例（非静态）数据成员仅可用作其位置的声明，或在实例（非静态）构造函数中的左值。下面的示例生成 C3894: The following sample generates C3894: // C3894.cpp  
// compile with: /clr  
ref struct Y1 {  
   initonly static int data_var = 0;  

public:  
   // class constructor  
   static Y1() {  
      data_var = 99;   // OK  
      System::Console::WriteLine("in static constructor");  
   }  

   // not the class constructor  
   Y1(int i) {  
      data_var = i;   // C3894  
   }  

   static void Test() {}  

};  

int main() {  
   Y1::data_var = 88;   // C3894  
   int i = Y1::data_var;  
   Y1 ^ MyY1 = gcnew Y1(99);  
   Y1::Test();  
}

编译器错误 C3895 Compiler Error C3895 11
：类型数据成员不能为易失性某些种类的数据成员，例如文本或，不能为易失性。下面的示例生成 C3895: The following sample generates C3895: // C3895.cpp  
// compile with: /clr  
ref struct Y1 {  
   initonly  
   volatile int data_var2;   // C3895  
};

编译器错误 C3896 Compiler Error C3896 11
：不正确的初始值设定项：只能与初始化此数据成员文本数据成员未正确初始化。请参阅有关详细信息。下面的示例生成 C3896: The following sample generates C3896: // C3896.cpp  
// compile with: /clr /c  
ref class R{};  

value class V {  
   literal R ^ r = "test";   // C3896  
   literal R ^ r2 = nullptr;   // OK  
};

编译器错误 C3898 Compiler Error C3898 11
：类型数据成员可以只是托管类型的成员本机类中声明数据成员。仅可将数据成员声明中的类。下面的示例生成 C3898: The following sample generates C3898: // C3898.cpp  
// compile with: /clr  
struct Y1 {  
   initonly  
   static int data_var = 9;   // C3898  
}; 可能的解决方法： Possible resolution: // C3898b.cpp  
// compile with: /clr /c  
ref struct Y1 {  
   initonly  
   static int data_var = 9;  
};

编译器错误 C3899 Compiler Error C3899 11
：左值使用数据成员不允许直接在类中的并行区域内数据成员不能初始化该部分中的构造函数内并行区域。这是由于编译器执行该代码，内部重定位，以便它不再有效地构造函数的一部分。若要解决，初始化在构造函数中，但在并行区域外的数据成员。示例下面的示例生成 C3899。 The following sample generates C3899. // C3899.cpp  
// compile with: /clr /openmp  
#include <omp.h>   

public ref struct R {  
   initonly int x;  
   R() {  
      x = omp_get_thread_num() + 1000;   // OK  
      #pragma omp parallel num_threads(5)  
      {  
         // cannot assign to 'x' here  
         x = omp_get_thread_num() + 1000;   // C3899  
         System::Console::WriteLine("thread {0}", omp_get_thread_num());  
      }  
      x = omp_get_thread_num() + 1000;   // OK  
   }  
};  

int main() {  
   R^ r = gcnew R;  
   System::Console::WriteLine(r->x);  
}

编译器错误 C3900 Compiler Error C3900 11
：不允许在当前范围内属性块可以包含函数声明和内联函数定义。在属性块中不允许函数以外的任何成员。允许不使用任何、操作员或友元函数。有关详细信息，请参阅。事件定义只能包含访问方法和函数。下面的示例生成 C3900: The following sample generates C3900: // C3900.cpp  
// compile with: /clr  
ref class X {  
   property int P {  
      void set(int);   // OK  
      int i;   // C3900 variable declaration  
   };  
}; 下面的示例生成 C3900: The following sample generates C3900: // C3900b.cpp  
// compile with: /clr  
using namespace System;  
delegate void H();  
ref class X {  
   event H^ E {  
      int m;   // C3900  

      // OK  
      void Test() {}  

      void add( H^ h ) {}  
      void remove( H^ h ) {}  
      void raise( ) {}  
   }  
};

编译器错误 C3901 Compiler Error C3901 11
：必须具有返回类型至少一个方法的返回类型必须匹配的属性类型。有关详细信息，请参阅。下面的示例生成 C3901: The following sample generates C3901: // C3901.cpp  
// compile with: /clr /c  
using namespace System;  
ref class X {  
   property String^ Name {  
      void get();   // C3901  
      // try the following line instead  
      // String^ get();  
   };  
};  

ref class Y {  
   property double values[int, int] {  
      int get(int, int);   // C3901  
      // try the following line instead  
      // double get(int, int);  
   };  
};

编译器错误 C3902 Compiler Error C3902 11
：最后一个参数类型必须是至少一个方法的最后一个参数的类型必须匹配的属性类型。有关详细信息，请参阅。下面的示例生成 C3902: The following sample generates C3902: // C3902.cpp  
// compile with: /clr /c  
using namespace System;  
ref class X {  
   property String ^Name {  
      void set(int);   // C3902  
      // try the following line instead  
      // void set(String^){}  
   }  

   property double values[int,int] {  
      void set(int, int, float);   // C3902  
      // try the following line instead  
      // void set(int, int, double){}  
   }  
};

编译器错误 C3903 Compiler Error C3903 11
：未不具有或方法属性必须具有至少一个或方法。有关详细信息，请参阅。下面的示例生成 C3903: The following sample generates C3903: // C3903.cpp  
// compile with: /clr  
ref class X {  
   property int P {  
      void f(int){}  
      // Add one or both of the following lines.  
      // void set(int){}  
      // int get(){return 0;}  
   };   // C3903  

   property double Q[,,,,] {  
      void f(){}  
      // Add one or both of the following lines.  
      // void set(int, char, int, char, double, double){}  
      // double get(int, char, int, char, double){return 1.1;}  
   }   // C3903  
};

编译器错误 C3904 Compiler Error C3904 11
：必须指定数目的参数检查中的参数数目你和对照属性维数的方法。参数数目方法必须等于的属性的维度数或为零，对于非索引属性。参数数目方法必须是一个以上的属性的维度数。有关详细信息，请参阅。示例下面的示例生成 C3904。 The following sample generates C3904. // C3904.cpp  
// compile with: /clr /c  
ref class X {  
   property int P {  
      // set  
      void set();   // C3904  
      // try the following line instead  
      // void set(int);  

      // get  
      int get(int, int);   // C3904  
      // try the following line instead  
      // int get();  
   };  
}; 示例 Example 下面的示例生成 C3904。 The following sample generates C3904. // C3904b.cpp  
// compile with: /clr /c  
ref struct X {  
   property int Q[double, double, float, float, void*, int] {  
      // set  
      void set(double, void*);   // C3904  
      // try the following line instead  
      // void set(double, double, float, float, void*, int, int);  

      // get  
      int get();   // C3904  
      // try the following line instead  
      // int get(double, double, float, float, void*, int);  
   }  
};

编译器错误 C3908 Compiler Error C3908 11
访问级别限制性比属性访问器方法（或）不能具有限制性较弱访问权限要比属性本身上指定的访问权限。同样，对于事件访问器方法。有关详细信息，请参阅属性和事件。下面的示例生成 C3908: The following sample generates C3908: // C3908.cpp  
// compile with: /clr  
ref class X {  
protected:  
   property int i {  
   public:   // C3908 property i is protected   
      int get();  
   private:  
      void set(int);   // OK more restrictive  
   };  
};

编译器错误 C3909 Compiler Error C3909 11
或托管的事件声明必须出现在或托管的类型运行时事件或托管事件是在本机类型中声明的。要修复此错误，请在运行时类型或托管类型中声明事件。有关详细信息，请参阅事件。下面的示例生成 C3909，并演示如何修复此错误： The following sample generates C3909 and shows how to fix it: // C3909.cpp  
// compile with: /clr /c  
delegate void H();  
class X {  
   event H^ E;   // C3909 - use ref class X instead  
};  

ref class Y {  
   static event H^ E {  
      void add(H^) {}  
      void remove( H^ h ) {}  
      void raise( ) {}  
   }  
};

编译器错误 C3910 Compiler Error C3910 11
：必须定义成员事件定义，但不是包含指定且必需的访问器方法。有关详细信息，请参阅事件。下面的示例生成 C3910: The following sample generates C3910: // C3910.cpp  
// compile with: /clr /c  
delegate void H();  
ref class X {  
   event H^ E {  
      // uncomment the following lines  
      // void add(H^) {}  
      // void remove( H^ h ) {}  
      // void raise( ) {}  
   };   // C3910  

   event H^ E2; // OK data member  
};

编译器错误 C3911 Compiler Error C3911 11
：函数必须具有类型签名未正确声明事件访问器方法。有关详细信息，请参阅事件。下面的示例生成 C3911: The following sample generates C3911: // C3911.cpp  
// compile with: /clr  
using namespace System;  
delegate void H(String^, int);  

ref class X {  
   event H^ E1 {  
      void add() {}   // C3911  
      // try the following line instead  
      // void add(H ^ h) {}  

      void remove(){}  
      // try the following line instead  
      // void remove(H ^ h) {}  

      void raise(){}  
      // try the following line instead  
      // void raise(String ^ s, int i) {}  
   };  
};

编译器错误 C3912 Compiler Error C3912 11
：必须是委托类型的事件的类型。事件被声明，但不是正确的类型。有关详细信息，请参阅事件。下面的示例生成 C3912: The following sample generates C3912: // C3912.cpp  
// compile with: /clr  
delegate void H();  
ref class X {  
   event int Ev;   // C3912  
   event H^ Ev2;   // OK  
};

编译器错误 C3913 Compiler Error C3913 11
默认属性必须编入索引默认属性定义不正确。有关详细信息，请参阅。下面的示例生成 C3913: The following sample generates C3913: // C3913.cpp  
// compile with: /clr /c  
ref struct X {  
   property int default {   // C3913  
   // try the following line instead  
   // property int default[int] {  
      int get(int) { return 0; }  
      void set(int, int) {}  
   }  
};

编译器错误 C3914 Compiler Error C3914 11
默认属性不能为静态未正确声明默认属性。有关详细信息，请参阅如何：使用属性在。示例下面的示例生成 C3914，并演示如何修复此错误。 The following sample generates C3914 and shows how to fix it. // C3914.cpp  
// compile with: /clr /c  
ref struct X {  
   static property int default[int] {   // C3914  
   // try the following line instead  
   // property int default[int] {  
      int get(int) { return 0; }  
      void set(int, int) {}  
   }  
};

编译器错误 C3915 Compiler Error C3915 11
具有任何默认索引属性（类索引器）类型不具有默认的索引的属性。有关详细信息，请参阅。示例下面的示例生成 C3915。 The following sample generates C3915. // C3915.cpp  
// compile with: /clr  
ref class X {  
public:  
// uncomment property to resolve this C3915  
//   property int default[]  
//   {  
//      int get(int i)  
//      {  
//         return 863;  
//      }  
//   }  
};  

int main() {  
   X^ x = new X;  
   System::Console::WriteLine(x[1]);   // C3915  
} 示例 Example 如果你尝试使用默认索引器在定义它与同一编译中的，也可能发生 C3915 DefaultMemberAttribute 。 C3915 can also occur if you attempt to consume a default indexer in the same compiland where it was defined with DefaultMemberAttribute . 下面的示例生成 C3915。 The following sample generates C3915. // C3915_b.cpp  
// compile with: /clr  
using namespace System;  

[Reflection::DefaultMember("XXX")]  
ref struct A {  
   property Double XXX[Double] {  
      Double get(Double data) {  
         return data*data;  
      }  
   }  
};  

ref struct B {  
   property Double default[Double] {  
      Double get(Double data) {  
         return data*data;  
      }  
   }  
};  

int main() {  
   A ^ mya = gcnew A();  
   Console::WriteLine("{0}", mya[3]);   // C3915  

   B ^ myb = gcnew B();  
   Console::WriteLine("{0}", myb[3]);   // OK  
}

编译器错误 C3917 Compiler Error C3917 11
属性：过时的构造声明样式一个属性或事件定义使用语法从之前的版本。有关详细信息，请参阅。示例

编译器错误 C3918 Compiler Error C3918 11
用法要求是数据成员可以出现原因有多种与事件相关。示例因为类成员需要在当前上下文中，会发生。下面的示例生成 C3918。 The following sample generates C3918. // C3918.cpp  
// compile with: /clr /c  
public ref class C {  
public:  
   System::Object ^ o;  
   delegate void Del();  

   event Del^ MyEvent {  
      void add(Del^ev) {  
         if ( MyEvent != nullptr) {}   // C3918  
         if ( o != nullptr) {}   // OK  
   }  
   void remove(Del^){}  
   }  
}; 示例 Example 如果你尝试检查常用事件为 null （事件名称将不再提供直接访问后备存储委托为事件），则也会导致 C3918。 C3918 is also caused if you try to check a trivial event for null (the event name will no longer provide direct access to the backing store delegate for the event). 下面的示例生成 C3918。 The following sample generates C3918. // C3918_2.cpp  
// compile with: /clr /c  
using namespace System;  
public delegate int MyDel(int);  

interface struct IEFace {  
   event MyDel ^ E;  
};  

ref struct EventSource : public IEFace {  
   virtual event MyDel ^ E;  
   void Fire_E(int i) {  
      if (E)   // C3918  
         E(i);  
   }  
}; 示例 Example 如果你错误地订阅事件，也会发生 C3918。 C3918 can also occur if you incorrectly subscribe to an event. 下面的示例生成 C3918。 The following sample generates C3918. // C3918_3.cpp  
// compile with: /clr /c  
using namespace System;  

public delegate void del();  

public ref class A {  
public:  
   event del^ e {  
      void add(del ^handler ) {  
         d += handler;  
      }  

      void remove(del ^handler) {  
         d -= handler;  
      }  

      void raise() {   
         d();  
      }  
   }  

   del^ d;  
   void f() {}  

   A() {  
      e = gcnew del(this, &A::f);   // C3918  
      // try the following line instead  
      // e += gcnew del(this, &A::f);  
      e();  
   }  
};  

int main() {  
   A a;  
}

编译器错误 C3919 Compiler Error C3919 11
：函数必须具有类型未正确声明事件访问器方法。有关事件的详细信息，请参阅事件。下面的示例生成 C3919: The following sample generates C3919: // C3919.cpp  
// compile with: /clr /c  
using namespace System;  
delegate void D(String^);  
ref class R {  
   event D^ e {  
      int add(int);   // C3919  
      int remove(int);   // C3919  

      void add(D^);   // OK  
      void remove(D^);   // OK  
   }  
};

编译器错误 C3920 Compiler Error C3920 11
运算符：不能定义后缀递增递减或运算符，调用后缀或运算符将调用相应的前缀或运算符，但具有后缀语义运行时和不支持后缀运算符并且不允许使用用户定义的后缀运算符。可以定义前缀运算符并且将其用于前递增和后递增操作。以下示例将生成，并演示如何修复此错误：

编译器错误 C3923 Compiler Error C3923 11
“”：不允许在或托管类的成员函数中使用局部类、结构或联合定义示例下列示例生成。