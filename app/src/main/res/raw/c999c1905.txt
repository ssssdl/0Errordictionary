错误 C1001 Fatal Error C1001 11
内部编译器编译器无法在分析中生成的构造，通常是由于特定表达式以及优化选项，或问题的组合的正确代码。如果列出的编译器文件具有或路径段，则可能会优化出错。如果文件具有或路径段，或者是，它可能是分析器错误。如果名为的文件，没有其他信息可用。通常可以通过删除一个或多个优化选项来修复优化问题。若要确定哪个选项有故障，请移除一个选项一个时间并重新编译之前的错误消息将消失。最常负责选项（全局优化）和（生成内部函数）。一旦你确定哪个优化选项负责，也可以禁用它通过使用出现错误的函数优化杂注，并继续使用该模块中的其余的选项。有关优化选项的详细信息，请参阅优化最佳做法。如果优化不负责该错误，请尝试重写其中报告错误，一行或几行的代码周围的行。若要查看的代码的方法，编译器可以看到该预处理后，可以使用（预处理到文件）选项。有关如何隔离错误根源以及如何向报告内部编译器错误的详细信息，请参阅如何报告使用工具集的问题。

错误 C1002 Fatal Error C1002 11
在第遍中编译器的堆空间不足在第二个阶段，可能由于具有过多符号或复杂表达式的程序发生过程，编译器用尽了动态内存空间。使用以下可能的解决方案进行修复将源文件划分为若干较小的文件。将表达式分解为较小的子表达式。删除其他程序或驱动程序占用的内存。

错误 C1003 Fatal Error C1003 11
错误计数超过数目；正在停止编译程序中的错误太多，无法恢复。编译器必须终止。

错误 C1004 Fatal Error C1004 11
中的意外的结束的文件编译器未解析构造达到源文件的末尾。该代码可能缺少以下元素之一：右大括号右括号结束注释标记分号若要解决此错误，请查看以下信息：默认磁盘驱动器没有足够的空间用于临时文件，需要大约两倍于源文件所在的空间。指令计算结果为缺少右指令。源文件不以回车符和换行符结尾。下面的示例生成 C1004: The following sample generates C1004: // C1004.cpp  
#if TEST  
int main() {}  
// C1004 可能的解决方法： Possible resolution: // C1004b.cpp  
#if TEST  
#endif  

int main() {}

错误 C1005 Fatal Error C1005 11
字符串过大，无法缓冲编译器中间文件内的字符串溢出了缓冲区。当你传递到或编译器选项的参数大于个字节时，可能会遇到此错误。

错误 C1007 Fatal Error C1007 11
选项中无法识别的标志字符串命令行选项包含无效的字符串。检查命令行和环境变量是否存在错误。

错误 C1008 Fatal Error C1008 11
没有指定输入文件未提供或源文件供编译器编译。检查命令行和环境变量是否符合文件名规范。

错误 C1009 Fatal Error C1009 11
编译器限制：宏嵌套太深编译器尝试在同一时间展开太多的宏。编译器已限制为级别的嵌套宏。嵌套的宏拆分为更简单的宏。

错误 C1010 Fatal Error C1010 11
查找预编译头时意外的文件尾。是否忘记添加名称对源？使用指定的包含文件源文件中未列出。默认情况下，在大多数项目类型中启用了此选项，并且默认值包括此选项指定的文件。在环境中，使用以下方法之一来解决此错误：如果你的项目中不使用预编译标头，设置创建使用预编译标头属性源文件复制到不使用预编译头。若要设置此编译器选项，请按照下列步骤：在项目的解决方案资源管理器窗格中，右键单击项目名称，然后单击属性。在左窗格中，单击文件夹。单击预编译标头节点。在右窗格中，单击创建使用预编译标头，然后单击不使用预编译头。请确保不要意外删除、重命名或删除了标头文件默认情况下，从当前项目。此文件还需要在你使用的源文件中的任何其他代码之前包含。此标头文件指定为通过文件创建使用项目属性

错误 C1012 Fatal Error C1012 11
括号不匹配：缺少字符预处理器指令中的括号不匹配。

错误 C1013 Fatal Error C1013 11
编译器限制左括号太多表达式在单个表达式中包含太多级别的括号。简化表达式，或将其分解为多个语句。在之前，单个表达式中嵌套括号的上限是个。目前，嵌套括号的上限是个。

错误 C1014 Fatal Error C1014 11
包含文件太多：深度指令的嵌套太深。嵌套指令可以包括打开的文件。包含该指令的源文件计为一个文件。

错误 C1016 Fatal Error C1016 11
预期标识符应输入标识符条件编译指令（或）没有要计算的标识符。若要解决此错误，请指定标识符。下面的示例生成 C1016： The following sample generates C1016: // C1016.cpp  
#ifdef   // C1016  
#define FC1016  
#endif  

int main() {} 可能的解决方法： Possible resolution: // C1016b.cpp  
#ifdef X  
#define FC1016  
#endif  

int main() {}

错误 C1017 Fatal Error C1017 11
无效的整数常量表达式中的表达式指令不存在或计算结果不为常量。使用定义的常量必须具有如果中使用的计算结果为整数常量的值，，或指令。下面的示例生成 C1017: The following sample generates C1017: // C1017.cpp  
#define CONSTANT_NAME "YES"  
#if CONSTANT_NAME   // C1017  
#endif 可能的解决方法： Possible resolution: // C1017b.cpp  
// compile with: /c  
#define CONSTANT_NAME 1  
#if CONSTANT_NAME  
#endif 因为 CONSTANT_NAME 计算结果为字符串而不是整数， #if 指令生成错误 C1017。 Because CONSTANT_NAME evaluates to a string and not an integer, the #if directive generates fatal error C1017. 在其他情况下，预处理器会作为零计算未定义的常数。 In other cases, the preprocessor evaluates an undefined constant as zero. 下面的示例中所示，这可能导致意外的结果。 This can cause unintended results, as shown in the following sample. YES 未定义，所以它的计算结果为零。 YES is undefined, so it evaluates to zero. 表达式 #if``CONSTANT_NAME 计算结果为 false，将使用上代码 YES 由预处理器移除。 The expression #if CONSTANT_NAME evaluates to false and the code to be used on YES is removed by the preprocessor. NO 也是不确定 （零），因此 #elif``CONSTANT_NAME==NO 计算结果为 true ( 0 == 0 )，导致预处理器将中的代码 #elif 语句部分 — 完全相反的预期行为。 NO is also undefined (zero), so #elif CONSTANT_NAME==NO evaluates to true ( 0 == 0 ), causing the preprocessor to leave the code in the #elif portion of the statement — exactly the opposite of the intended behavior. // C1017c.cpp  
// compile with: /c  
#define CONSTANT_NAME YES  
#if CONSTANT_NAME  
   // Code to use on YES...  
#elif CONSTANT_NAME==NO  
   // Code to use on NO...  
#endif 若要查看完全编译器如何处理预处理器指令，使用 /P ， /E ，或 /EP 。 To see exactly how the compiler handles preprocessor directives, use /P , /E , or /EP .

错误 C1018 Fatal Error C1018 11
意外的指令出现在、或构造外部。仅在这些构造之一中使用。下面的示例生成 C1018： The following sample generates C1018: // C1018.cpp  
#elif      // C1018  
#endif  

int main() {} 可能的解决方法： Possible resolution: // C1018b.cpp  
#if 1  
#elif  
#endif  

int main() {}

错误 C1019 Fatal Error C1019 11
意外的指令出现在、或构造外部。仅在这些构造之一中使用。下面的示例生成 C1019： The following sample generates C1019: // C1019.cpp  
#else   // C1019  
#endif  

int main() {} 可能的解决方法： Possible resolution: // C1019b.cpp  
#if 1  
#else  
#endif  

int main() {}

错误 C1020 Fatal Error C1020 11
意外的指令有没有匹配的、或指令。确保每个具有匹配的指令。下面的示例生成 C1020： The following sample generates C1020: // C1020.cpp  
#endif     // C1020 可能的解决方法： Possible resolution: // C1020b.cpp  
// compile with: /c  
#if 1  
#endif

错误 C1021 Fatal Error C1021 11
无效的预处理器命令“”不是有效的预处理器指令。若要解决此错误，请使用对于有效预处理器名称。下面的示例生成 C1021： The following sample generates C1021: // C1021.cpp  
#BadPreProcName    // C1021 delete line

错误 C1022 Fatal Error C1022 11
应输入、或指令没有匹配的指令。确保每个、或都有一个相匹配的。以下示例生成：可能的解决方法：

错误 C1023 Fatal Error C1023 11
“”：发生有关的意外错误，请尝试重新生成可能由多个问题导致，其解决方案是重新生成预编译标头文件。如果尝试在生成预编译标头文件的计算机以外的计算机上使用该标头文件，则可能会导致。

错误 C1026 Fatal Error C1026 11
分析器堆栈溢出，程序太复杂分析程序所需的空间导致编译器堆栈溢出。降低通过表达式的复杂性：减少在中的使用嵌套和语句。将更深入地嵌套的语句放置在单独的函数。中断性长涉及逗号运算符或函数调用的表达式。

错误 C1033 Fatal Error C1033 11
无法打开程序数据库可以通过磁盘错误导致此错误。有关详细信息，请参阅。

错误 C1035 Fatal Error C1035 11
表达式太复杂；简化表达式编译器无法生成复杂表达式的代码。将表达式拆分成更简单的表达式并重新编译。

错误 C1037 Fatal Error C1037 11
无法打开对象文件的文件名无法打开由指定的对象文件。通过检查以下可能的原因进行修复文件名无效。内存不足，无法打开该文件。另一个进程正在使用该文件。一个只读文件具有相同的名称。

错误 C1038 Fatal Error C1038 11
编译器限制：：控制流状态太复杂；请简化函数该函数具有的控制流状态比编译器能够处理的多。简化控制流或者将该函数拆分为更小的函数。

错误 C1045 Fatal Error C1045 11
编译器限制链接规范嵌套太深嵌套的外部对象超过编译器限制。允许嵌套的外部项使用外部链接类型，如“”。减少嵌套的外部项的数量以解决该错误。

错误 C1046 Fatal Error C1046 11
编译器限制：结构嵌套太深结构、联合或类超出嵌套限制，这是个级别。重写的定义，以减少嵌套级别。结构、联合或类通过拆分成两个或多个部分使用定义一个或多个嵌套的结构。

错误 C1047 Fatal Error C1047 11
对象或库文件“”是使用比创建其他对象所用编译器旧的编译器创建的；请重新生成旧的对象和库当使用生成的对象文件或库链接在一起，而这些对象文件或库是用不同版本的工具集生成的，则会导致。当你开始使用新版本的编译器，而不完全重新生成现有对象文件或库时，可能出现这种情况。若要解决，请重新生成所有对象文件或库。

错误 C1051 Fatal Error C1051 11
程序数据库文件，具有过时的格式，将其删除并重新编译编译器无法更新程序数据库文件的较旧的版本号。删除文件并重新编译您的程序与或。有关详细信息，请参阅、、（调试信息格式）

错误 C1053 Fatal Error C1053 11
标识符：函数太大该函数太大，无法编译。使用以下可能的解决方案进行修复请尝试编译但不优化。将函数拆分为较小的函数。减少对内联函数的调用。

错误 C1054 Fatal Error C1054 11
编译器限制：初始值设定项嵌套太深代码超过初始值设定项（级别，具体取决于正在初始化的类型的组合）的嵌套限制。使用以下可能的解决方案进行修复简化正在初始化以减少嵌套的数据类型。初始化声明后的单独的语句中的变量。

错误 C1055 Fatal Error C1055 11
编译器限制：超出键源文件包含太多的符号。编译器用尽了符号表的哈希键。使用以下可能的解决方案进行修复源文件拆分成较小的文件。消除不必要的标头文件。重复使用而不是创建新的临时和全局变量。

错误 C1057 Fatal Error C1057 11
宏扩展中遇到意外的文件结束编译器在收集宏调用参数，可能是由于宏调用中缺少右括号时达到源文件的末尾。

错误 C1060 Fatal Error C1060 11
编译器的堆空间不足操作系统或运行时库无法满足内存要求。若要修复此错误，请尝试以下可能的解决方案如果编译器还发出错误和，使用编译器选项减少内存分配限制。如果减少剩余内存分配，更多堆空间可用于应用程序。如果选项已设置，请尝试将其删除。堆空间可能已用完，因为选项中指定的内存分配限制太高。编译器使用的默认限制，如果你删除选项。如果你正在位平台上进行编译，请使用位编译器工具集。有关信息，请参阅如何：启用位工具集在命令行上的。在位上，请尝试使用开关。增加交换文件的大小。关闭其他正在运行的程序。消除不需要的包含文件。消除不需要的全局变量，例如，通过动态分配内存而不是声明一个大数组。消除未使用的声明。将当前文件拆分成更小的文件。

错误 C1061 Fatal Error C1061 11
编译器限制块嵌套太深代码块的嵌套超过嵌套级的限制。在位和位工具集中，这对于和的编译器都是硬性限制。创建范围或块的任何内容都能增加嵌套级别的计数。例如，命名空间、使用指令、预处理器扩展、模板扩展、异常处理、循环构造和子句都能增加编译器看到的嵌套级别。若要修复此错误，则必须重构代码。在任何情况下，深度嵌套的代码都是难以理解和解释的。重构代码以减少嵌套级别可提高代码质量和简化维护。将深度嵌套代码分解为从原始上下文调用的函数。限制块内的循环或链接的的子句的数量。

错误 C1064 Fatal Error C1064 11
编译器限制：标记已溢出内部缓冲区标识符超过标识符所使用的内部缓冲区的长度。缩短的名称。

错误 C1065 Fatal Error C1065 11
编译器限制：超出标记源文件包含超过个类、结构、联合、命名空间或枚举。文件拆分成较小的文件。

错误 C1067 Fatal Error C1067 11
编译器限制：已超出类型记录的大小的限制如果符号的修饰的名超过个字符，则可能发生此错误。若要解决，缩短符号名称。当编译器生成调试信息时，它会发出类型记录，以定义在源代码中遇到的类型。例如，类型记录包括简单的结构和函数的自变量列表。这些类型记录的一些可能是大型列表。任何类型记录的大小上没有的限制。如果超出该限制将发生此错误。如果没有具有较长名称的多个符号，或者某个类、结构或联合具有成员太多，也可能发生。

错误 C1068 Fatal Error C1068 11
无法打开文件“”确保未被其他程序使用。

错误 C1070 Fatal Error C1070 11
文件“”中的对不匹配、或指令没有对应的。下面的示例生成 C1070： The following sample generates C1070: // C1070.cpp  
#define TEST  

#ifdef TEST  

#ifdef TEST  
#endif  
// C1070 可能的解决方法： Possible resolution: // C1070b.cpp  
// compile with: /c  
#define TEST  

#ifdef TEST  
#endif  

#ifdef TEST  
#endif

错误 C1071 Fatal Error C1071 11
在注释中遇到意外的文件结束在扫描注释时，编译器到达文件末尾。通过检查以下可能的原因进行修复缺少注释终止符。源文件的最后一行注释后缺少的换行符。下面的示例生成 C1071: The following sample generates C1071: // C1071.cpp  
int main() {  
}  

/* this comment is fine */  
/* forgot the closing tag        // C1071

错误 C1073 Fatal Error C1073 11
涉及增量编译（编译器文件、行号）的内部错误重新编译而无需使用增量编译的文件。

错误 C1074 Fatal Error C1074 11
“”是文件的非法扩展名编译器需要程序数据库的扩展名为。

错误 C1075 Fatal Error C1075 11
左侧标记与文件结尾不匹配编译器应在到达文件结尾之前匹配标记。导致此错误的原因可能是不匹配的括号、大括号或其他成对字符。

错误 C1076 Fatal Error C1076 11
编译器限制达到内部堆限制；使用指定更高的限制此错误可能是由过多符号或过多模板实例化引起的。解决此问题的方法是：使用选项将编译器内存限制设置中指定的值为错误消息。有关详细信息，包括如何在中设置此值，请参阅备注部分中的（指定预编译头内存分配限制）。如果正在位操作系统中使用位托管编译器，请改用位托管编译器。有关详细信息，请参阅如何：启用位工具集在命令行上的。消除不需要的包含文件。消除不需要的全局变量，例如，动态分配内存而不是声明一个大数组。—消除未使用的声明。将大函数拆分为更小的函数。将大类拆分为更小的类。将当前文件拆分成更小的文件。如果指定的值在生成开始后，立即，则会发生而言可能太高为您的程序。减少值。

错误 C1077 Fatal Error C1077 11
编译器限制：命令行选项数不得超过其限定值命令行选项数超过了内部限制。可能多用定义的符号太多。（改为将定义放置在头文件中。）

错误 C1079 Fatal Error C1079 11
编译器限制：超出文件大小限制文件超过大小限制。

错误 C1080 Fatal Error C1080 11
编译器限制：命令行选项超出限制的数字字符传递给编译器的参数超过个字符。

错误 C1081 Fatal Error C1081 11
：文件名太长文件的路径名的长度超过（由定义为个字符）。缩短文件的名称。如果用短文件名调用，编译器可能需要生成完整的路径名。例如，可能会导致编译器生成：

错误 C1082 Fatal Error C1082 11
无法关闭文件：“”：消息如果消息指出“文件号错误”，说明此文件在后台进行编译的同时，可能已在前台关闭。

错误 C1083 Fatal Error C1083 11
无法打开文件文件消息它找不到它需要的文件时，编译器将生成错误。’有许多可能的原因，此错误。不正确的包含搜索路径或丢失或拼错的标头文件的最常见的原因，但其他文件类型和问题也可能导致。以下是一些编译器生成此错误的常见原因。指定的文件名错误文件名可能键入有误。例如，应用于对象的可能找不到你想要的文件。大多数标准库头文件没有文件扩展名。算法标头将找不到此指令。若要解决此问题，请验证输入了正确的文件名称，如此示例所示：某些运行库标头位于标准包含目录的子目录中。例如，若要包含，必须包括在将子目录名称指令：在包含搜索路径中未包括的文件此编译器无法使用或指令指示的搜索规则找到该文件。例如，标头文件名用引号引起来，这将告知编译器查找首先，包含源文件的相同目录中的文件，然后在生成环境指定的其他位置查找。如果引号包含绝对路径，则编译器仅在该位置查找文件。如果引号包含相对路径，则编译器在相对于源目录的目录中查找文件。如果名称括在尖括号中，编译器遵循生成环境中，定义的搜索路径编译器选项，编译器选项和包括环境变量。有关详细信息，包括有关使用查找的文件的搜索顺序的特定详细信息，请参阅指令（）和指令。如果你包含文件位于相对于你的源目录，另一个目录，并且你使用的相对路径你指令，你必须使用双引号括起来，而不是命令的尖括号。例如，如果你标头文件在项目源文件名为标头的子目录中，然后此示例中未能找到该文件并导致但是，此示例中的工作：此外可以与目录上包含搜索路径使用相对路径。如果你添加到目录包括环境变量或你包含目录路径在中，不要还为指令添加路径的一部分。例如，如果你标头位于，并添加到你包含目录路径在中，但你指令引用作为文件

错误 C1084 Fatal Error C1084 11
无法读取文件：“”消息此错误通常是由编译器无法执行内部系统调用造成的。显示当遇到此错误的消息通常通过以下任一方法生成或。执行以下步骤可帮助解决错误：请确保指定的文件存在。请确保设置了访问指定文件所需的相应权限。确保命令行语法遵从中所述的规则编译器命令行语法。另请确保环境变量和经过适当的组，以及适当的权限才能访问这些环境变量所引用的目录。此外确保按所引用的驱动器和环境变量包含足够的可用空间量。如果消息指出“文件号错误”，说明指定的文件在后台进行编译的同时，可能已在前台关闭。执行上面的诊断后，请执行干净的生成。

错误 C1085 Fatal Error C1085 11
无法写入文件：消息通过检查以下可能的原因进行修复驱动器是只读的。驱动器已满。共享冲突。如果消息指出“文件号错误”，说明此文件在后台进行编译的同时，可能已在前台关闭。

错误 C1086 Fatal Error C1086 11
无法查找文件：“”：消息编译器无法完成某个操作。

错误 C1087 Fatal Error C1087 11
无法辨别文件：“”：消息编译器无法完成某个操作。

错误 C1088 Fatal Error C1088 11
无法刷新文件“”消息编译器无法完成某个操作。

错误 C1089 Fatal Error C1089 11
无法截断文件“文件”消息编译器不能将文件缩小到零长度。

错误 C1091 Fatal Error C1091 11
编译器限制：字符串长度超过“”个字节字符串常量超过当前的字符串长度限制。你可能希望将静态字符串拆分为两个（或更多）变量，以及使用在声明或在运行时联接结果。

错误 C1092 Fatal Error C1092 11
“编辑并继续”不支持对数据类型的更改；需要生成更改或自上次成功生成以来添加的数据类型。编辑并继续不支持对现有的数据类型，包括类、结构或枚举定义的更改。你必须停止调试并生成应用程序。编辑并继续不支持添加新的数据类型，如果程序数据库文件，如其中是在使用的主要版本是只读的。若要添加的数据类型，编译器必须在写入模式下打开文件。若要删除此错误，而无需结束当前调试会话将数据类型改回其在发生错误前的状态。在“调试”菜单中选择“应用代码更改”。若要在不更改源代码的情况下删除此错误在“调试”菜单上，选择“停止调试”。在“生成”菜单上，选择“生成”。有关详细信息，请参阅受支持的代码更改。

错误 C1093 Fatal Error C1093 11
调用函数名称失败的调用的位置运行时从文本对函数的调用失败。从运行时文本可能或可能未提供的运行时。有关系统错误消息的详细信息，请参阅系统文件，和。

错误 C1094 Fatal Error C1094 11
：命令行选项是与用于生成预编译标头的值不一致传递到值必须是相同的值传递给值必须在所有编译中，使用或创建相同的预编译相同标头文件）。下面的示例生成 C1094: The following sample generates C1094: // C1094.h  
int func1(); 然后， And then, // C1094.cpp  
// compile with: /Yc"C1094.h" /Zm200  
int u;  
int main() {  
   int sd = 32;  
}  
#include "C1094.h" 然后， And then, // C1094b.cpp  
// compile with: /Yu"C1094.h" /Zm300 /c  
#include "C1094.h"   // C1094 compile with /Zm200  
void Test() {}

错误 C1098 Fatal Error C1098 11
版本与“编辑并继续”引擎不匹配正在使用的调试器版本与用来创建可执行文件的编译器不匹配。如果重新编译不能解决问题，则可能需要重新安装，以确保拥有正确的调试器和编译器版本。

错误 C1099 Fatal Error C1099 11
“编辑并继续”引擎正在终止编译“编辑并继续”在准备进行编译代码更改的过程中加载了一个预编译头文件，但后续操作（例如预编译头语句前的代码更改或停止调试器）阻止“编辑并继续”使用该进程完成编译。不需要执行任何操作来修复此错误。

错误 C1100 Fatal Error C1100 11
无法初始化：系统错误消息编译器无法初始化组件对象模型库。请参阅。

错误 C1103 Fatal Error C1103 11
导入时遇到错误：“”导入类型库时编译器检测到问题。例如，你不能使用指定类型库，同时还指定。有关详细信息，请参阅指令。下面的示例生成 C1103： The following sample will generate C1103: // C1103.cpp  
#import "progid:a.b.id.1.5" no_registry auto_search   // C1103

错误 C1104 Fatal Error C1104 11
导入时遇到错误：“”导入类型库时编译器检测到问题。例如，你不能使用指定类型库，同时还指定。有关详细信息，请参阅指令。下面的示例生成 C1104： The following sample will generate C1104: // C1104.cpp  
#import "libid:11111111.1111.1111.1111.111111111111" version("4.0") lcid("9") no_registry auto_search   // C1104

错误 C1107 Fatal Error C1107 11
找不到程序集：请指定程序集搜索路径中使用或通过设置环境变量元数据文件已传递到编译器找不到的指令。中的主题所述，和编译器选项，你可以指定在其中编译器将查找引用元数据文件的目录。

错误 C1108 Fatal Error C1108 11
找不到：“”在路径中找不到指定的。若要解决此错误，请重新安装或将相应的文件从安装复制到计算机。

错误 C1109 Fatal Error C1109 11
在“”中找不到“入口点”在编译器所需的延迟加载中找不到入口点。

错误 C1113 Fatal Error C1113 11
使用在上失败仅中间语言格式的文件可以传递给指令。编译器选项允许你创建的输出文件。其他语言还生成文件。

错误 C1120 Fatal Error C1120 11
调用失败此错误指示需要重新安装。

错误 C1121 Fatal Error C1121 11
调用失败编译器会生成与的调用和调用失败。重新安装，并可能重新安装操作系统。

错误 C1126 Fatal Error C1126 11
：自动分配超过大小为本地变量的函数（加上使用的编译器，如用于可交换函数的额外字节的空间有限）分配的空间超过了限制。若要更正此错误，使用或分配大量的数据。

错误 C1128 Fatal Error C1128 11
节数超过对象文件格式限制：请使用进行编译文件超出允许的节，对象文件格式限制的数目。达到此部分限制可能是由于使用和调试版本导致函数进入自己节。在调试版本中，没有用于每个函数的调试信息节。有太多的内联函数时，还可能导致。若要更正此错误，将源文件划分为多个源代码文件，而无需编译，或使用编译（增加的节数中。文件）。如果您不编译与，你将需要单独，指定优化由于和均暗指。如果可能，编译不使用调试信息。你可能还需要在单独的源的代码文件，具有特定的模板实例，而不是让编译器发出。当移植代码，可能时将出现第一次使用编译器和很多更高版本与编译器。将具有与编译每个函数相关联的至少个节或内联从模板或类内联：编码，，和调试信息以及可能。无。’

错误 C1189 Fatal Error C1189 11
错误：用户提供错误消息由生成指令。开发人员代码指令指定的错误消息的文本。有关详细信息，请参阅指令（）。下面的示例生成 C1189。 The following sample generates C1189. 在示例中，开发人员发出自定义错误消息，因为 _WIN32 未定义标识符： In the sample, the developer issues a custom error message because the _WIN32 identifier is not defined: // C1189.cpp  
#undef _WIN32  
#if !defined(_WIN32)  
#error _WIN32 must be defined   // C1189  
#endif 你可能还会看到此错误，如果使用生成 ATL 项目 / 可靠 MIDL 编译器选项。 You might also see this error if you build an ATL project by using the /robust MIDL compiler option. 使用 / 可靠 开关可仅生成 Windows 2000 Windows 2000 和更高版本的 Windows。 Use the /robust switch to build only Windows 2000 Windows 2000 and later versions of Windows. 请执行以下步骤以更正此错误： To correct this error, use one of the following procedures: 将此行 dlldatax.c 文件中的更改： Change this line in the dlldatax.c file: #define _WIN32_WINNT 0x0400   // for WinNT 4.0 or Windows 95 with DCOM 更改为： to: #define _WIN32_WINNT 0x0500   // for WinNT 4.0 or Windows 95 with DCOM 使用 高级 中的属性页 MIDL 要删除的属性页文件夹 / 可靠 开关，然后指定 /no_robust 切换。 Use the Advanced property page in the MIDL property page folder to remove the /robust switch and then specify the /no_robust switch. 有关详细信息，请参阅 MIDL 属性页： 高级 。 For more information, see MIDL Property Pages: Advanced . 请参阅 See Also #define 指令 (C/C++) #define Directive (C/C++)

错误 C1190 Fatal Error C1190 11
托管目标代码需要“”选项你当前使用的是构造，但未指定。有关更多信息，请参见。下面的示例生成 C1190： The following sample generates C1190: // C1190.cpp  
// compile with: /c  
__gc class A {};   // C1190  
ref class A {};

错误 C1191 Fatal Error C1191 11
只能在全局范围内导入指令导入使用编程的程序不能出现在命名空间或函数，但必须出现在全局范围内。下面的示例生成 C1191: The following sample generates C1191: // C1191.cpp  
// compile with: /clr  
namespace sample {  
   #using <mscorlib.dll>   // C1191 not at global scope  
} 可能的解决方法： Possible resolution: // C1191b.cpp  
// compile with: /clr /c  
#using <mscorlib.dll>  
namespace sample {}

错误 C1192 Fatal Error C1192 11
使用在上失败仅中间语言格式的文件可以传递给指令。编译器选项允许你创建的输出文件。其他语言还生成文件。

错误 C1196 Fatal Error C1196 11
“”：在类型库“”中找到的标识符不是有效的标识符类型库中有一个标识符不是有效的标识符。类型库不可与一起使用。

错误 C1197 Fatal Error C1197 11
不能引用，因为程序已经引用编译器符合公共语言运行时的版本。但是，已尝试从早期版本中引用的公共语言运行时文件的版本。若要解决此错误，只能引用与编译所用的版本附带的公共语言运行时版本中的文件。示例下面的示例生成 C1197: The following sample generates C1197: // C1197.cpp  
// compile with: /clr /c  
// processor: x86  
#using "C:\Windows\Microsoft.NET\Framework\v1.1.4322\mscorlib.dll"   // C1197  
// try the following line instead  
// #using "mscorlib.dll"

错误 C1201 Fatal Error C1201 11
类模板定义中出现语法错误后无法继续分析类模板定义时出现意外错误。修复任何其他错误并重新编译。若失败，请注意错误的情况，可尝试隔离问题并创建可重现的测试用例，然后联系产品支持服务。

错误 C1202 Fatal Error C1202 11
递归类型或函数依赖项上下文太复杂模板定义为递归，或者超出复杂性限制。示例下面的示例生成 C1202。 The following sample generates C1202. // C1202.cpp  
// processor: x86 IPF  
template<int n>   
class Factorial : public Factorial<n-1>  {   // C1202  
public:  
   operator int () {   
      return Factorial <n-1>::operator int () * n;   
   }  
};  
Factorial<7> facSeven; 示例 Example 可能的解决方法。 Possible resolution. // C1202b.cpp  
// compile with: /c  
template<int n>   
class Factorial : public Factorial<n-1> {  
public:  
   operator int () {   
      return Factorial <n-1>::operator int () * n;   
   }  
};  

template <>  
class Factorial<0> {  
public:  
   operator int () {   
      return 1;   
   }  
};  

Factorial<7> facSeven;

错误 C1205 Fatal Error C1205 11
安装的运行时版本不支持这些泛型编译器所使用的公共语言运行时版本不是当前编译器支持的运行时版本。例如，泛型功能要求与编译器匹配的运行时。你的路径说明可能需要修改。

错误 C1206 Fatal Error C1206 11
安装的运行时版本不支持数据某些功能（如每个应用程序域数据）只由支持该功能的公共语言运行库支持。指出计算机上未安装运行库的最新版本。请安装适用于你的编译器的公共语言运行时版本。有关更多信息，请参见。

错误 C1207 Fatal Error C1207 11
安装的运行时版本不支持托管模板使用的编译器是当前版本而公共语言运行时是早期版本时将发生错误。编译器的一些功能在早期的运行时版本中可能无效。若要解决问题，请安装你的编译器专用的公共语言运行时版本。

错误 C1208 Fatal Error C1208 11
安装的运行时版本不支持在堆栈上分配引用类使用的编译器是当前版本而公共语言运行时是早期版本时将发生。编译器的一些功能在早期的运行时版本中可能无效。请安装适用于你的编译器的公共语言运行时版本。

错误 C1209 Fatal Error C1209 11
安装的运行时版本不支持友元程序集使用的编译器是当前版本而公共语言运行时是早期版本时将发生。编译器的一些功能在早期的运行时版本中可能无效。若要解决，请安装随正在使用的编译器附带的公共语言运行时。有关详细信息，请参阅友元程序集（）。

错误 C1210 Fatal Error C1210 11
安装的运行时版本不支持和和编译器选项在中已弃用。使用的编译器是当前版本而公共语言运行时是早期版本时将发生。编译器的一些功能在早期的运行时版本中可能无效。若要解决，请安装适用于你的编译器的公共语言运行时版本。

错误 C1211 Fatal Error C1211 11
安装的运行时版本不支持自定义特性使用的编译器是当前版本而公共语言运行时是早期版本时将发生。编译器的一些功能在早期的运行时版本中可能无效。若要解决，请安装随当前所使用编译器一起提供的公共语言运行时。有关详细信息，请参阅类型转发。

错误 C1305 Fatal Error C1305 11
配置文件数据库是用于不同的体系结构操作的另一个平台传递到已生成的文件。按配置优化可用于和平台。但是，与为平台操作生成的文件不是有效作为输入到为不同的平台。若要解决此错误，仅传递使用到同一平台上创建一个文件。

错误 C1307 Fatal Error C1307 11
自收集配置文件数据后已编辑了程序使用时、链接器检测到后已重新编译输入的模块和模块已更改为其中现有配置文件数据已不再相关的点。例如，如果在重新编译的模块中更改的调用关系图，编译器将生成。若要解决此错误，运行、重做所有测试运行，并运行。如果你不能运行和重做所有测试运行，使用而不是创建优化的映像。

错误 C1308 Fatal Error C1308 11
不支持链接程序集允许作为链接器输入，但程序集不能。如果尝试链接使用编译的程序集可以生成此错误。有关详细信息，请参阅用作链接器输入的文件。下面的示例生成 C1308: The following sample generates C1308: // C1308.cpp  
// compile with: /clr:safe /LD  
public ref class MyClass {  
public:  
   int i;  
}; 然后 and then, // C1308b.cpp  
// compile with: /clr /link C1308b.obj C1308.dll  
// C1308 expected  
#using "C1308.dll"  
int main() {  
   MyClass ^ my = gcnew MyClass();  
}

错误 C1309 Fatal Error C1309 11
不匹配的的版本。和版本。使用用于生成和使用的工具集按配置文件优化包含不匹配的组件。如果无法手动解决此错误，请重新安装。

错误 C1310 Fatal Error C1310 11
按配置优化不能与一起使用你不能将与任何用编译的模块进行链接。以下示例生成：

错误 C1311 Fatal Error C1311 11
格式无法以静态方式初始化具有数字字节的地址在编译时不知道其值的地址不能以静态方式分配给其类型具有不超过四个字节的存储变量。上，则代码可能会发生此错误有效的。以下示例显示了可能导致的一种情况。

错误 C1312 Fatal Error C1312 11
函数中的条件分支太多。简化或重构源代码。此代码太过复杂，编译器无法在不耗尽堆栈内存的情况下进行处理。简化代码。

错误 C1313 Fatal Error C1313 11
编译器限制：类型块嵌套深度不能深于数字级别异常处理（或结构化的异常处理）块嵌套太深。简化代码。

错误 C1350 Fatal Error C1350 11
加载时出错：没有找到找不到支持所尝试的操作的。这表明你的安装问题，应从产品光盘重新安装该。

错误 C1351 Fatal Error C1351 11
加载时出错：不兼容的版本找到了错误版本的。这表明你的安装问题，应重新安装。

错误 C1352 Fatal Error C1352 11
函数“”模块“”中的无效或已损坏向编译器传递了一个文件，但编译器检测出该文件已损坏。向生成该文件的人员询问有关情况。编译器并不检查文件中所有类型的损坏。但它检查函数中的所有控制路径是否包含返回语句。有关详细信息，请参阅用作链接器输入的文件。

错误 C1353 Fatal Error C1353 11
元数据操作失败未安装运行时或运行时版本不匹配重新安装或。

错误 C1382 Fatal Error C1382 11
已重新生成文件由于在生成时。请重新生成此对象使用时，编译器检测到指向了它比新的文件。文件中的信息已过期。重新生成对象。如果使用进行编译也可能发生，但还将多个源代码文件传递到编译器。若要解决，不要使用时将多个源传递给编译器的代码文件。有关详细信息，请参阅（创建预编译标头文件）。

错误 C1383 Fatal Error C1383 11
编译器选项与安装的公共语言运行时版本不兼容将以前版本的公共语言运行时与较新编译器结合使用时，以及使用和进行编译时，会发生。要进行解决，请勿将与结合使用，或是安装随你的编译器附带的公共语言运行时版本。有关详细信息，请参阅和。

错误 C1506 Fatal Error C1506 11
无法恢复的块范围错误块已太大，无法编译。通过检查以下可能的原因进行修复大括号不匹配非常大的函数或类

错误 C1508 Fatal Error C1508 11
编译器限制：“”：多于个参数字节函数的形参超过个字节的限制。

错误 C1509 Fatal Error C1509 11
编译器限制：函数中的有太多异常处理程序状态。简化函数代码超过异常处理程序状态（个状态）的内部限制。最常见原因是该函数包含用户定义的类变量和算术运算符的复杂表达式。使用以下可能的解决方案进行修复通过将公共子表达式分配给临时变量来简化表达式。将函数拆分为较小的函数。

错误 C1601 Fatal Error C1601 11
不支持的内联程序集操作码此错误指示编译器文件，这可能是由于不完整的安装中不匹配。例如，你可能已安装但不是处理器包。安装所有必需的产品。

错误 C1602 Fatal Error C1602 11
不支持的内部函数此错误指示编译器文件，这可能是由于不完整的安装中不匹配。例如，你可能已安装但不是处理器包。安装所有必需的产品。

错误 C1603 Fatal Error C1603 11
内联程序集分支目标超出范围个字节大于个字节之间或指令和其指定的目标标签的计算的距离。更新你的代码，以便标签为更接近于指令。

错误 C1852 Fatal Error C1852 11
“”不是有效的预编译头文件文件不是预编译头文件。通过检查以下可能的原因进行修复使用或指定的无效文件。如果未另行指定，编译器将假定为文件扩展名。

错误 C1853 Fatal Error C1853 11
预编译标头文件从早期版本的编译器，或者预编译标头为，在你使用它从（或相反）可能的原因：预编译标头是与以前的编译器版本编译的。尝试重新编译使用当前编译器的标头。预编译标头为和。请尝试重新与一起使用的标头编译通过指定之一从使用编译器选项，或更改的源文件的后缀为。有关详细信息，请参阅预编译代码的两种方法。

错误 C1854 Fatal Error C1854 11
无法覆盖创建对象文件中的预编译标头的过程中形成的信息你指定（使用预编译标头文件）选项后指定（创建预编译标头文件）相同的文件的选项。若要解决此问题，通常情况下，只有一个文件在项目中设置你要通过使用编译选项，然后将所有其他文件来通过编译设置选项。有关详细信息的使用选项，以及如何在中设置它，请参阅（创建预编译标头文件）。有关如何使用预编译标头的详细信息，请参阅创建预编译标头文件。

错误 C1902 Fatal Error C1902 11
程序数据库管理器不匹配请检查安装程序数据库文件使用较新版本的创建比你系统上找到编译器。此错误通常表示或缺少或者具有不同的版本比。中占位符随每个产品版本的文件名称更改。例如，在中，文件名为。）确保匹配版本的、和你系统上安装。确保不具有已不匹配的版本复制到包含目标平台的编译器和链接工具的目录。例如，你可能具有复制文件，以便你可以调用该编译器或链接的工具，在命令提示符下设置不路径环境变量相应地。

错误 C1903 Fatal Error C1903 11
无法从以前的错误中恢复；正在停止编译编译器发现太多错误，无法继续。修复错误并重新编译。

错误 C1904 Fatal Error C1904 11
错误的提供程序交互：“”此错误表示特性提供程序失败。注意错误的情况，可尝试隔离问题并创建可重现的测试用例，然后联系与我们交流。

错误 C1905 Fatal Error C1905 11
前端和后端不兼容（必须面向同一处理器）当文件由以一个处理器（如、或）为目标的编译器前端生成，但由以另一个处理器为目标的后端读取时，将发生此错误。若要解决此问题，请确保你使用的前端和后端相匹配。对于中创建的项目，这是默认的。如果已编辑该项目文件并使用通向编译器工具的不同路径，则可能会出现此错误。如果未特别设置编译器工具的路径，则你的安装损坏时可能发生此错误。例如，你可能已将编译器文件从一个位置复制到另一个位置。使用程序和功能控制面板来修复或重新安装中。

错误 C999 Fatal Error C999 11
未知消息请选择技术支持命令的帮助菜单上，或打开技术支持帮助文件了解详细信息此错误通常表示你有具有来自编译器不同版本的混合文件，或者你的编译器安装已损坏。使用程序和功能小程序修复或重新安装产品控制面板中的。